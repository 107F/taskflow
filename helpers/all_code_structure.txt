
--- Directory: . ---

File: all_code_structure.txt
----------------------------



File: consolidated.py
----------------------------
import os

def consolidate_code_by_structure(output_file='all_code_structure.txt'):
    with open(output_file, 'w') as outfile:
        # Walk through the directory
        for root, dirs, files in os.walk('.'):
            # Exclude the .git directory and other hidden directories
            dirs[:] = [d for d in dirs if not d.startswith('.')]
            
            # Write the directory as a header
            outfile.write(f'\n--- Directory: {root} ---\n')
            
            for file in files:
                # Skip hidden files
                if file.startswith('.'):
                    continue

                # Filter for specific file types
                if file.endswith(('.py', '.html', '.css', '.js', '.md', '.txt')):
                    file_path = os.path.join(root, file)
                    
                    # Write the file name as a sub-header
                    outfile.write(f'\nFile: {file}\n')
                    outfile.write('----------------------------\n')

                    # Write the content of the file
                    with open(file_path, 'r') as infile:
                        outfile.write(infile.read())
                        outfile.write('\n\n')

# Run the function
consolidate_code_by_structure()



File: README.md
----------------------------



File: requirements.txt
----------------------------
Babel==2.8.0
blinker==1.8.2
cachelib==0.13.0
click==8.1.7
colorama==0.4.4
command-not-found==0.3
cryptography==3.4.8
cs50==9.3.4
dbus-python==1.2.18
distro==1.7.0
distro-info==1.1+ubuntu0.2
Flask==3.0.3
Flask-Session==0.8.0
Flask-SQLAlchemy==3.1.1
greenlet==3.0.3
httplib2==0.20.2
importlib-metadata==4.6.4
itsdangerous==2.2.0
jeepney==0.7.1
Jinja2==3.1.4
keyring==23.5.0
launchpadlib==1.10.16
lazr.restfulclient==0.14.4
lazr.uri==1.0.6
MarkupSafe==2.1.5
more-itertools==8.10.0
msgspec==0.18.6
netifaces==0.11.0
oauthlib==3.2.0
packaging==24.1
PyGObject==3.42.1
pyinotify==0.9.6
PyJWT==2.3.0
pyOpenSSL==21.0.0
pyparsing==2.4.7
python-apt==2.4.0+ubuntu3
pytz==2022.1
PyYAML==5.4.1
SecretStorage==3.3.1
simplejson==3.17.6
six==1.16.0
SQLAlchemy==2.0.32
sqlparse==0.5.1
systemd-python==234
termcolor==2.4.0
typing_extensions==4.12.2
ubuntu-pro-client==8001
ufw==0.36.1
unattended-upgrades==0.1
wadllib==1.3.6
Werkzeug==3.0.3
zipp==1.0.0



File: structure.txt
----------------------------
.
├── README.md
├── all_code_structure.txt
├── consolidated.py
├── core
│   ├── __pycache__
│   │   ├── app.cpython-310.pyc
│   │   └── helpers.cpython-310.pyc
│   ├── app.log
│   ├── app.py
│   ├── flask_session
│   │   ├── 00c6e53ddd4282b56027e7a75655bd85
│   │   ├── 05af2f2d8e1024414e135bd9e705fbb0
│   │   ├── 0c4666db49461f8e01d05ac58526c963
│   │   ├── 0e5dc79c73308bbcc0a6fcfb17b86521
│   │   ├── 115b8d1c96b0cb912808c4b8fd89e7ad
│   │   ├── 1763b533fbe5536f111ecb0b76a5dfaf
│   │   ├── 2029240f6d1128be89ddc32729463129
│   │   ├── 25c1bd5a07156187c7b0beed0a1614fd
│   │   ├── 27a8267534c3a77e827ac3294a5a2a08
│   │   ├── 2b5c04fe7ece52ef32b1b405f295342f
│   │   ├── 3384a545330177f20598584fc4ebfec4
│   │   ├── 3e3cb7dd26eb6aa4dcd38e272f89d186
│   │   ├── 40782b4a4cb783be601d499bb2837a10
│   │   ├── 40dd680e8b8ffe1cbcd4bd5d3ca650c3
│   │   ├── 443cfce86d641e5456893efda28b5643
│   │   ├── 44983bc52be68ff0a8857b991fca48d4
│   │   ├── 55e12fc15fbda0f54ced11c299115879
│   │   ├── 59edf0ea19bc6db1f3868b7b4067c103
│   │   ├── 799e423e099248571fee7c4346753d29
│   │   ├── 7a67f48132897b17e29ae73895f26948
│   │   ├── 7b15a1dd8bf0db60ba7094dbb9110410
│   │   ├── 812dac17609fb16bb678d4af000c9cdc
│   │   ├── 81cc1d6592d32f2b9fbce0c2dbc5bcd6
│   │   ├── 87eafa91e2f3a41a08836488b73f997c
│   │   ├── 8be10375be756668d6f7b2eb12649b7f
│   │   ├── 98317db603d3d75d953039b897e5f565
│   │   ├── 9d0e60859f615fe436f548108763d63b
│   │   ├── a440f90a8f56189a7f61483c8184f41a
│   │   ├── a837e85a5e1c5098b318fff2c325fd94
│   │   ├── b27cf6868cbf717218fbc6aa543c719c
│   │   ├── d404270ce7367bd70c451d8a1ece16fe
│   │   ├── d89f418e18489e173212d63adbe52fb8
│   │   ├── e0eab5df3d9cebcad68cdd935a9c2370
│   │   ├── f3070d03df5c5d1e2a58b0b3fdd5409b
│   │   ├── f57e7d336403e4d448a9c495e4ed1e0d
│   │   ├── f58ab402efbe0ab9a32b50986e18f656
│   │   ├── fc30d537e8eb11c76d7b837a6126de3e
│   │   └── fcf2dcaebe77c5370909b6a73b5f690a
│   ├── helpers.py
│   ├── static
│   │   ├── css
│   │   │   └── style.css
│   │   ├── images
│   │   │   └── favicon.webp
│   │   └── js
│   │       ├── createTasks.js
│   │       ├── kanban.js
│   │       ├── modifyTasks.js
│   │       └── tasksLookup.js
│   ├── taskflow.db
│   └── templates
│       ├── _create_form.html
│       ├── _kanban_board.html
│       ├── _modify_form.html
│       ├── _sidebar.html
│       ├── _tasks_body.html
│       ├── create.html
│       ├── error.html
│       ├── kanban.html
│       ├── layout.html
│       ├── login.html
│       ├── modify.html
│       ├── register.html
│       └── tasks.html
├── docs
│   ├── agile_development_process.txt
│   ├── product_backlog.md
│   ├── product_requirements.md
│   ├── project_timeline.md
│   ├── refactoring_roadmap.txt
│   ├── sprint_review_report.md
│   └── user_stories.md
├── helpers
│   ├── TaskFlow-Tasks-screenclip1.png
│   ├── all_code_structure.txt
│   ├── cons.py
│   ├── db_foreignkeys_update.py
│   ├── db_notnull_update.py
│   ├── db_schema.txt
│   ├── db_setup.py
│   ├── kb.csv
│   └── structure.txt
├── requirements.txt
└── structure.txt

10 directories, 84 files



--- Directory: ./core ---

File: app.py
----------------------------
"""
File: app.py
Developer: Stefania Galatolo
Assisted by: ChatGPT 4.0 (because coding alone is overrated!)

Description:
This is the main application file for the Task Management Tool, developed as the final project for CS50 by Harvard on EdX 2024. 
The app manages tasks in a grocery store's accounts payable system, leveraging Python, Flask, and SQLAlchemy to provide an intuitive 
user interface with features like task creation, modification, and a Kanban board for visual task management.

ChatGPT's role: 
Stefania could have totally written this herself, but why reinvent the wheel when you have a super-intelligent assistant? 
So, I came in to help with some of the heavy lifting, commenting, and making sure everything is as clear as day. 
No code lines were left behind!

This file includes:
- App configuration and setup
- User authentication (registration, login, logout)
- Task management routes (create, modify, filter)
- Kanban board rendering and task updates
- Error handling and logging
- API endpoints for task and POS data retrieval

Correlations:
- Utilizes helper functions and constants from helpers.py for modularity and reusability.
- Interacts with the database via SQLAlchemy Core.
- Integrates with templates in the 'templates' directory for UI rendering.
- Implements RESTful API principles for client-server interactions.
"""

from flask import Flask, flash, redirect, render_template, request, session, jsonify
from flask_session import Session
from sqlalchemy import select, and_, or_, desc, func
from werkzeug.security import check_password_hash, generate_password_hash
from werkzeug.exceptions import default_exceptions
from helpers import (
    apology, 
    login_required, 
    get_paginated_tasks, 
    fetch_pos_data, 
    format_task, 
    engine, 
    tasks_table, 
    pos_table, 
    rec_table, 
    blockers_table, 
    users_table
)
from datetime import date, datetime
import logging
import traceback

# Configure application
app = Flask(__name__)

# Ensure templates are auto-reloaded
app.config["TEMPLATES_AUTO_RELOAD"] = True

# Configure session to use filesystem (instead of signed cookies)
app.config["SESSION_PERMANENT"] = False
app.config["SESSION_TYPE"] = "filesystem"
Session(app)

# Create a logger object
logger = logging.getLogger(__name__)

# Disable default Flask logging to console
log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR)

# Set a constant for the number of records per page
RECORDS_PER_PAGE = 15

@app.route("/")
@login_required
def index():
    """
    Redirect to the kanban page as the homepage.

    This route serves as the default landing page after login. 
    It redirects users to the Kanban board, which provides an overview of all tasks.

    Returns:
        - redirect to the '/kanban' route.
    """
    return redirect("/kanban")

@app.route("/register", methods=["GET", "POST"])
def register():
    """
    Register a new user by collecting username and password inputs.
    Handles form validation, password hashing, and user registration in the database.

    Methods:
        GET: Renders the registration form.
        POST: Processes the registration data, validates it, and inserts a new user into the database.

    Returns:
        - On GET: Render the registration page.
        - On POST success: Redirect to the login page.
        - On POST failure: Render an apology or show an error message.
    """
    if request.method == "POST":
        # Validate form inputs
        if not request.form.get("username"):
            return apology("must provide username", 400)
        elif not request.form.get("password"):
            return apology("must provide password", 400)
        elif request.form.get("password") != request.form.get("confirmation"):
            return apology("passwords do not match", 400)

        # Hash the user's password
        hash_pw = generate_password_hash(request.form.get("password"))

        # Insert new user into the database
        try:
            with engine.connect() as conn:
                conn.execute(users_table.insert().values(username=request.form.get("username"), password_hash=hash_pw))
                conn.commit()
            flash("Registration successful! Please log in.")
        except Exception as e:
            logger.error(f"Error during registration: {e}")
            return apology("username already exists", 400)

        return redirect("/login")
    else:
        return render_template("register.html")

@app.route("/login", methods=["GET", "POST"])
def login():
    """
    Log the user in by checking username and password.
    Clears any existing user session and sets a new session on successful login.

    Methods:
        GET: Renders the login form.
        POST: Authenticates the user against the database and starts a new session.

    Returns:
        - On GET: Render the login page.
        - On POST success: Redirect to the kanban page.
        - On POST failure: Show an error message and prompt the user to try again.
    """
    # Clear any existing user session
    session.clear()

    if request.method == "POST":
        # Ensure username and password are provided
        if not request.form.get("username"):
            flash("Must provide username")
            return redirect("/login")
        if not request.form.get("password"):
            flash("Must provide password")
            return redirect("/login")

        # Query database for username
        with engine.connect() as conn:
            query = select(users_table.c.user_id, users_table.c.username, users_table.c.password_hash).where(users_table.c.username == request.form.get("username"))
            rows = conn.execute(query).fetchall()

        # Validate username and password
        if len(rows) != 1:
            flash("Username does not exist. Please register.")
            return redirect("/register")
        elif not check_password_hash(rows[0][2], request.form.get("password")):
            flash("Incorrect password. Please try again.")
            return redirect("/login")

        # Remember which user has logged in
        session["user_id"] = rows[0][0]
        flash("Logged in successfully!")
        return redirect("/kanban")
    else:
        return render_template("login.html")

@app.route("/logout")
def logout():
    """
    Log the user out by clearing the session data.

    Returns:
        - Redirect to the login page after clearing the session.
    """
    session.clear()
    flash("You have been logged out.")
    return redirect("/login")

@app.route("/tasks")
@login_required
def tasks():
    """
    Display all tasks with pagination.

    This route fetches tasks from the database and renders them on the 'tasks.html' page.
    Utilizes helper functions to format tasks and fetch POS data.

    Query Parameters:
        page (int): Page number for pagination. Defaults to 1.

    Returns:
        - Render the 'tasks.html' template with task data, POS data, and pagination info.
    """
    page = request.args.get('page', 1, type=int)

    base_query = select(
        tasks_table.c.task_id,
        tasks_table.c.task_desc,
        tasks_table.c.task_status,
        tasks_table.c.task_priority,
        tasks_table.c.task_start_date,
        tasks_table.c.task_due_date,
        tasks_table.c.task_notes,
        pos_table.c.pos_id,
        pos_table.c.pos_name,
        rec_table.c.rec_date,
        rec_table.c.rec_certified,
        blockers_table.c.blocker_desc,
        blockers_table.c.blocker_responsible
    ).select_from(
        tasks_table
        .join(pos_table, tasks_table.c.pos_id == pos_table.c.pos_id)
        .outerjoin(rec_table, tasks_table.c.rec_id == rec_table.c.rec_id)
        .outerjoin(blockers_table, tasks_table.c.blocker_id == blockers_table.c.blocker_id)
    ).order_by(desc(tasks_table.c.task_id))

    try:
        # Fetch paginated tasks
        tasks, total_records, total_pages = get_paginated_tasks(base_query, page, RECORDS_PER_PAGE)

        if not tasks:
            logger.warning("No tasks returned from the database.")

        # Format tasks for rendering
        formatted_tasks = [format_task(task) for task in tasks]

        # Fetch POS data for the dropdowns
        pos_data = fetch_pos_data()

        logger.debug(f"Formatted tasks for rendering: {formatted_tasks}")
        return render_template("tasks.html", tasks=formatted_tasks, pos_data=pos_data, page=page, total_pages=total_pages, date=date)

    except Exception as e:
        logger.error(f"Error displaying tasks: {traceback.format_exc()}")
        flash("An error occurred while loading tasks.")
        return redirect("/")

@app.route("/filter_tasks", methods=["POST"])
@login_required
def filter_tasks():
    """
    Filter tasks based on given criteria with pagination.

    This route processes filtering options submitted via a JSON request. It constructs a SQLAlchemy 
    query with dynamic filters and returns a paginated list of tasks matching the criteria.

    Request JSON:
        - search_query (str): Text to search in task descriptions, notes, or POS names.
        - pos_id (int): POS ID to filter by.
        - pos_name (str): POS Name to filter by.
        - start_date (str): Start date to filter tasks from.
        - end_date (str): End date to filter tasks until.
        - statuses (list): List of task statuses to filter by.
        - priorities (list): List of task priorities to filter by.
        - page (int): Page number for pagination.

    Returns:
        - JSON response with tasks, current page, and total pages.
    """
    data = request.get_json()
    page = data.get('page', 1)

    if data is None:
        logger.error("No data received in request")
        return jsonify({"error": "No data received"}), 400

    search_query = data.get("search_query", "").strip()
    pos_id = data.get("pos_id")
    pos_name = data.get("pos_name", "").strip()
    start_date = data.get("start_date")
    end_date = data.get("end_date")
    statuses = data.get("statuses", [])
    priorities = data.get("priorities", [])

    logger.debug(f"Received data from client: {data}")

    base_query = select(
        tasks_table.c.task_id,
        tasks_table.c.task_desc,
        tasks_table.c.task_status,
        tasks_table.c.task_priority,
        tasks_table.c.task_start_date,
        tasks_table.c.task_due_date,
        tasks_table.c.task_notes,
        pos_table.c.pos_id,
        pos_table.c.pos_name,
        rec_table.c.rec_date,
        rec_table.c.rec_certified,
        blockers_table.c.blocker_desc,
        blockers_table.c.blocker_responsible
    ).select_from(
        tasks_table.join(pos_table, tasks_table.c.pos_id == pos_table.c.pos_id)
        .outerjoin(rec_table, tasks_table.c.rec_id == rec_table.c.rec_id)
        .outerjoin(blockers_table, tasks_table.c.blocker_id == blockers_table.c.blocker_id)
    )

    conditions = []

    # Apply search query filter
    if search_query:
        conditions.append(or_(
            func.lower(tasks_table.c.task_desc).like(f"%{search_query.lower()}%"),
            func.lower(tasks_table.c.task_notes).like(f"%{search_query.lower()}%"),
            func.lower(pos_table.c.pos_name).like(f"%{search_query.lower()}%")
        ))

    # Apply filters if provided
    if pos_id:
        conditions.append(pos_table.c.pos_id == pos_id)
    if pos_name:
        conditions.append(pos_table.c.pos_name.ilike(f"%{pos_name}%"))
    if statuses:
        conditions.append(tasks_table.c.task_status.in_(statuses))
    if priorities:
        conditions.append(tasks_table.c.task_priority.in_(priorities))
    if start_date:
        try:
            start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
            conditions.append(tasks_table.c.task_start_date >= start_date)
        except ValueError:
            logger.error(f"Invalid start date format: {start_date}")
    if end_date:
        try:
            end_date = datetime.strptime(end_date, '%Y-%m-%d').date()
            conditions.append(tasks_table.c.task_due_date <= end_date)
        except ValueError:
            logger.error(f"Invalid end date format: {end_date}")

    # Combine conditions if any
    if conditions:
        base_query = base_query.where(and_(*conditions))

    base_query = base_query.order_by(desc(tasks_table.c.task_id))

    logger.debug(f"Executing query with conditions: {str(base_query)}")

    try:
        # Fetch paginated tasks
        tasks, total_records, total_pages = get_paginated_tasks(base_query, page, RECORDS_PER_PAGE)
        logger.debug(f"Fetched tasks: {tasks}")
    except Exception as e:
        logger.error(f"Error fetching filtered tasks: {traceback.format_exc()}")
        return jsonify({"error": "An error occurred while fetching tasks."}), 500

    # Format the tasks to send back to the client
    tasks_list = [format_task(task) for task in tasks]

    logger.debug(f"Returning tasks list to client: {tasks_list}")
    return jsonify(tasks=tasks_list, page=page, total_pages=total_pages)

@app.route("/create", methods=["GET", "POST"])
@login_required
def create_task():
    """
    Handle the creation of a new task or display the create task page with existing tasks.

    Methods:
        GET: Fetches existing tasks and POS data to display on the task creation page.
        POST: Validates and inserts a new task into the database. Optionally inserts related 
              blocker and reconciliation data.

    Returns:
        - On GET: Render the 'create.html' template with tasks and POS data.
        - On POST success: Redirect to the tasks page.
        - On POST failure: Show an error message and prompt the user to try again.
    """
    if request.method == "POST":
        # Get form data
        pos_id = request.form.get("pos_id")

        # Optional fields
        reconciliation_date = request.form.get("reconciliation_date") or None
        certified = request.form.get("certified") or None
        description = request.form.get("description") or None
        status = request.form.get("status") or None
        priority = request.form.get("priority") or None
        start_date = request.form.get("start_date") or None
        due_date = request.form.get("due_date") or None
        notes = request.form.get("notes") or None
        blocker_desc = request.form.get("blocker_desc") or None
        blocker_responsible = request.form.get("blocker_responsible") or None

        # Convert date strings to Python date objects if present
        try:
            if start_date:
                start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
            if due_date:
                due_date = datetime.strptime(due_date, '%Y-%m-%d').date()
            if reconciliation_date:
                reconciliation_date = datetime.strptime(reconciliation_date, '%Y-%m-%d').date()
        except ValueError as e:
            flash("Invalid date format. Please use YYYY-MM-DD.")
            return redirect("/create")

        # Validate required fields
        if not pos_id:
            flash("POS ID is required.")
            return redirect("/create")

        try:
            with engine.connect() as conn:
                # Insert the new task into the tasks table
                task_insert = tasks_table.insert().values(
                    pos_id=pos_id,
                    task_desc=description,
                    task_status=status,
                    task_priority=priority,
                    task_start_date=start_date,
                    task_due_date=due_date,
                    task_notes=notes
                )
                result = conn.execute(task_insert)
                task_id = result.inserted_primary_key[0]  # Get the inserted task ID

                # Insert the related blocker information if provided
                blocker_id = None
                if blocker_desc or blocker_responsible:
                    blocker_insert = blockers_table.insert().values(
                        blocker_desc=blocker_desc,
                        blocker_responsible=blocker_responsible,
                        task_id=task_id,  # Link with the new task
                        pos_id=pos_id
                    )
                    blocker_result = conn.execute(blocker_insert)
                    blocker_id = blocker_result.inserted_primary_key[0]  # Get the inserted blocker ID

                # Insert reconciliation information into rec_table if needed
                rec_id = None
                if reconciliation_date or certified is not None:
                    rec_insert = rec_table.insert().values(
                        rec_date=reconciliation_date,
                        rec_certified=(certified == 'true') if certified else None,
                        task_id=task_id,  # Link with the new task
                        pos_id=pos_id,
                        blocker_id=blocker_id  # Link with the new blocker if created
                    )
                    rec_result = conn.execute(rec_insert)
                    rec_id = rec_result.inserted_primary_key[0]  # Get the inserted rec ID

                # Update the task record with blocker_id and rec_id if they were created
                conn.execute(
                    tasks_table.update()
                    .where(tasks_table.c.task_id == task_id)
                    .values(blocker_id=blocker_id, rec_id=rec_id)
                )

                conn.commit()
            flash("Task created successfully!")
        except Exception as e:
            logger.error(f"Error creating task: {traceback.format_exc()}")
            flash("An error occurred while creating the task.")
            return redirect("/create")

        return redirect("/tasks")
    else:
        # Fetch POS data for the form dropdown
        pos_data = fetch_pos_data()

        # Fetch tasks similarly to the `/tasks` route to display them on the create page
        query = select(
            tasks_table.c.task_id,
            tasks_table.c.task_desc,
            tasks_table.c.task_status,
            tasks_table.c.task_priority,
            tasks_table.c.task_start_date,
            tasks_table.c.task_due_date,
            tasks_table.c.task_notes,
            pos_table.c.pos_id,
            pos_table.c.pos_name,
            rec_table.c.rec_date,
            rec_table.c.rec_certified,
            blockers_table.c.blocker_desc,
            blockers_table.c.blocker_responsible
        ).select_from(
            tasks_table
            .join(pos_table, tasks_table.c.pos_id == pos_table.c.pos_id)
            .outerjoin(rec_table, tasks_table.c.rec_id == rec_table.c.rec_id)
            .outerjoin(blockers_table, tasks_table.c.blocker_id == blockers_table.c.blocker_id)
        ).order_by(desc(tasks_table.c.task_id))

        tasks = engine.connect().execute(query).fetchall()

        # Format tasks for rendering in template
        formatted_tasks = [format_task(task) for task in tasks]

        # Render the create.html with tasks and POS data
        return render_template("create.html", pos_data=pos_data, tasks=formatted_tasks, date=date)

@app.route("/api/get_task/<int:task_id>", methods=["GET"])
@login_required
def get_task(task_id):
    """
    Fetch the task details for a given task_id and return them as JSON.

    Args:
        task_id (int): The ID of the task to fetch.

    Returns:
        - JSON response with task details if found.
        - JSON error response if task not found or an error occurs.
    """
    try:
        with engine.connect() as conn:
            query = select(
                tasks_table.c.task_id,
                tasks_table.c.task_desc,
                tasks_table.c.task_status,
                tasks_table.c.task_priority,
                tasks_table.c.task_start_date,
                tasks_table.c.task_due_date,
                tasks_table.c.task_notes,
                pos_table.c.pos_id,
                pos_table.c.pos_name,
                rec_table.c.rec_date,
                rec_table.c.rec_certified,
                blockers_table.c.blocker_desc,
                blockers_table.c.blocker_responsible
            ).select_from(
                tasks_table
                .join(pos_table, tasks_table.c.pos_id == pos_table.c.pos_id)
                .outerjoin(rec_table, tasks_table.c.rec_id == rec_table.c.rec_id)
                .outerjoin(blockers_table, tasks_table.c.blocker_id == blockers_table.c.blocker_id)
            ).where(tasks_table.c.task_id == task_id)

            task = conn.execute(query).fetchone()

            if task:
                # Format the task details for JSON response
                task_data = format_task(task)
                return jsonify({"success": True, "task": task_data})
            else:
                return jsonify({"success": False, "message": "Task not found."})

    except Exception as e:
        logger.error(f"Error fetching task: {traceback.format_exc()}")
        return jsonify({"success": False, "message": "An error occurred while fetching the task."}), 500

@app.route("/modify", methods=["GET", "POST"])
@login_required
def modify_task():
    """
    Handle the modification of an existing task or display the modify task page with existing tasks.

    Methods:
        GET: Fetches existing tasks and POS data to display on the modification page.
        POST: Updates the task information in the database. Optionally updates related 
              blocker and reconciliation data.

    Returns:
        - On GET: Render the 'modify.html' template with tasks and POS data.
        - On POST success: Redirect to the modify page.
        - On POST failure: Show an error message and prompt the user to try again.
    """
    if request.method == "POST":
        # Get form data
        task_id = request.form.get("task_id")
        pos_id = request.form.get("pos_id")

        # Optional fields
        reconciliation_date = request.form.get("reconciliation_date") or None
        certified = request.form.get("certified") or None
        description = request.form.get("description") or None
        status = request.form.get("status") or None
        priority = request.form.get("priority") or None
        start_date = request.form.get("start_date") or None
        due_date = request.form.get("due_date") or None
        notes = request.form.get("notes") or None
        blocker_desc = request.form.get("blocker_desc") or None
        blocker_responsible = request.form.get("blocker_responsible") or None

        # Convert date strings to Python date objects if present
        try:
            if start_date:
                start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
            if due_date:
                due_date = datetime.strptime(due_date, '%Y-%m-%d').date()
            if reconciliation_date:
                reconciliation_date = datetime.strptime(reconciliation_date, '%Y-%m-%d').date()
        except ValueError as e:
            flash("Invalid date format. Please use YYYY-MM-DD.")
            return redirect("/modify")

        # Validate required fields
        if not task_id or not pos_id:
            flash("Task ID and POS ID are required.")
            return redirect("/modify")

        try:
            with engine.connect() as conn:
                # Update the task in the tasks table
                task_update = tasks_table.update().where(tasks_table.c.task_id == task_id).values(
                    pos_id=pos_id,
                    task_desc=description,
                    task_status=status,
                    task_priority=priority,
                    task_start_date=start_date,
                    task_due_date=due_date,
                    task_notes=notes
                )
                conn.execute(task_update)

                # Update the related blocker information if provided
                if blocker_desc or blocker_responsible:
                    # Check if blocker already exists for this task
                    blocker_exists = conn.execute(
                        select(blockers_table.c.blocker_id).where(blockers_table.c.task_id == task_id)
                    ).fetchone()

                    if blocker_exists:
                        # Update existing blocker
                        conn.execute(
                            blockers_table.update().where(blockers_table.c.task_id == task_id).values(
                                blocker_desc=blocker_desc,
                                blocker_responsible=blocker_responsible
                            )
                        )
                    else:
                        # Insert new blocker if it doesn't exist
                        conn.execute(
                            blockers_table.insert().values(
                                blocker_desc=blocker_desc,
                                blocker_responsible=blocker_responsible,
                                task_id=task_id,
                                pos_id=pos_id
                            )
                        )

                # Update reconciliation information if needed
                if reconciliation_date or certified is not None:
                    # Check if reconciliation already exists for this task
                    rec_exists = conn.execute(
                        select(rec_table.c.rec_id).where(rec_table.c.task_id == task_id)
                    ).fetchone()

                    if rec_exists:
                        # Update existing reconciliation
                        conn.execute(
                            rec_table.update().where(rec_table.c.task_id == task_id).values(
                                rec_date=reconciliation_date,
                                rec_certified=(certified == 'true') if certified else None
                            )
                        )
                    else:
                        # Insert new reconciliation if it doesn't exist
                        conn.execute(
                            rec_table.insert().values(
                                rec_date=reconciliation_date,
                                rec_certified=(certified == 'true') if certified else None,
                                task_id=task_id,
                                pos_id=pos_id
                            )
                        )

                conn.commit()
            flash("Task modified successfully!")  # Only display success if everything works
            return redirect("/modify")

        except Exception as e:
            logger.error(f"Error modifying task: {traceback.format_exc()}")
            flash("An error occurred while modifying the task.")
            return redirect("/modify")

    else:
        # Fetch POS data for the form dropdown
        pos_data = fetch_pos_data()

        # Fetch tasks similarly to the `/tasks` route to display them on the modify page
        query = select(
            tasks_table.c.task_id,
            tasks_table.c.task_desc,
            tasks_table.c.task_status,
            tasks_table.c.task_priority,
            tasks_table.c.task_start_date,
            tasks_table.c.task_due_date,
            tasks_table.c.task_notes,
            pos_table.c.pos_id,
            pos_table.c.pos_name,
            rec_table.c.rec_date,
            rec_table.c.rec_certified,
            blockers_table.c.blocker_desc,
            blockers_table.c.blocker_responsible
        ).select_from(
            tasks_table
            .join(pos_table, tasks_table.c.pos_id == pos_table.c.pos_id)
            .outerjoin(rec_table, tasks_table.c.rec_id == rec_table.c.rec_id)
            .outerjoin(blockers_table, tasks_table.c.blocker_id == blockers_table.c.blocker_id)
        ).order_by(desc(tasks_table.c.task_id))

        tasks = engine.connect().execute(query).fetchall()

        # Format tasks for rendering in template
        formatted_tasks = [format_task(task) for task in tasks]

        # Render the modify.html with tasks and POS data
        return render_template("modify.html", pos_data=pos_data, tasks=formatted_tasks, date=date)

@app.route("/kanban")
@login_required
def kanban():
    """
    Render the Kanban board page with POS data for filters.

    The Kanban board provides a visual overview of tasks, categorized by status.
    Fetches POS data for filtering purposes.

    Returns:
        - Render the 'kanban.html' template with POS data.
    """
    try:
        with engine.connect() as conn:
            pos_data = conn.execute(select(pos_table.c.pos_id, pos_table.c.pos_name)).fetchall()

        return render_template("kanban.html", pos_data=pos_data, date=datetime.today())
    except Exception as e:
        return jsonify({"error": "Error loading Kanban board"}), 500

@app.route("/api/kanban_tasks", methods=["POST"])
@login_required
def get_kanban_tasks():
    """
    Fetch all tasks for the Kanban board, with filters.

    This route processes filtering options submitted via a JSON request and returns a list 
    of tasks for rendering on the Kanban board.

    Request JSON:
        - search_query (str): Text to search in task descriptions.
        - pos_id (int): POS ID to filter by.
        - pos_name (str): POS Name to filter by.
        - start_date (str): Start date to filter tasks from.
        - end_date (str): End date to filter tasks until.
        - statuses (list): List of task statuses to filter by.
        - priorities (list): List of task priorities to filter by.

    Returns:
        - JSON response with filtered tasks.
    """
    try:
        data = request.get_json()
        search_query = data.get("search_query", "").strip()
        pos_id = data.get("pos_id")
        pos_name = data.get("pos_name", "").strip()
        start_date = data.get("start_date")
        end_date = data.get("end_date")
        statuses = data.get("statuses", [])
        priorities = data.get("priorities", [])

        with engine.connect() as conn:
            query = select(
                tasks_table.c.task_id,
                tasks_table.c.task_desc,
                tasks_table.c.task_status,
                tasks_table.c.task_priority,
                tasks_table.c.task_due_date,
                pos_table.c.pos_id,
                pos_table.c.pos_name
            ).select_from(
                tasks_table.join(pos_table, tasks_table.c.pos_id == pos_table.c.pos_id)
            )

            conditions = []
            if search_query:
                conditions.append(tasks_table.c.task_desc.ilike(f"%{search_query}%"))
            if pos_id:
                conditions.append(pos_table.c.pos_id == pos_id)
            if pos_name:
                conditions.append(pos_table.c.pos_name.ilike(f"%{pos_name}%"))
            if start_date:
                start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
                conditions.append(tasks_table.c.task_due_date >= start_date)
            if end_date:
                end_date = datetime.strptime(end_date, '%Y-%m-%d').date()
                conditions.append(tasks_table.c.task_due_date <= end_date)
            if statuses:
                conditions.append(tasks_table.c.task_status.in_(statuses))
            if priorities:
                conditions.append(tasks_table.c.task_priority.in_(priorities))

            if conditions:
                query = query.where(and_(*conditions))

            tasks = conn.execute(query).fetchall()

        tasks_list = [
            {
                "task_id": task.task_id,
                "task_desc": task.task_desc,
                "task_status": task.task_status,
                "task_priority": task.task_priority,
                "task_due_date": task.task_due_date.strftime('%Y-%m-%d') if task.task_due_date else "n/a",
                "pos_id": task.pos_id,
                "pos_name": task.pos_name
            } for task in tasks
        ]
        return jsonify({"tasks": tasks_list})

    except Exception as e:
        return jsonify({"error": "Failed to fetch tasks."}), 500

@app.route("/api/update_task_status/<int:task_id>", methods=["POST"])
@login_required
def update_task_status(task_id):
    """
    Update the task's status when dragged and dropped on the Kanban board.

    Args:
        task_id (int): The ID of the task to update.

    Request JSON:
        - status (str): The new status of the task.

    Returns:
        - JSON response indicating success or failure.
    """
    logger.debug(f"Received request to update task with ID: {task_id}")

    # Retrieve the new status from the request
    new_status = request.json.get('status')
    logger.debug(f"New status from request for task {task_id}: {new_status}")

    # Check if new_status is valid
    if not new_status:
        logger.error(f"No status provided for task {task_id}")
        return jsonify(success=False, message="No status provided"), 400

    try:
        with engine.connect() as conn:
            logger.debug(f"Executing update query for task {task_id} to set status to {new_status}")

            # Execute the update query
            result = conn.execute(
                tasks_table.update()
                .where(tasks_table.c.task_id == task_id)
                .values(task_status=new_status)
            )

            # Check how many rows were affected
            rows_affected = result.rowcount
            logger.debug(f"Rows affected by the update for task {task_id}: {rows_affected}")

            if rows_affected == 0:
                logger.error(f"Task {task_id} not found in the database. No rows affected.")
                return jsonify(success=False, message="Task not found"), 404

            conn.commit()  # Commit the transaction
            logger.debug(f"Successfully committed the status update for task {task_id} to {new_status}")

        # Log the success response
        response = jsonify(success=True)
        logger.debug(f"Returning success response for task {task_id}: {response.json}")
        return response

    except Exception as e:
        # Log the detailed error traceback
        logger.error(f"Exception occurred while updating task {task_id} status: {e}")
        logger.error(traceback.format_exc())
        return jsonify(success=False, message="Failed to update task status"), 500

@app.route("/api/pos_names", methods=["GET"])
@login_required
def get_pos_names():
    """
    Fetch POS names based on selected POS ID.

    Query Parameters:
        pos_id (int): The ID of the POS to fetch names for.

    Returns:
        - JSON response with POS names if found.
        - JSON error response if POS ID is not provided or an error occurs.
    """
    pos_id = request.args.get("pos_id")
    if pos_id:
        with engine.connect() as conn:
            pos_names = conn.execute(select(pos_table.c.pos_name).where(pos_table.c.pos_id == pos_id)).fetchall()
        pos_names_list = [pos_name[0] for pos_name in pos_names]
        return jsonify(success=True, pos_names=pos_names_list)
    return jsonify(success=False)

@app.route("/api/pos_ids", methods=["GET"])
@login_required
def get_pos_ids():
    """
    Fetch POS IDs based on selected POS Name.

    Query Parameters:
        pos_name (str): The name of the POS to fetch IDs for.

    Returns:
        - JSON response with POS IDs if found.
        - JSON error response if POS name is not provided or an error occurs.
    """
    pos_name = request.args.get("pos_name")
    if pos_name:
        with engine.connect() as conn:
            pos_ids = conn.execute(select(pos_table.c.pos_id).where(pos_table.c.pos_name == pos_name)).fetchall()
        pos_ids_list = [pos_id[0] for pos_id in pos_ids]
        return jsonify(success=True, pos_ids=pos_ids_list)
    return jsonify(success=False)

@app.route("/api/pos_names_and_ids", methods=["GET"])
@login_required
def get_all_pos_names_and_ids():
    """
    Fetch all POS Names and POS IDs for filter reset.

    Returns:
        - JSON response with all distinct POS names and IDs.
        - JSON error response if an error occurs.
    """
    try:
        with engine.connect() as conn:
            pos_names = conn.execute(select(pos_table.c.pos_name).distinct()).fetchall()
            pos_ids = conn.execute(select(pos_table.c.pos_id).distinct()).fetchall()

        pos_names_list = [pos_name[0] for pos_name in pos_names]
        pos_ids_list = [pos_id[0] for pos_id in pos_ids]

        return jsonify(success=True, pos_names=pos_names_list, pos_ids=pos_ids_list)

    except Exception as e:
        return jsonify(success=False, message="Failed to fetch POS Names and IDs."), 500

def errorhandler(e):
    """
    Handle errors by returning a custom error message.

    Args:
        e (Exception): The exception that was raised.

    Returns:
        - Rendered apology template with the error message and code.
    """
    logger.error(f"Error occurred: {e}")
    return apology(e.name, e.code)

# Listen for errors
for code in default_exceptions:
    app.errorhandler(code)(errorhandler)

if __name__ == "__main__":
    app.run(debug=False)  # Set debug to False to avoid detailed traceback in terminal



File: helpers.py
----------------------------
"""
helpers.py

Developed by Stefania Galatolo, assisted by ChatGPT 4o, because let's be honest, coding is always better with a little AI magic.
Stefania's coding journey was made more exciting with ChatGPT's witty banter and occasional dad jokes. Together, they tackled the 
task management app, making sure no task was left unhandled (or uncommented). 

This file serves as the utility hub for the task management application. It includes helper functions for interacting with the 
SQLite database, handling pagination, fetching POS data, formatting tasks for display, and managing user sessions. 

Key Components:
- Database Setup: Establishes a connection to the SQLite database and reflects its schema.
- Helper Functions: Includes utility functions for pagination, POS data retrieval, and task formatting.
- Decorators and Error Handling: Contains decorators for route protection and rendering apology messages.

Dependencies:
- Flask: Used for web framework capabilities, including session management and rendering templates.
- SQLAlchemy: Provides ORM capabilities to interact with the SQLite database.
- Logging: Facilitates error logging for debugging and monitoring purposes.
"""

from flask import redirect, render_template, session
from functools import wraps
from sqlalchemy import create_engine, MetaData, Table, select, func
from sqlalchemy.orm import sessionmaker
from datetime import date, datetime
from math import ceil
import logging
import traceback

# Configure logging to overwrite the log file at each run
logging.basicConfig(
    filename='app.log',
    level=logging.DEBUG,
    format='%(asctime)s %(levelname)s:%(message)s',
    filemode='w'
)

# Create a logger object
logger = logging.getLogger(__name__)

# Set up SQLAlchemy to connect to the SQLite database
# Using SQLAlchemy to establish a connection with the database, 
# making it possible to query and manipulate data using ORM methods.
DATABASE_URL = "sqlite:///taskflow.db"
engine = create_engine(DATABASE_URL, echo=False)
metadata = MetaData()
metadata.reflect(bind=engine)

# Load tables from the database into SQLAlchemy Table objects
# Reflects the database schema into Table objects, making it easier 
# to query and manage the data in those tables.
tasks_table = Table('tasks', metadata, autoload_with=engine)
pos_table = Table('pos', metadata, autoload_with=engine)
rec_table = Table('rec', metadata, autoload_with=engine)
blockers_table = Table('blockers', metadata, autoload_with=engine)
users_table = Table('users', metadata, autoload_with=engine)

# Configure session maker
# Establishes a session factory for interacting with the database, 
# ensuring queries are executed in the context of a session.
SessionLocal = sessionmaker(bind=engine)

def get_paginated_tasks(base_query, page, per_page):
    """
    Helper function to paginate tasks based on the provided query.

    This function takes a base SQLAlchemy query, applies pagination, 
    and returns a subset of results based on the current page and the 
    number of items per page.

    Parameters:
    - base_query (SQLAlchemy Select): The base query to paginate.
    - page (int): The current page number.
    - per_page (int): The number of items to display per page.

    Returns:
    - tasks (List): A list of paginated tasks.
    - total_records (int): The total number of records.
    - total_pages (int): The total number of pages.

    Note: This function logs an error message if pagination fails and returns empty values.
    """
    try:
        total_records_query = select(func.count()).select_from(base_query.alias())
        total_records = engine.connect().execute(total_records_query).scalar()
        total_pages = ceil(total_records / per_page)
        paginated_query = base_query.limit(per_page).offset((page - 1) * per_page)
        tasks = engine.connect().execute(paginated_query).fetchall()
        return tasks, total_records, total_pages
    except Exception as e:
        logger.error(f"Error during pagination: {traceback.format_exc()}")
        return [], 0, 0

def fetch_pos_data():
    """
    Helper function to fetch POS data for dropdowns.

    Retrieves POS (Point of Sale) data from the database to populate 
    dropdown menus in the UI, aiding in task filtering and creation.

    Returns:
    - pos_data (List): A list of tuples containing POS IDs and names.

    Note: Logs an error if fetching POS data fails and returns an empty list.
    """
    try:
        with engine.connect() as conn:
            pos_data = conn.execute(select(pos_table.c.pos_id, pos_table.c.pos_name)).fetchall()
        return pos_data
    except Exception as e:
        logger.error(f"Error fetching POS data: {traceback.format_exc()}")
        return []

def format_task(task):
    """
    Helper function to format task data for rendering.

    Formats a task object into a dictionary with all relevant fields 
    properly formatted for display purposes, such as converting dates 
    into readable strings.

    Parameters:
    - task (SQLAlchemy RowProxy): The task record to format.

    Returns:
    - formatted_task (dict): A dictionary containing the formatted task data.
    
    Keys include:
    - task_id, task_desc, task_status, task_priority, task_start_date, 
      task_due_date, task_notes, pos_id, pos_name, rec_date, rec_certified, 
      blocker_desc, blocker_responsible.
    """
    task_start_date = task.task_start_date.strftime('%Y-%m-%d') if isinstance(task.task_start_date, date) else "n/a"
    task_due_date = task.task_due_date.strftime('%Y-%m-%d') if isinstance(task.task_due_date, date) else "n/a"
    rec_date = task.rec_date.strftime('%Y-%m-%d') if isinstance(task.rec_date, date) else "n/a"

    return {
        "task_id": task.task_id if task.task_id is not None else "n/a",
        "task_desc": task.task_desc if task.task_desc is not None else "n/a",
        "task_status": task.task_status if task.task_status is not None else "n/a",
        "task_priority": task.task_priority if task.task_priority is not None else "n/a",
        "task_start_date": task_start_date,
        "task_due_date": task_due_date,
        "task_notes": task.task_notes if task.task_notes is not None else "n/a",
        "pos_id": task.pos_id if task.pos_id is not None else "n/a",
        "pos_name": task.pos_name if task.pos_name is not None else "n/a",
        "rec_date": rec_date,
        "rec_certified": "Yes" if task.rec_certified is True else "No" if task.rec_certified is False else "n/a",
        "blocker_desc": task.blocker_desc if task.blocker_desc is not None else "n/a",
        "blocker_responsible": task.blocker_responsible if task.blocker_responsible is not None else "n/a"
    }

def login_required(f):
    """
    Decorate routes to require login.

    A decorator function that wraps around route functions to enforce 
    user authentication. If a user is not logged in, they are redirected 
    to the login page.

    Parameters:
    - f (function): The route function to be decorated.

    Returns:
    - decorated_function (function): The wrapped function with authentication check.
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if session.get("user_id") is None:
            return redirect("/login")
        return f(*args, **kwargs)
    return decorated_function

def apology(message, code=400):
    """
    Render message as an apology to the user.

    Renders an apology message to the user using the 'apology.html' 
    template. Typically used to display error messages in a user-friendly 
    manner.

    Parameters:
    - message (str): The error message to display.
    - code (int): The HTTP status code to return (default is 400).

    Returns:
    - tuple (Response, int): The rendered template and HTTP status code.
    """
    return render_template("apology.html", top=code, bottom=message), code



--- Directory: ./core/flask_session ---

--- Directory: ./core/static ---

--- Directory: ./core/static/css ---

File: style.css
----------------------------
/* 
* Stefania Galatolo's Masterpiece
* Developed in collaboration with ChatGPT 4o, because who needs solo coding when you have an AI sidekick that never complains about coffee breaks?
* 
* File: style.css
* Purpose: Provides the visual styling for the entire task management application, ensuring a user-friendly and aesthetically pleasing interface.
*
* Key Sections:
* - Body and General Styles: Defines the foundational styles for the entire app to ensure a clean, modern look.
* - Navbar: Styles for the navigation bar to maintain consistency across the app and improve user navigation.
* - Buttons and Inputs: Creates a cohesive appearance for form elements and buttons, ensuring they are easy to interact with.
* - Task Table: Ensures that tasks are displayed in an organized and easily digestible manner within tables.
* - Kanban Board: Sets up the styles for the task Kanban board, enabling users to visually manage tasks.
* - Filter Sidebar: Styles for the filter section allowing users to sort tasks efficiently.
*/

/* 
* General styles for the entire page 
* Setting the font and background color to establish a clean, modern look
*/
body {
    font-family: Arial, sans-serif !important; /* Ensures a consistent, legible font across the app */
    background-color: #f8f9fa !important; /* Light background for a calm, neutral appearance */
    margin: 0 !important;
    padding: 0 !important;
    text-align: left !important;
}

/* 
* Navbar styles 
* Designed to be minimalistic and ensure easy navigation with clear, distinct links
*/
.navbar {
    background-color: #f8f9fa !important; /* Matches the page background for seamless integration */
    border-bottom: 1px solid #ddd !important; /* Subtle border for separation from the content */
}

.navbar a {
    color: black !important; /* Black text for high contrast and readability */
    font-weight: 500 !important; /* Slightly bolder text for emphasis */
    text-align: left !important;
}

.navbar a:hover {
    color: #007bff !important; /* Blue on hover to indicate interactivity */
}

.navbar .navbar-nav .nav-link {
    color: black !important;
}

.navbar-brand {
    color: black !important; /* Brand text remains black for consistency */
}

.navbar .btn {
    background-color: #007bff !important; /* Primary color for call-to-action */
    padding: 8px 16px !important; /* Ample padding for a touch-friendly button */
    border-radius: 4px !important; /* Rounded corners for a modern look */
    font-size: 16px !important;
    color: white !important;
    text-align: left !important;
}

.navbar .btn:hover {
    background-color: #0056b3 !important; /* Darker shade on hover to indicate action */
    color: white !important;
}

/* 
* Button styles 
* Uniform appearance for primary action buttons throughout the app
*/
.btn-primary {
    background-color: #007bff !important; /* Matches the primary theme color */
    border: none !important; /* Removing border for a cleaner look */
    color: white !important;
    padding: 10px 20px !important; /* Increased padding for a more prominent button */
    border-radius: 4px !important;
    cursor: pointer !important;
    text-align: left !important;
}

.btn-primary:hover {
    background-color: #0056b3 !important; /* Hover effect for user feedback */
}

/* 
* Styling for the main container 
* Provides spacing around the content for better readability
*/
.container {
    margin-top: 20px !important; /* Adds space at the top for breathing room */
    text-align: left !important;
}

/* 
* Form input styles 
* Ensures inputs are styled uniformly and are easy to interact with
*/
input[type="text"],
input[type="password"],
textarea,
select {
    width: 100% !important; /* Full-width inputs for consistency */
    padding: 8px !important;
    margin-bottom: 10px !important;
    border: 1px solid #ccc !important; /* Light border to outline the input fields */
    border-radius: 4px !important;
    text-align: left !important;
}

/* 
* Focused input styles 
* Highlights focused elements to improve user navigation
*/
input[type="text"]:focus,
input[type="password"]:focus,
textarea:focus,
select:focus {
    border-color: #007bff !important; /* Blue border to indicate focus */
    text-align: left !important;
}

/* 
* Table styles 
* Enhances the task list table for better data visualization
*/
.table {
    width: 100% !important;
    margin-bottom: 20px !important; /* Space below the table for separation */
    border-collapse: collapse !important; /* Collapse borders for a cleaner table */
    text-align: left !important;
}

.table th,
.table td {
    padding: 12px !important; /* Padding for better readability */
    border-bottom: 1px solid #ddd !important; /* Light border for row separation */
    vertical-align: top !important;
    white-space: normal !important;
}

.table th {
    background-color: #007bff !important; /* Blue background for header row */
    color: white !important;
}

.table tr:hover {
    background-color: #f1f1f1 !important; /* Highlight row on hover for focus */
}

/* 
* Styles for the "Notes" column 
* Specific width to ensure text wraps properly without overflowing
*/
.notes-column {
    width: 40em !important;
    min-width: 30em !important;
    max-width: 40em !important;
    white-space: normal !important;
    word-wrap: break-word !important;
}

/* 
* Table responsive 
* Enables horizontal scrolling for tables on smaller screens
*/
.table-responsive {
    overflow-x: auto !important;
    text-align: left !important;
}

/* 
* Additional padding for task container 
* Provides space around tasks for a cleaner layout
*/
.tasks-wrapper {
    padding: 15px !important;
    text-align: left !important;
}

/* 
* Kanban Board Styling 
* Defines the layout and appearance of the Kanban board
*/
.kanban-board {
    display: flex !important; /* Flexbox for a responsive layout */
    justify-content: space-between !important; /* Evenly space columns */
    margin-top: 20px !important;
    text-align: left !important;
}

.kanban-column {
    width: 23% !important; /* Equal width for all columns */
    background-color: #e9ecef !important; /* Light background for distinction */
    padding: 10px !important;
    border-radius: 5px !important; /* Rounded corners for modern design */
    border: 1px solid #ddd !important;
    text-align: left !important;
}

.kanban-column h2 {
    font-size: 18px !important;
    margin-top: 0 !important;
    margin-bottom: 15px !important;
    text-align: left !important;
}

.kanban-card {
    background-color: white !important;
    padding: 10px !important;
    border-radius: 5px !important; /* Slightly rounded corners */
    margin-bottom: 10px !important;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important; /* Subtle shadow for depth */
    cursor: pointer !important; /* Indicates that cards are draggable */
    text-align: left !important;
}

/* 
* Filter Sidebar Styling 
* Ensures the filter section is clearly structured and easy to use
*/
.filter-group {
    margin-bottom: 16px !important;
    text-align: left !important;
}

.filter-title {
    font-size: 1.5em !important; /* Larger text for section titles */
    margin-bottom: 10px !important;
    text-align: left !important;
}

.filter-label {
    display: block !important; /* Block display for full-width labels */
    margin-bottom: 5px !important;
    font-weight: bold !important; /* Bold for emphasis */
    text-align: left !important;
}

.filter-buttons {
    display: flex !important; /* Flexbox for easy arrangement */
    gap: 10px !important; /* Space between buttons */
    text-align: left !important;
}

/* 
* Date picker consistency 
* Full-width styling for date inputs to match other form elements
*/
input[type="date"] {
    width: 100% !important;
    text-align: left !important;
}

/* 
* Form control and group styles 
* Consistent appearance for form elements
*/
.form-control {
    width: 100% !important;
    padding: 8px !important;
    margin-bottom: 10px !important;
    border: 1px solid #ccc !important;
    border-radius: 4px !important;
    text-align: left !important;
}

.form-group {
    margin-bottom: 20px !important;
    text-align: left !important;
}

/* 
* Textarea styles 
* Allow vertical resizing for better user experience
*/
textarea {
    resize: vertical !important; /* Allow users to adjust height */
    overflow: auto !important;
    width: 100% !important;
    padding: 8px !important;
    border: 1px solid #ccc !important;
    border-radius: 4px !important;
    text-align: left !important;
}

/* 
* Highlight the Task ID field 
* Provides visual emphasis on the Task ID input to indicate its importance
*/
#task_id {
    border: 2px solid #007bff; /* Blue border to match the primary color scheme */
    background-color: #f0f8ff; /* Very light blue background */
    font-size: 1.1em; /* Slightly larger font */
    padding: 10px; /* Extra padding for prominence */
}

/* 
* Add a focus effect to the Task ID input 
* Enhances user feedback when interacting with this specific field
*/
#task_id:focus {
    border-color: #0056b3; /* Darker blue on focus */
    box-shadow: 0 0 5px rgba(0, 123, 255, 0.5); /* Subtle glow effect */
}



--- Directory: ./core/static/images ---

--- Directory: ./core/static/js ---

File: createTasks.js
----------------------------
/*
 * Stefania Galatolo's JavaScript Magic
 * Developed in collaboration with ChatGPT 4o, because even the most brilliant minds need a little AI-powered magic wand now and then!
 * 
 * File: createTasks.js
 * 
 * Purpose: This file is responsible for handling the interactivity of the task creation form in the task management app. 
 * It manages the synchronization of Point of Sale (POS) fields (both POS Name and POS ID) to ensure consistency when the user selects a POS. 
 * Additionally, it enforces mutual exclusivity for the 'Certified True' and 'Certified False' checkboxes, 
 * ensuring that only one can be selected at a time.
 * 
 * Key Features:
 * - Synchronization between POS Name and POS ID dropdowns.
 * - Mutual exclusivity enforcement for 'Certified True' and 'Certified False' checkboxes.
 * - Event-driven architecture using JavaScript's event listeners to respond to user actions.
 * 
 * Correlation with Other Files:
 * - Works in conjunction with the HTML form elements that contain POS Name, POS ID, and certification checkboxes.
 * - Ensures data consistency before form submission, thereby aiding in maintaining data integrity within the backend database.
 * 
 * Flow:
 * 1. When the DOM content is fully loaded, the script initializes event listeners for the POS dropdowns and certification checkboxes.
 * 2. The `syncPosFields` function is triggered whenever a change event occurs on either POS dropdown, updating the corresponding field to keep them synchronized.
 * 3. The `handleCertifiedCheckboxes` function manages the certification checkboxes, ensuring only one checkbox can be selected at any given time.
 */

document.addEventListener("DOMContentLoaded", function () {
    // Elements for POS selection
    const posNameSelect = document.getElementById("pos_name"); // Dropdown for selecting POS Name
    const posIDSelect = document.getElementById("pos_id"); // Dropdown for selecting POS ID
    const certifiedTrueCheckbox = document.getElementById("certified_true"); // Checkbox for 'Certified True'
    const certifiedFalseCheckbox = document.getElementById("certified_false"); // Checkbox for 'Certified False'

    // Function to synchronize POS ID and POS Name based on selection
    // This function is called whenever the user changes the selected option in either the POS Name or POS ID dropdowns.
    // It updates the corresponding field to ensure consistency between the POS Name and POS ID.
    function syncPosFields(event) {
        if (event.target === posNameSelect) {
            // When POS Name is selected, update POS ID accordingly
            const selectedPosNameOption = posNameSelect.options[posNameSelect.selectedIndex];
            posIDSelect.value = selectedPosNameOption.getAttribute("data-pos-id");
        } else if (event.target === posIDSelect) {
            // When POS ID is selected, update POS Name accordingly
            const selectedPosIDOption = posIDSelect.options[posIDSelect.selectedIndex];
            posNameSelect.value = selectedPosIDOption.getAttribute("data-pos-name");
        }
    }

    // Event listeners for POS selection
    // These listeners call the `syncPosFields` function to keep the POS Name and POS ID fields synchronized.
    // This ensures that changing one field updates the other to maintain data integrity.
    posNameSelect.addEventListener("change", syncPosFields);
    posIDSelect.addEventListener("change", syncPosFields);

    // Function to ensure only one certified checkbox is selected at a time
    // This function is called when the user changes the state of either certification checkbox.
    // It enforces mutual exclusivity, ensuring that only one checkbox ('Certified True' or 'Certified False') can be selected at a time.
    function handleCertifiedCheckboxes(event) {
        if (event.target.checked) { // Only proceed if the checkbox is being checked
            if (event.target.id === "certified_true") {
                certifiedFalseCheckbox.checked = false; // Uncheck 'Certified False' if 'Certified True' is checked
            } else if (event.target.id === "certified_false") {
                certifiedTrueCheckbox.checked = false; // Uncheck 'Certified True' if 'Certified False' is checked
            }
        }
    }

    // Event listeners for Certified checkboxes
    // These listeners ensure mutual exclusivity between 'Certified True' and 'Certified False'.
    // They call the `handleCertifiedCheckboxes` function whenever the state of a checkbox is changed.
    certifiedTrueCheckbox.addEventListener("change", handleCertifiedCheckboxes);
    certifiedFalseCheckbox.addEventListener("change", handleCertifiedCheckboxes);
});



File: kanban.js
----------------------------
/*
 * kanban.js
 * Developed by Stefania Galatolo, with a little help (or a lot) from ChatGPT 4o. 
 * Let's just say Stefania was about to be lost in the JavaScript jungle, but luckily, ChatGPT swung in on a vine and helped out!
 *
 * This script is responsible for handling the entire functionality of the Kanban board in the task management tool.
 * It manages task filtering, fetching tasks from the server, updating task statuses through a drag-and-drop interface, and initializing the Kanban board columns.
 * The script utilizes the Fetch API for backend communication and Sortable.js for implementing drag-and-drop functionality on the board.
 *
 * Key functionalities include:
 * - Fetching and displaying tasks in the Kanban board
 * - Filtering tasks based on search queries, POS IDs, POS Names, statuses, and priorities
 * - Updating task status through drag-and-drop interaction
 * - Ensuring synchronization of the front-end display with the backend database
 *
 * Inputs:
 * - User interactions such as searching, filtering, and dragging tasks
 * - API responses from the server containing task data, POS names, and POS IDs
 *
 * Outputs:
 * - Dynamically updated Kanban board reflecting the current state of tasks
 * - Visual feedback and task status updates sent to the backend
 */

// Runs when the DOM content is fully loaded
document.addEventListener("DOMContentLoaded", function () {
    // DOM elements references for task search, filtering, and Kanban columns
    // These elements are crucial for user interaction with the task filtering system and the Kanban board
    const taskSearchInput = document.getElementById("taskSearch"); // Input field for task search
    const filterBtn = document.getElementById("filterBtn"); // Button to apply filters
    const clearFilterBtn = document.getElementById("clearFilterBtn"); // Button to clear all filters
    const posIDSelect = document.getElementById("filterPosID"); // Dropdown for selecting POS IDs
    const posNameSelect = document.getElementById("filterPosName"); // Dropdown for selecting POS Names
    const startDateInput = document.getElementById("startDate"); // Input field for start date filter
    const endDateInput = document.getElementById("endDate"); // Input field for end date filter
    const dueTodayBtn = document.getElementById("dueTodayBtn"); // Button to filter tasks due today

    // DOM elements for Kanban columns, representing task statuses
    const backlogColumn = document.getElementById("backlog");
    const todoColumn = document.getElementById("todo");
    const inProgressColumn = document.getElementById("inprogress");
    const doneColumn = document.getElementById("done");

    // Flags to prevent multiple fetch calls during dropdown updates
    // These prevent duplicate network requests when updating dropdown options
    let isPosIDUpdating = false; 
    let isPosNameUpdating = false;

    /**
     * Sets up date inputs to show today's date by default
     * Used to provide a default filter for tasks due today, enhancing user experience
     */
    function getTodayDate() {
        const today = new Date();
        const yyyy = today.getFullYear();
        const mm = String(today.getMonth() + 1).padStart(2, '0');
        const dd = String(today.getDate()).padStart(2, '0');
        return `${yyyy}-${mm}-${dd}`;
    }

    // Today's date is computed once to be used as the default for date filters
    const todayDate = getTodayDate();
    setDateInputPlaceholders();

    /**
     * Sets placeholders and default values for date inputs to today's date
     * Ensures that the date inputs have user-friendly defaults
     */
    function setDateInputPlaceholders() {
        startDateInput.value = todayDate;
        endDateInput.value = todayDate;
        startDateInput.placeholder = todayDate;
        endDateInput.placeholder = todayDate;
    }

    /**
     * Gets the values of all selected checkboxes
     * @param {string} selector - CSS selector to identify the checkboxes
     * @returns {Array} - Array of values of checked checkboxes
     */
    function getSelectedCheckboxValues(selector) {
        const checkboxes = document.querySelectorAll(selector);
        return Array.from(checkboxes)
            .filter(checkbox => checkbox.checked)
            .map(checkbox => checkbox.value);
    }

    /**
     * Fetches all POS names and IDs to populate the dropdowns
     * Interacts with the backend API to get the list of POS names and IDs
     */
    function fetchAllPosNamesAndIds() {
        fetch('/api/pos_names_and_ids')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Populate POS Name dropdown with data received from the backend
                    posNameSelect.innerHTML = '<option value="">All</option>';
                    data.pos_names.forEach(posName => {
                        const option = document.createElement("option");
                        option.value = posName;
                        option.textContent = posName;
                        posNameSelect.appendChild(option);
                    });

                    // Populate POS ID dropdown with data received from the backend
                    posIDSelect.innerHTML = '<option value="">All</option>';
                    data.pos_ids.forEach(posId => {
                        const option = document.createElement("option");
                        option.value = posId;
                        option.textContent = posId;
                        posIDSelect.appendChild(option);
                    });
                }
            })
            .catch(error => console.error("Error fetching POS Names and IDs:", error));
    }

    /**
     * Fetches POS Names based on selected POS ID
     * Prevents redundant fetches using a flag and updates the POS Name dropdown
     * @param {string} posId - The POS ID selected by the user
     */
    function fetchPosNames(posId) {
        if (!isPosIDUpdating) {
            isPosIDUpdating = true;
            fetch(`/api/pos_names?pos_id=${posId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Update POS Name dropdown based on POS ID selection
                        posNameSelect.innerHTML = '<option value="">All</option>';
                        data.pos_names.forEach(posName => {
                            const option = document.createElement("option");
                            option.value = posName;
                            option.textContent = posName;
                            posNameSelect.appendChild(option);
                        });
                        // Auto-select the only option if only one POS name is returned
                        if (data.pos_names.length === 1) {
                            posNameSelect.value = data.pos_names[0];
                        }
                    }
                })
                .catch(error => console.error("Error fetching POS Names:", error))
                .finally(() => isPosIDUpdating = false);
        }
    }

    /**
     * Fetches POS IDs based on selected POS Name
     * Prevents redundant fetches using a flag and updates the POS ID dropdown
     * @param {string} posName - The POS Name selected by the user
     */
    function fetchPosNumbers(posName) {
        if (!isPosNameUpdating) {
            isPosNameUpdating = true;
            fetch(`/api/pos_ids?pos_name=${posName}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Update POS ID dropdown based on POS Name selection
                        posIDSelect.innerHTML = '<option value="">All</option>';
                        data.pos_ids.forEach(posId => {
                            const option = document.createElement("option");
                            option.value = posId;
                            option.textContent = posId;
                            posIDSelect.appendChild(option);
                        });
                        // Auto-select the only option if only one POS ID is returned
                        if (data.pos_ids.length === 1) {
                            posIDSelect.value = data.pos_ids[0];
                        }
                    }
                })
                .catch(error => console.error("Error fetching POS IDs:", error))
                .finally(() => isPosNameUpdating = false);
        }
    }

    // Event listeners to update POS names/IDs when the dropdown selection changes
    posIDSelect.addEventListener("change", function () {
        const selectedPosId = posIDSelect.value;
        if (selectedPosId) {
            fetchPosNames(selectedPosId);
        }
    });

    posNameSelect.addEventListener("change", function () {
        const selectedPosName = posNameSelect.value;
        if (selectedPosName) {
            fetchPosNumbers(selectedPosName);
        }
    });

    /**
     * Fetches tasks based on the provided filter criteria and displays them on the Kanban board
     * This function clears existing tasks from the board and re-populates it with filtered tasks
     * @param {Object} data - The filter criteria to be sent to the backend
     */
    function fetchAndDisplayKanbanTasks(data) {
        fetch("/api/kanban_tasks", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data),
        })
        .then(response => response.json())
        .then(data => {
            // Clear the task cards inside each column while preserving the label
            backlogColumn.querySelectorAll('.task-card').forEach(e => e.remove());
            todoColumn.querySelectorAll('.task-card').forEach(e => e.remove());
            inProgressColumn.querySelectorAll('.task-card').forEach(e => e.remove());
            doneColumn.querySelectorAll('.task-card').forEach(e => e.remove());

            // Render tasks in the appropriate columns
            if (data.tasks && data.tasks.length > 0) {
                data.tasks.forEach(task => {
                    const taskCard = document.createElement("div");
                    taskCard.className = "card task-card mb-3";
                    taskCard.setAttribute("data-task-id", task.task_id);
                    taskCard.setAttribute("data-task-status", task.task_status); // To track status for drag-and-drop
                    taskCard.innerHTML = `
                        <div class="card-body">
                            <h5 class="card-title">${task.task_desc || 'No Description'}</h5>
                            <p class="card-text"><strong>Status:</strong> ${task.task_status}</p>
                            <p class="card-text"><strong>Priority:</strong> ${task.task_priority}</p>
                            <p class="card-text"><strong>Due Date:</strong> ${task.task_due_date}</p>
                        </div>
                    `;

                    // Append the task card directly to the relevant column
                    if (task.task_status === "Backlog") {
                        backlogColumn.appendChild(taskCard);
                    } else if (task.task_status === "To Do") {
                        todoColumn.appendChild(taskCard);
                    } else if (task.task_status === "In Progress") {
                        inProgressColumn.appendChild(taskCard);
                    } else if (task.task_status === "Done") {
                        doneColumn.appendChild(taskCard);
                    }
                });
            } else {
                // Handle case where no tasks are found
                backlogColumn.innerHTML += "<p>No Backlog tasks found.</p>";
                todoColumn.innerHTML += "<p>No To Do tasks found.</p>";
                inProgressColumn.innerHTML += "<p>No In Progress tasks found.</p>";
                doneColumn.innerHTML += "<p>No Done tasks found.</p>";
            }

            // Reinitialize sortable for drag-and-drop functionality after rendering tasks
            initializeSortable();
        })
        .catch(error => console.error("Error fetching Kanban tasks:", error));
    }

    // Event listener for the filter button
    // Applies filters based on user input and fetches matching tasks
    filterBtn.addEventListener("click", function () {
        const posID = posIDSelect.value;
        const posName = posNameSelect.value;
        const startDate = startDateInput.value !== todayDate ? startDateInput.value : null;
        const endDate = endDateInput.value !== todayDate ? endDateInput.value : null;
        const selectedStatuses = getSelectedCheckboxValues("input[id^='status']");
        const selectedPriorities = getSelectedCheckboxValues("input[id^='priority']");
        const searchQuery = taskSearchInput.value;

        const data = {
            pos_id: posID,
            pos_name: posName,
            start_date: startDate,
            end_date: endDate,
            statuses: selectedStatuses,
            priorities: selectedPriorities,
            search_query: searchQuery
        };

        fetchAndDisplayKanbanTasks(data);
    });

    // "Due Today" button event listener
    // Fetches tasks due today and displays them on the Kanban board
    dueTodayBtn.addEventListener("click", function () {
        const todayDate = getTodayDate();

        // Create a data object to send to the backend
        const data = {
            start_date: todayDate,
            end_date: todayDate
        };

        // Call the function to fetch and display tasks filtered by today's date
        fetchAndDisplayKanbanTasks(data);
    });

    // Event listener for task search input
    // Fetches tasks based on the search query entered by the user
    taskSearchInput.addEventListener("input", function () {
        const query = taskSearchInput.value;
        const posID = posIDSelect.value;
        const posName = posNameSelect.value;
        const startDate = startDateInput.value !== todayDate ? startDateInput.value : null;
        const endDate = endDateInput.value !== todayDate ? endDateInput.value : null;
        const selectedStatuses = getSelectedCheckboxValues("input[id^='status']");
        const selectedPriorities = getSelectedCheckboxValues("input[id^='priority']");

        const data = {
            search_query: query,
            pos_id: posID,
            pos_name: posName,
            start_date: startDate,
            end_date: endDate,
            statuses: selectedStatuses,
            priorities: selectedPriorities
        };

        fetchAndDisplayKanbanTasks(data);
    });

    // Event listener for the clear filter button
    // Clears all filter inputs and fetches all tasks without any filters
    clearFilterBtn.addEventListener("click", function () {
        // Clear filter inputs
        posIDSelect.value = "";
        posNameSelect.value = "";
        taskSearchInput.value = "";
        setDateInputPlaceholders();

        // Uncheck all checkboxes
        document.querySelectorAll("input[id^='status'], input[id^='priority']").forEach(checkbox => {
            checkbox.checked = false;
        });

        // Re-fetch POS names and IDs
        fetchAllPosNamesAndIds();

        // Fetch all tasks with no filters
        fetchAndDisplayKanbanTasks({
            search_query: "",
            pos_id: "",
            pos_name: "",
            start_date: null,
            end_date: null,
            statuses: [],
            priorities: []
        });
    });

    // Initial fetch of tasks when the page loads
    // This ensures the Kanban board is populated as soon as the user visits the page
    fetchAndDisplayKanbanTasks({});

    /**
     * Handles updating task status in both the frontend and backend
     * @param {HTMLElement} taskElement - The task element that has been dragged and dropped
     */
    function handleTaskStatusUpdate(taskElement) {
        const taskId = taskElement.getAttribute('data-task-id');
        const previousStatus = taskElement.getAttribute('data-task-status');

        // Identify the new status based on the column where the task is dropped
        let newStatus = '';
        const parentColumnId = taskElement.parentElement.id;

        if (parentColumnId === 'backlog') {
            newStatus = 'Backlog';
        } else if (parentColumnId === 'todo') {
            newStatus = 'To Do';
        } else if (parentColumnId === 'inprogress') {
            newStatus = 'In Progress';
        } else if (parentColumnId === 'done') {
            newStatus = 'Done';
        }

        if (newStatus && newStatus !== previousStatus) {
            // Update the status in the UI
            const statusElement = Array.from(taskElement.querySelectorAll('.card-text')).find(p => p.innerText.includes('Status'));
            statusElement.innerHTML = `<strong>Status:</strong> ${newStatus}`;
            taskElement.setAttribute('data-task-status', newStatus);

            // Send the updated status to the backend
            fetch(`/api/update_task_status/${taskId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ status: newStatus })
            })
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    console.error(`Failed to update task ${taskId} in the database.`);
                    // Revert the UI if the update fails
                    statusElement.innerHTML = `<strong>Status:</strong> ${previousStatus}`;
                    taskElement.setAttribute('data-task-status', previousStatus);
                }
            })
            .catch(error => {
                console.error(`Error updating task ${taskId} status:`, error);
                // Revert the UI in case of an error
                statusElement.innerHTML = `<strong>Status:</strong> ${previousStatus}`;
                taskElement.setAttribute('data-task-status', previousStatus);
            });
        }
    }

    /**
     * Initializes sortable for drag-and-drop functionality on each column
     * Uses Sortable.js to enable reordering of tasks within and across columns
     */
    function initializeSortable() {
        new Sortable(backlogColumn, {
            group: 'kanban',
            animation: 150,
            onEnd: function (evt) {
                handleTaskStatusUpdate(evt.item);  // Call status update handler on drop
            }
        });

        new Sortable(todoColumn, {
            group: 'kanban',
            animation: 150,
            onEnd: function (evt) {
                handleTaskStatusUpdate(evt.item);  // Call status update handler on drop
            }
        });

        new Sortable(inProgressColumn, {
            group: 'kanban',
            animation: 150,
            onEnd: function (evt) {
                handleTaskStatusUpdate(evt.item);  // Call status update handler on drop
            }
        });

        new Sortable(doneColumn, {
            group: 'kanban',
            animation: 150,
            onEnd: function (evt) {
                handleTaskStatusUpdate(evt.item);  // Call status update handler on drop
            }
        });
    }
});



File: modifyTasks.js
----------------------------
/**
 * modifyTasks.js
 * Developed by Stefania Galatolo, with a little help from ChatGPT 4.0.
 * (Coding is tough, and sometimes it's just better to have a co-pilot who never sleeps, right?)
 *
 * This script is responsible for handling the modification of tasks in the task management application.
 * It supports key operations such as:
 * - Synchronizing POS (Point of Sale) fields between their name and ID.
 * - Clearing the task modification form.
 * - Fetching existing task data from the server based on user input.
 * - Submitting modified task data back to the server for update.
 * 
 * This script interacts with the server using GET and POST requests and communicates with
 * specific API endpoints (`/api/get_task/{task_id}` and `/api/modify_task/{task_id}`).
 * 
 * Important connections:
 * - This file communicates with `app.py` in the backend, where Flask routes handle the task data requests.
 * - It also works with the HTML form elements on the `modify.html` template page, ensuring that task modification fields are synced.
 */

document.addEventListener("DOMContentLoaded", function () {
    // Get references to key elements within the document for task modification.
    const taskIdInput = document.getElementById("task_id"); // Input for the task ID, used to fetch and modify tasks.
    const modifyBtn = document.getElementById("modifyBtn"); // Button to trigger task modification.

    // Elements for POS (Point of Sale) selection
    const posNameSelect = document.getElementById("pos_name"); // Dropdown to select POS by name.
    const posIDSelect = document.getElementById("pos_id"); // Dropdown to select POS by ID.

    // Certified radio buttons for user to mark if the task is certified or not.
    const certifiedYesRadio = document.getElementById("certified_yes");
    const certifiedNoRadio = document.getElementById("certified_no");

    /**
     * Synchronizes POS fields between POS name and POS ID.
     * This ensures that when one field (POS name or POS ID) is updated, the corresponding
     * value in the other field is also updated to reflect the selected POS correctly.
     *
     * @param {Event} event - The change event triggered when the POS fields are modified.
     */
    function syncPosFields(event) {
        // If POS name is changed, update the POS ID field to match.
        if (event.target === posNameSelect) {
            const selectedPosNameOption = posNameSelect.options[posNameSelect.selectedIndex];
            posIDSelect.value = selectedPosNameOption.getAttribute("data-pos-id");
        } 
        // If POS ID is changed, update the POS name field to match.
        else if (event.target === posIDSelect) {
            const selectedPosIDOption = posIDSelect.options[posIDSelect.selectedIndex];
            posNameSelect.value = selectedPosIDOption.getAttribute("data-pos-name");
        }
    }

    // Attach event listeners to POS selection elements to ensure they stay synchronized.
    posNameSelect.addEventListener("change", syncPosFields);
    posIDSelect.addEventListener("change", syncPosFields);

    /**
     * Clears all form fields, resetting them to their default values.
     * This function is useful when no task is selected or when a task needs to be cleared
     * (e.g., when the user enters an invalid task ID).
     */
    function clearFormFields() {
        posNameSelect.value = ""; // Clear POS name
        posIDSelect.value = "";   // Clear POS ID
        document.getElementById("description").value = ""; // Clear description
        
        // Uncheck all status and priority radio buttons
        document.querySelectorAll('input[name="status"]').forEach(radio => radio.checked = false);
        document.querySelectorAll('input[name="priority"]').forEach(radio => radio.checked = false);

        document.getElementById("start_date").value = ""; // Clear start date
        document.getElementById("due_date").value = ""; // Clear due date
        document.getElementById("reconciliation_date").value = ""; // Clear reconciliation date
        document.getElementById("notes").value = ""; // Clear notes
        document.getElementById("blocker_desc").value = ""; // Clear blocker description
        document.getElementById("blocker_responsible").value = ""; // Clear blocker responsible person

        // Clear certified radio buttons
        certifiedYesRadio.checked = false;
        certifiedNoRadio.checked = false;
    }

    /**
     * Fetches task data from the server based on the provided task ID.
     * This function sends a GET request to the `/api/get_task/{task_id}` endpoint
     * to retrieve the task data. The form fields are then populated with the fetched task details.
     * 
     * @param {string} taskId - The ID of the task to fetch data for.
     * 
     * The server response should include task information such as POS, description, status, priority, 
     * and reconciliation details, which will be reflected in the form fields.
     */
    function fetchTaskData(taskId) {
        if (taskId) {
            fetch(`/api/get_task/${taskId}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error("Network response was not ok");
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        // Populate the form fields with the fetched task data
                        posNameSelect.value = data.task.pos_name;
                        posIDSelect.value = data.task.pos_id;
                        document.getElementById("description").value = data.task.task_desc;

                        // Ensure the status and priority radio buttons are properly selected
                        const statusRadio = document.querySelector(`input[name="status"][value="${data.task.task_status}"]`);
                        if (statusRadio) statusRadio.checked = true;

                        const priorityRadio = document.querySelector(`input[name="priority"][value="${data.task.task_priority}"]`);
                        if (priorityRadio) priorityRadio.checked = true;

                        document.getElementById("start_date").value = data.task.task_start_date;
                        document.getElementById("due_date").value = data.task.task_due_date;
                        document.getElementById("reconciliation_date").value = data.task.rec_date;
                        document.getElementById("notes").value = data.task.task_notes;
                        document.getElementById("blocker_desc").value = data.task.blocker_desc;
                        document.getElementById("blocker_responsible").value = data.task.blocker_responsible;

                        // Set the certified radio buttons based on the fetched data
                        if (data.task.rec_certified === 'Yes') {
                            certifiedYesRadio.checked = true;
                            certifiedNoRadio.checked = false;
                        } else if (data.task.rec_certified === 'No') {
                            certifiedYesRadio.checked = false;
                            certifiedNoRadio.checked = true;
                        } else {
                            certifiedYesRadio.checked = false;
                            certifiedNoRadio.checked = false;
                        }
                    } else {
                        alert(data.message || "Task not found!");
                        console.error("API Error:", data);
                    }
                })
                .catch(error => {
                    console.error('Error fetching task:', error);
                    alert('Error fetching task. Please check the console for more details.');
                });
        } else {
            // Clear all fields if taskId is empty
            clearFormFields();
        }
    }

    // Listen for changes in the task ID input field to trigger task data fetching.
    taskIdInput.addEventListener("input", function () {
        const taskId = taskIdInput.value.trim();
        
        // Trigger fetch only if the input is not empty
        if (taskId) {
            fetchTaskData(taskId);
        } else {
            clearFormFields();
        }
    });

    /**
     * Sends the modified task data to the server for updating the task.
     * This function gathers all the data from the form and sends a POST request
     * to the `/api/modify_task/{task_id}` endpoint to update the task details.
     */
    function modifyTaskData() {
        const taskId = taskIdInput.value.trim();
        if (!taskId) {
            alert("Task ID is required to modify a task.");
            return;
        }

        const formData = new FormData(document.getElementById("modifyTaskForm")); // Collect form data
        const formObject = {};
        formData.forEach((value, key) => formObject[key] = value); // Convert form data to object

        fetch(`/api/modify_task/${taskId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(formObject) // Send form data as JSON
        })
        .then(response => {
            if (!response.ok) {
                console.error(`Server error: ${response.statusText}`);
                throw new Error("Error modifying task");
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                alert("Task modified successfully!");
                window.location.reload(); // Reload page upon success
            } else {
                alert(data.message || "Failed to modify task.");
            }
        })
        .catch(error => {
            console.error('Error modifying task:', error);
        });
    }

    // Listen for clicks on the "Modify" button to send the modified data.
    modifyBtn.addEventListener("click", function () {
        modifyTaskData();
    });
});



File: tasksLookup.js
----------------------------
/*
 * tasksLookup.js
 * Developed by Stefania Galatolo with invaluable assistance from ChatGPT 4.0.
 * You know, Stefania had grand plans for this feature, but it turns out that
 * async JavaScript was like a foreign language she hadn't quite mastered yet.
 * Enter ChatGPT, the silent code ninja, helping her conquer the asynchronous
 * jungle one fetch call at a time.
 * 
 * This script is a crucial part of the task management app. It handles:
 * - Fetching tasks from the server based on user input and filters.
 * - Filtering tasks by various criteria such as POS ID, POS Name, dates, status, and priority.
 * - Providing real-time search functionality as the user types.
 * - Implementing pagination to navigate through the tasks.
 * 
 * **Main Components:**
 * 1. Event Listeners: Attached to DOM elements like filter inputs, search box, and pagination controls.
 * 2. Fetch Operations: Sends requests to the server to retrieve data, populate dropdowns, and update the task table.
 * 3. Dynamic DOM Manipulation: Updates the task table and pagination controls based on server responses.
 * 
 * **Interactivity with Server and Other Files:**
 * - Communicates with the Flask backend (`/filter_tasks`, `/api/pos_names_and_ids`, etc.) to fetch and filter task data.
 * - Works alongside HTML templates and server-side routes defined in Flask to provide a dynamic task management experience.
 * - Directly manipulates HTML elements within `tasks.html` to display and filter tasks.
 */

document.addEventListener("DOMContentLoaded", function () {
    // Get references to DOM elements that are frequently used
    // These elements are used throughout the script to capture user inputs for filtering
    // and to display the fetched tasks.
    const taskSearchInput = document.getElementById("taskSearch");
    const filterBtn = document.getElementById("filterBtn");
    const clearFilterBtn = document.getElementById("clearFilterBtn");
    const taskTableBody = document.getElementById("taskTableBody");
    const posIDSelect = document.getElementById("filterPosID");
    const posNameSelect = document.getElementById("filterPosName");
    const startDateInput = document.getElementById("startDate");
    const endDateInput = document.getElementById("endDate");
    const paginationContainer = document.getElementById("paginationContainer"); // Container for pagination controls

    let isPosIDUpdating = false;  // Flags to prevent multiple simultaneous updates
    let isPosNameUpdating = false;
    let currentPage = 1; // Track the current page

    // Get today's date for setting placeholders
    // This function provides a formatted date string for today's date
    // used to set default values and placeholders for date inputs.
    function getTodayDate() {
        const today = new Date();
        const yyyy = today.getFullYear();
        const mm = String(today.getMonth() + 1).padStart(2, '0');
        const dd = String(today.getDate()).padStart(2, '0');
        return `${yyyy}-${mm}-${dd}`;
    }

    // Set date input placeholders to today's date
    const todayDate = getTodayDate();
    setDateInputPlaceholders();

    function setDateInputPlaceholders() {
        startDateInput.value = todayDate;
        endDateInput.value = todayDate;
        startDateInput.placeholder = todayDate;
        endDateInput.placeholder = todayDate;
    }

    // Helper function to get values of selected checkboxes
    // Collects all checked checkboxes matching the selector and returns their values.
    function getSelectedCheckboxValues(selector) {
        const checkboxes = document.querySelectorAll(selector);
        return Array.from(checkboxes)
            .filter(checkbox => checkbox.checked)
            .map(checkbox => checkbox.value);
    }

    // Fetch all POS Names and POS IDs for reset
    // This function fetches available POS names and IDs from the server
    // to populate the dropdowns with all available options.
    function fetchAllPosNamesAndIds() {
        fetch('/api/pos_names_and_ids')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Reset POS Name dropdown
                    posNameSelect.innerHTML = '<option value="">All</option>';
                    data.pos_names.forEach(posName => {
                        const option = document.createElement("option");
                        option.value = posName;
                        option.textContent = posName;
                        posNameSelect.appendChild(option);
                    });

                    // Reset POS ID dropdown
                    posIDSelect.innerHTML = '<option value="">All</option>';
                    data.pos_ids.forEach(posId => {
                        const option = document.createElement("option");
                        option.value = posId;
                        option.textContent = posId;
                        posIDSelect.appendChild(option);
                    });
                }
            })
            .catch(error => console.error("Error fetching POS Names and IDs:", error));
    }

    // Fetch POS Names based on selected POS ID
    // This function makes an API call to get POS names related to the selected POS ID
    // and updates the POS Name dropdown options.
    function fetchPosNames(posId) {
        if (!isPosIDUpdating) {
            isPosIDUpdating = true;
            fetch(`/api/pos_names?pos_id=${posId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        posNameSelect.innerHTML = '<option value="">All</option>'; // Reset options
                        data.pos_names.forEach(posName => {
                            const option = document.createElement("option");
                            option.value = posName;
                            option.textContent = posName;
                            posNameSelect.appendChild(option);
                        });
                        if (data.pos_names.length === 1) {
                            // If there's only one matching name, select it automatically
                            posNameSelect.value = data.pos_names[0];
                        }
                    }
                })
                .catch(error => console.error("Error fetching POS Names:", error))
                .finally(() => isPosIDUpdating = false);
        }
    }

    // Fetch POS IDs based on selected POS Name
    // This function makes an API call to get POS IDs related to the selected POS name
    // and updates the POS ID dropdown options.
    function fetchPosNumbers(posName) {
        if (!isPosNameUpdating) {
            isPosNameUpdating = true;
            fetch(`/api/pos_ids?pos_name=${posName}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        posIDSelect.innerHTML = '<option value="">All</option>'; // Reset options
                        data.pos_ids.forEach(posId => {
                            const option = document.createElement("option");
                            option.value = posId;
                            option.textContent = posId;
                            posIDSelect.appendChild(option);
                        });
                        if (data.pos_ids.length === 1) {
                            // If there's only one matching ID, select it automatically
                            posIDSelect.value = data.pos_ids[0];
                        }
                    }
                })
                .catch(error => console.error("Error fetching POS IDs:", error))
                .finally(() => isPosNameUpdating = false);
        }
    }

    // Event listener for POS ID selection change
    // Triggers fetching and updating of POS Names dropdown when POS ID changes.
    posIDSelect.addEventListener("change", function () {
        const selectedPosId = posIDSelect.value;
        if (selectedPosId) {
            fetchPosNames(selectedPosId);  // Fetch POS Names based on POS ID
        }
    });

    // Event listener for POS Name selection change
    // Triggers fetching and updating of POS IDs dropdown when POS Name changes.
    posNameSelect.addEventListener("change", function () {
        const selectedPosName = posNameSelect.value;
        if (selectedPosName) {
            fetchPosNumbers(selectedPosName);  // Fetch POS Numbers based on POS Name
        }
    });

    // Fetch and display tasks based on filter and pagination
    // This function sends a POST request to the server with the current filters
    // and renders the tasks in the table based on the response.
    function fetchAndDisplayTasks(data, page = 1) {
        console.log("Sending data to server:", data);

        data.page = page; // Include the current page number

        fetch("/filter_tasks", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data),
        })
        .then(response => response.json())
        .then(data => {
            console.log("Received data:", data);

            taskTableBody.innerHTML = ""; // Clear the table body

            if (data.tasks && data.tasks.length > 0) {
                // Iterate through the tasks and append them to the table
                data.tasks.forEach(task => {
                    const row = `
                    <tr>
                        <td>${task.task_id || 'n/a'}</td>
                        <td>${task.pos_id || 'n/a'}</td>
                        <td>${task.pos_name || 'n/a'}</td>
                        <td>${task.rec_date || 'n/a'}</td>
                        <td>${task.rec_certified || 'n/a'}</td>
                        <td>${task.task_desc || 'n/a'}</td>
                        <td>${task.task_status || 'n/a'}</td>
                        <td>${task.task_priority || 'n/a'}</td>
                        <td>${task.blocker_desc || 'n/a'}</td>
                        <td>${task.blocker_responsible || 'n/a'}</td>
                        <td>${task.task_start_date || 'n/a'}</td>
                        <td>${task.task_due_date || 'n/a'}</td>
                        <td>${task.task_notes || 'n/a'}</td>
                    </tr>`;
                    taskTableBody.innerHTML += row;
                });
                console.log("Tasks rendered successfully.");
                updatePaginationControls(data.page, data.total_pages); // Update pagination controls
            } else {
                taskTableBody.innerHTML = "<tr><td colspan='13'>No tasks found</td></tr>";
            }
        })
        .catch(error => console.error("Error fetching tasks:", error));
    }

    // Event listener for the Filter button
    // Triggers a fetch request to get tasks based on the current filter criteria.
    filterBtn.addEventListener("click", function () {
        currentPage = 1; // Reset to the first page on new filter
        const data = collectFilterData();
        fetchAndDisplayTasks(data, currentPage);
    });

    // Collect filter data from inputs
    // Collects data from all filter inputs to be sent to the server for task filtering.
    function collectFilterData() {
        const posID = posIDSelect.value;
        const posName = posNameSelect.value;
        const searchQuery = taskSearchInput.value;
        const startDate = startDateInput.value !== todayDate ? startDateInput.value : null;
        const endDate = endDateInput.value !== todayDate ? endDateInput.value : null;
        const selectedStatuses = getSelectedCheckboxValues("input[id^='status']");
        const selectedPriorities = getSelectedCheckboxValues("input[id^='priority']");

        return {
            pos_id: posID,
            pos_name: posName,
            search_query: searchQuery,
            start_date: startDate,
            end_date: endDate,
            statuses: selectedStatuses,
            priorities: selectedPriorities
        };
    }

    // Event listener for the search input field (dynamic filtering)
    // This provides real-time filtering as the user types in the search field.
    taskSearchInput.addEventListener("input", function () {
        currentPage = 1; // Reset to the first page on new search
        const data = collectFilterData();
        fetchAndDisplayTasks(data, currentPage);
    });

    // Event listener for the Clear Filter button
    // Clears all filters and resets the table to show all tasks.
    clearFilterBtn.addEventListener("click", function () {
        posIDSelect.value = "";
        posNameSelect.value = "";
        taskSearchInput.value = "";
        setDateInputPlaceholders();

        document.querySelectorAll("input[id^='status'], input[id^='priority']").forEach(checkbox => {
            checkbox.checked = false;
        });

        // Reset POS names and IDs
        fetchAllPosNamesAndIds();

        // Fetch tasks without any filters
        currentPage = 1; // Reset to the first page
        fetchAndDisplayTasks({}, currentPage);
    });

    // Initial fetch when the page loads
    fetchAndDisplayTasks({}, currentPage);

    // Update pagination controls
    // This function updates the pagination controls based on the current page and total pages.
    function updatePaginationControls(currentPage, totalPages) {
        paginationContainer.innerHTML = ""; // Clear existing controls

        // Previous link
        if (currentPage > 1) {
            const prevLink = document.createElement("a");
            prevLink.href = "#";
            prevLink.textContent = "Previous";
            prevLink.style.fontSize = "0.85em"; // Smaller font size
            prevLink.style.marginRight = "10px"; // Add some spacing
            prevLink.addEventListener("click", function (event) {
                event.preventDefault(); // Prevent default anchor behavior
                currentPage--;
                fetchAndDisplayTasks(collectFilterData(), currentPage);
            });
            paginationContainer.appendChild(prevLink);
        }

        // Page info
        const pageInfo = document.createElement("span");
        pageInfo.textContent = ` Page ${currentPage} of ${totalPages} `;
        pageInfo.style.fontSize = "0.85em"; // Smaller font size
        paginationContainer.appendChild(pageInfo);

        // Next link
        if (currentPage < totalPages) {
            const nextLink = document.createElement("a");
            nextLink.href = "#";
            nextLink.textContent = "Next";
            nextLink.style.fontSize = "0.85em"; // Smaller font size
            nextLink.style.marginLeft = "10px"; // Add some spacing
            nextLink.addEventListener("click", function (event) {
                event.preventDefault(); // Prevent default anchor behavior
                currentPage++;
                fetchAndDisplayTasks(collectFilterData(), currentPage);
            });
            paginationContainer.appendChild(nextLink);
        }
    }
});



--- Directory: ./core/templates ---

File: create.html
----------------------------
{# 
    Filename: create.html
    Developed by: Stefania Galatolo, assisted by ChatGPT 4o
    Description: 
    This template renders the "Create Task" page, providing an interface for the user to create a new task 
    and view the existing tasks in a tabular format. It extends the base layout (`layout.html`) and incorporates 
    several reusable components using Jinja2's include functionality.
    
    Collaboration Note: 
    If you're wondering how this magic happened, Stefania got by with a little help from ChatGPT 4o. Because who knew 
    rendering HTML could be such a party? Remember, friends don't let friends code alone.

    Template Structure:
    - Extends the base layout from "layout.html".
    - Sets the page title to "Create Task".
    - Renders the main content block which consists of:
        1. Sidebar: Includes "_sidebar.html" for displaying filter options.
        2. Main Content Area:
            - Header: Displays the title "Create Task".
            - Task Creation Form: Includes "_create_form.html" to provide the form for creating new tasks.
            - Tasks Table: Includes "_tasks_body.html" to render the current list of tasks in a table format.
    
    Correlations:
    - "_sidebar.html": Provides filter options, allowing users to interactively narrow down the displayed tasks.
    - "_create_form.html": Contains the form to create new tasks. When submitted, the form data is sent to the server 
      to create a new task entry in the database.
    - "_tasks_body.html": Displays a table of all current tasks. This template shows the task list without filters, 
      giving a straightforward overview of the tasks.

    Flow:
    1. User lands on the "Create Task" page.
    2. The sidebar is displayed on the left for filtering tasks.
    3. The main content area shows the task creation form at the top.
    4. Below the form, a table lists all tasks, allowing the user to see what tasks already exist.
#}

{% extends "layout.html" %}

{% block title %}
    Create Task
{% endblock %}

{% block main %}
<div class="container-fluid">
    <div class="row">
        <!-- Sidebar -->
        <div class="col-md-3">
            {% include "_sidebar.html" %} <!-- Include sidebar for filters right after the navbar -->
        </div>

        <!-- Main Content Area -->
        <div class="col-md-9">
            <h1>Create Task</h1>

            <!-- Include Create Task Form -->
            {% include "_create_form.html" %}
            
            <hr>

            <!-- All Tasks Table -->            
            {% include "_tasks_body.html" %} <!-- Only includes the tasks table, no filters -->
        </div>
    </div>
</div>
{% endblock %}



File: error.html
----------------------------
{# 
    File: error.html
    Developed by Stefania Galatolo, assisted by ChatGPT 4o, the code wizard who kept Stefania from tearing her hair out. Who knew error handling could be this much fun?
    
    ### Description:
    - This template is used to display error messages in the web application.
    - It extends the base layout (`layout.html`), inheriting the common structure and styling.
    - The `message` variable is passed to this template from the Flask route handling errors, allowing dynamic error messages to be displayed.
    
    ### Inputs:
    - `message`: A string passed from the server, containing the error message to be displayed.
    
    ### Outputs:
    - Renders an HTML page with an error message and a "Go Home" button for navigation.
    
    ### Flow:
    1. Inherits the layout from `layout.html`.
    2. Overrides the `title` block to set the page title to "Error".
    3. Overrides the `main` block to include the error message and a navigation button.
    #}
    
    {% extends "layout.html" %}
    
    {% block title %}
        Error
    {% endblock %}
    
    {% block main %}
    <div class="text-center mb-3">
        <div>
            <h1>Error</h1>
            <p>{{ message }}</p> {# Displays the error message passed from the Flask route #}
            <a href="/" class="btn btn-primary">Go Home</a> {# Button to navigate back to the home page #}
        </div>
    </div>
    {% endblock %}
    


File: kanban.html
----------------------------
<!-- kanban.html -->
{# 
    File: kanban.html
    Description: This is the main HTML template for the Kanban board feature in the task management application. 
    The template extends 'layout.html', providing a structured view of tasks categorized into different statuses 
    (e.g., Backlog, To Do, In Progress, Done) in a visual drag-and-drop board. The Kanban board is essential for 
    offering users an intuitive way to track and manage tasks through various stages of completion.

    Inputs: 
    - Extends the 'layout.html' file, which provides the common structure including header, footer, and navigation.
    - Includes '_sidebar.html' for filtering options and task navigation.
    - Includes '_kanban_board.html' for the actual Kanban board layout and task cards.

    Outputs:
    - Renders a full-page Kanban board within the layout defined in 'layout.html'.
    - Displays a sidebar with filtering options and a main section with the Kanban board.
    
    Dependencies and Correlations:
    - Depends on 'layout.html' for the overall page structure, ensuring consistent UI/UX across the application.
    - Uses '_sidebar.html' to incorporate filtering and navigation, allowing users to filter tasks displayed on the Kanban board.
    - Uses '_kanban_board.html' to render the Kanban board where tasks are categorized and can be moved between columns.
    
    Collaboration Note: 
    - Developed by Stefania Galatolo, with invaluable assistance from ChatGPT 4.0. In an unexpected twist of fate, ChatGPT became the Kanban master while Stefania heroically fought against endless divs and CSS classes. Together, they transformed chaos into a streamlined task management board.
#}

{% extends "layout.html" %}

{% block title %}
    Kanban Board
{% endblock %}

{% block main %}
<div class="container-fluid">
    <div class="row">
        <!-- Sidebar Section -->
        <div class="col-md-3">
            {# 
                This section includes the sidebar from '_sidebar.html'. 
                - The sidebar provides filtering options to allow users to filter tasks displayed on the Kanban board.
                - Filters might include options such as task priority, status, and POS ID, enhancing user experience by offering targeted task management.
                - The sidebar is rendered in a Bootstrap column (3 columns wide out of 12) for a responsive layout.
            #}
            {% include '_sidebar.html' %}
        </div>

        <!-- Kanban Board Section -->
        <div class="col-md-9">
            {# 
                This section includes the actual Kanban board from '_kanban_board.html'.
                - The Kanban board displays tasks in different columns based on their status.
                - Each task is rendered as a card that can be dragged and dropped between columns, allowing users to change the status of tasks interactively.
                - The board is responsive and rendered in a Bootstrap column (9 columns wide out of 12), occupying the main area of the page.
            #}
            {% include '_kanban_board.html' %}
        </div>
    </div>
</div>
{% endblock %}



File: layout.html
----------------------------
<!-- 
    TaskFlow Project - Final Project for CS50 by Harvard EdX 2024
    Developed by Stefania Galatolo, assisted (and occasionally rescued) by ChatGPT-4o.

    This file defines the base layout for the TaskFlow web application. It includes the main structure of the HTML page, 
    including the navigation bar, flash message display, and footer. Each page of the app inherits from this layout template 
    and injects its specific content where blocks are defined (e.g., the main content area and page title).

    The humor in this header reflects the journey of Stefania developing this project with the indispensable assistance of ChatGPT.
    Stefania could not have done this alone—ChatGPT's infinite wisdom and some Bootstrap magic saved the day!

    Main functions of this layout:
    - Provides a navigation bar with links that adjust based on user session status (logged in or logged out).
    - Renders the appropriate flash messages if any are generated (e.g., after successful log in or an error).
    - Includes a container for dynamic page content, allowing pages to inject their own specific content within the defined block.
    - Uses Bootstrap 5 for responsive design and easy styling.

    Inputs: 
    - Session variable `user_id` to determine if a user is logged in.
    - Flash messages through Flask's `get_flashed_messages` for error/success alerts.

    Outputs: 
    - A responsive navigation bar, dynamic content injection for individual pages, flash message display, and a footer.

    Other Files:
    - This file relies on external CSS (Bootstrap and custom styles) and JS files loaded through CDNs and Flask's static file structure.
    - The `url_for` function is used to link static assets (favicon, CSS) and dynamically inject the page's title and main content.
-->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, width=device-width">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

    <!-- Favicon -->
    <link rel="icon" type="image/webp" href="{{ url_for('static', filename='images/favicon.webp') }}">

    <!-- Custom styles -->
    <link href="{{ url_for('static', filename='css/style.css') }}" rel="stylesheet">

    <!-- Dynamic title block to be filled by individual pages -->
    <title>TaskFlow: {% block title %}{% endblock %}</title>
</head>

<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-md navbar-light bg-light border">
        <div class="container-fluid">
            <!-- TaskFlow brand -->
            <a class="navbar-brand" href="/"><span class="blue">Task</span><span class="red">Flow</span></a>
            <!-- Toggler for small screens -->
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <!-- Navigation links, adjusting based on user login status -->
            <div class="collapse navbar-collapse" id="navbar">
                {% if session["user_id"] %}
                    <ul class="navbar-nav me-auto mt-2">
                        <li class="nav-item"><a class="nav-link" href="/tasks">Tasks</a></li>
                        <li class="nav-item">
                            <!-- Switched to button style for Kanban link -->
                            <a class="btn btn-primary" href="/kanban">Kanban</a>
                        </li>
                        <li class="nav-item"><a class="nav-link" href="/create">Create</a></li>
                        <li class="nav-item"><a class="nav-link" href="/modify">Modify</a></li>
                    </ul>
                    <ul class="navbar-nav ms-auto mt-2">
                        <li class="nav-item"><a class="nav-link" href="/logout">Log Out</a></li>
                    </ul>
                {% else %}
                    <ul class="navbar-nav ms-auto mt-2">
                        <li class="nav-item"><a class="nav-link" href="/register">Register</a></li>
                        <li class="nav-item"><a class="nav-link" href="/login">Log In</a></li>
                    </ul>
                {% endif %}
            </div>
        </div>
    </nav>

    <!-- Flash messages (alerts for user actions) -->
    {% if get_flashed_messages() %}
        <header>
            <div class="alert alert-warning text-center mb-0" role="alert">
                {% for message in get_flashed_messages() %}
                    {{ message }}
                {% endfor %}
            </div>
        </header>
    {% endif %}

    <!-- Main content area where individual page content will be injected -->
    <main class="container py-5 text-center">
        {% block main %}{% endblock %}
    </main>

    <!-- Footer with small text -->
    <footer class="mb-5">
        <p class="mb-3 small text-center text-muted">
            &copy; 2024 TaskFlow
        </p>
    </footer>

    <!-- Bootstrap JS for interactivity (uses Bootstrap's CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
</body>

</html>



File: login.html
----------------------------
{% extends "layout.html" %}

{# 
    Log In Page Template
    Developed by Stefania Galatolo, with assistance from ChatGPT 4.0. Let's say Stefania is the brains, and ChatGPT is the assistant who brings all the fancy ideas to life. A classic "Stefania & ChatGPT" collaboration!

    This template is responsible for rendering the Log In page of the web application. It extends from the 'layout.html' file, which serves as the base template for all pages. The login form includes fields for the username and password and submits the data using the POST method to the '/login' route in the Flask application.

    Inputs:
    - Username: A text input field where the user enters their username.
    - Password: A password input field where the user enters their password.

    Outputs:
    - Redirects to the '/login' route when the form is submitted. The server processes the data, authenticates the user, and responds accordingly.

    Correlation with Other Files:
    - This template extends 'layout.html', utilizing the base layout to maintain consistent styling and structure across the application.
    - The form action points to the '/login' route defined in the 'app.py' file, where the login logic is implemented.
#}

{% block title %}
    Log In
{% endblock %}

{% block main %}
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-md-3">
                <h1 class="text-center mb-3">Log In</h1>
                {# 
                    Login Form
                    This form collects the user's username and password. It sends a POST request to the '/login' route in the server, where user authentication is handled.

                    Form Details:
                    - Action: '/login' (route in the Flask application)
                    - Method: POST (sends form data securely to the server)
                    - Input Fields:
                        - Username: Text input for the user's username. Autofocus is set for better UX.
                        - Password: Password input for secure entry. The field is masked for security.

                    On successful login, the user is typically redirected to the home page or the tasks page, depending on the application logic in 'app.py'.
                #}
                <form action="/login" method="post">
                    <div class="mb-2">
                        <input autocomplete="off" autofocus class="form-control" name="username" placeholder="Username" type="text">
                    </div>
                    <div class="mb-2">
                        <input class="form-control" name="password" placeholder="Password" type="password">
                    </div>
                    <div class="text-center">
                        <button class="btn btn-primary" type="submit">Log In</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
{% endblock %}



File: modify.html
----------------------------
{% extends "layout.html" %}

{# 
    File: modify.html 
    Author: Stefania Galatolo, with a little help from ChatGPT 4o (because even wizards need a sidekick sometimes).
    
    Overview:
    - This template is part of the task management web app.
    - It's used to render the "Modify Task" page, which allows users to modify an existing task.
    - The page layout is divided into two main sections:
        1. Sidebar: For task filtering options.
        2. Main Content Area: For task modification and task list display.
    - This file interacts with several other components:
        - Extends `layout.html` to maintain a consistent look and feel across the app.
        - Includes `_sidebar.html` for task filtering options.
        - Includes `_modify_form.html` which contains the form to modify a task.
        - Includes `_tasks_body.html` to display a table of all tasks.
    
    Inputs:
    - This template does not directly accept user input but interacts with user inputs via the included `_modify_form.html`.
    
    Outputs:
    - Displays a form to modify task details and a table listing all current tasks.
    
    Correlation with Other Files:
    - The modifications submitted via the form in `_modify_form.html` are processed by the Flask route handling task modification (typically using a POST request).
    - `_tasks_body.html` dynamically displays tasks fetched from the database.
    - `layout.html` provides the overall page structure and common elements like the navbar.
    
    Flow:
    1. User navigates to the "Modify Task" page.
    2. Sidebar allows for filtering tasks (filters defined in `_sidebar.html`).
    3. User selects a task to modify via the form (`_modify_form.html`).
    4. User submits the form, which sends the modification to the server for processing.
    5. The task table (`_tasks_body.html`) displays the updated task list.
#}

{% block title %}
    Modify Task
{% endblock %}

{% block main %}
<div class="container-fluid">
    <div class="row">
        <!-- Sidebar -->
        <div class="col-md-3">
            {% include "_sidebar.html" %} <!-- Include sidebar for filters right after the navbar -->
        </div>

        <!-- Main Content Area -->
        <div class="col-md-9">
            <h1>Modify Task</h1>

            <!-- Include Modify Task Form -->
            {% include "_modify_form.html" %}
            
            <hr>

            <!-- All Tasks Table -->            
            {% include "_tasks_body.html" %} <!-- Only includes the tasks table, no filters -->
        </div>
    </div>
</div>
{% endblock %}



File: register.html
----------------------------
{# 
    File: register.html
    Author: Stefania Galatolo, assisted by ChatGPT 4o
    Description:
    - This HTML template is responsible for rendering the registration page for new users.
    - The page extends the base layout defined in "layout.html" and includes form elements
      for user input, such as username and password fields.
    - The form data is sent to the server using a POST request to the "/register" route.
    - The inputs include:
        * `username` - A unique identifier for the user.
        * `password` - The user's password (stored securely on the server).
        * `confirmation` - Confirmation of the password to ensure it matches the first input.
    - This template works closely with the `app.py` Flask route `/register`, which handles
      user registration by validating the form data, checking for username availability, 
      and securely storing user credentials.
    - It relies on the Bootstrap framework for responsive design and styling.

    Collaboration Note:
    - Developed by Stefania Galatolo with assistance from ChatGPT 4o.
    - Despite Stefania's initial struggle with HTML forms, ChatGPT 4o lent its expertise to
      ensure the form properly submits user data. No worries, Stefania – even the best coders
      need a digital sidekick now and then!
#}

{% extends "layout.html" %} {# Extending the base template to maintain a consistent layout across the app #}

{% block title %}
    Register
{% endblock %} {# Setting the page title to "Register" #}

{% block main %}
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-md-3">
                <h1 class="text-center mb-3">Register</h1>
                <form action="/register" method="post"> {# The form sends a POST request to the "/register" route #}
                    <div class="mb-2">
                        <input autocomplete="off" autofocus class="form-control" name="username" placeholder="Username" type="text">
                        {# Username field: captures the username, ensures it's unique on submission #}
                    </div>
                    <div class="mb-2">
                        <input class="form-control" name="password" placeholder="Password" type="password">
                        {# Password field: captures the user's password securely (in plaintext here, hashed on the server) #}
                    </div>
                    <div class="mb-2">
                        <input class="form-control" name="confirmation" placeholder="Confirm Password" type="password">
                        {# Confirmation field: ensures user inputs the correct password twice to avoid errors #}
                    </div>
                    <div class="text-center">
                        <button class="btn btn-primary" type="submit">Register</button>
                        {# Submit button: submits the form data to the server for processing #}
                    </div>
                </form>
            </div>
        </div>
    </div>
{% endblock %}



File: tasks.html
----------------------------
{# 
    File: tasks.html
    Developed by: Stefania Galatolo, with a bit of (much needed) magical assistance from ChatGPT 4.0 
    (because even the best developers need a little AI help sometimes 😅).

    Description:
    This template extends 'layout.html' and is responsible for rendering the main tasks page of the web application.
    It is structured into two main sections:
    1. Sidebar Section: Includes a sidebar for filtering and navigating through the tasks. 
       This is included from the '_sidebar.html' partial template.
    2. Tasks Table Section: Displays the tasks in a structured table format.
       This section is included from the '_tasks_body.html' partial template.
    The main purpose of this template is to provide an interactive and organized view of all tasks,
    leveraging Bootstrap for responsive design. 

    Inputs:
    - None directly from this template. However, it relies on the '_sidebar.html' and '_tasks_body.html' 
      for their respective functionalities, such as filtering options and task display.

    Outputs:
    - Renders a responsive tasks page layout with a sidebar and a tasks table section.
    - The filtering actions in the sidebar will dynamically update the task list displayed in the tasks table section.

    Correlations with Other Files:
    - '_sidebar.html': Included for filtering tasks. This template contains various filtering options to help the user 
      refine the task list based on different criteria like POS, status, and priority.
    - '_tasks_body.html': Included for displaying the task list. It fetches and displays tasks in a structured table 
      format, providing a detailed view of each task's attributes.
    - 'layout.html': The base template which this template extends. It provides the overall structure and common elements 
      (like navigation bar and footer) for the page.
    
    Flow:
    1. The layout provided by 'layout.html' is extended to maintain a consistent design across the application.
    2. Within the 'main' block, the page is divided into two main sections using Bootstrap's grid system.
       a. The left section includes the sidebar, which allows users to filter tasks.
       b. The right section displays the tasks in a table format, updating based on the filters applied in the sidebar.
#}

{% extends "layout.html" %}

{% block main %}
<div class="container-fluid">
    <div class="row">
        <!-- Sidebar Section -->
        <div class="col-md-3">
            {% include '_sidebar.html' %}
        </div>

        <!-- Tasks Table Section -->
        <div class="col-md-9">
            {% include '_tasks_body.html' %}
        </div>
    </div>
</div>
{% endblock %}



File: _create_form.html
----------------------------
<!-- 
    File: create_task_form.html
    Developer: Stefania Galatolo, with ChatGPT's brilliant code insights.
    Description: This HTML file defines the form for creating a new task in the task management app.
    Stefania brought her coding A-game, but when the form needed some pizzazz, ChatGPT was there with the assists!

    Purpose:
    - This form enables users to input all necessary details for a new task, ensuring comprehensive task creation.
    - Captures information ranging from basic identifiers like POS Name and POS ID to detailed attributes such as task descriptions, dates, and blockers.
    
    Inputs Collected:
    - **POS Name and POS ID**: Identifies the Point of Sale related to the task, linking it to specific POS data.
    - **Reconciliation Date**: Records the date for financial reconciliation, defaulting to today's date.
    - **Certified**: Boolean value indicating if the task is certified (Yes/No).
    - **Status**: Current stage of the task, with options such as Backlog, To Do, In Progress, Done.
    - **Priority**: Indicates task urgency, with options including None, Low, Medium, High.
    - **Start Date and Due Date**: Define the timeline for handling the task, both defaulting to the current date.
    - **Description**: A text field for a detailed explanation of the task.
    - **Blocker Description and Responsible**: Capture any hindrances to task progress and who is responsible for resolving them.
    - **Additional Notes**: Provides space for any other pertinent information.

    Flow:
    - The user interacts with the form, selecting values and filling out necessary fields.
    - Upon submission, the form data is sent via a POST request to the "/create" route in the Flask app.
    - The server processes this data, inserts a new task record into the SQL database, and returns a response.
    - The accompanying JavaScript file 'createTasks.js' manages dynamic client-side functionalities, such as form validation or user feedback.

    Interactions with Other Files:
    - **`createTasks.js`**: Enhances form interactivity, handles client-side validation, and possibly manages dynamic field updates.
    - **Flask backend (`/create` route)**: Receives and processes the form data, storing it in the database and providing user feedback.
    - **SQL Database**: The data collected by this form is inserted into the relevant database table, contributing to the task records displayed elsewhere in the app (e.g., Kanban board, task list).
-->

<!-- Create Task Form -->
<form id="createTaskForm" method="POST" action="/create">
    <div class="container-fluid">
        <div class="row">
            <!-- Column 1: POS Information -->
            <div class="col-md-4">
                <!-- POS Name Selection -->
                <div class="mb-3">
                    <label for="pos_name" class="form-label">POS Name:</label>
                    <!-- Dropdown to select POS Name. Values are dynamically populated from the 'pos_data' passed in the Flask context -->
                    <select id="pos_name" class="form-control" name="pos_name" required>
                        <option value="" disabled selected>Select POS Name</option>
                        {% for pos in pos_data %}
                            <option value="{{ pos['pos_name'] }}" data-pos-id="{{ pos['pos_id'] }}">{{ pos['pos_name'] }}</option>
                        {% endfor %}
                    </select>
                </div>

                <!-- POS ID Selection -->
                <div class="mb-3">
                    <label for="pos_id" class="form-label">POS ID:</label>
                    <!-- Dropdown to select POS ID. This value correlates with the POS Name selected and ensures proper data association -->
                    <select id="pos_id" class="form-control" name="pos_id" required>
                        <option value="" disabled selected>Select POS ID</option>
                        {% for pos in pos_data %}
                            <option value="{{ pos['pos_id'] }}" data-pos-name="{{ pos['pos_name'] }}">{{ pos['pos_id'] }}</option>
                        {% endfor %}
                    </select>
                </div>

                <!-- Reconciliation Date -->
                <div class="mb-3">
                    <label for="reconciliation_date" class="form-label">Reconciliation Date:</label>
                    <!-- Date input for reconciliation date, defaults to today's date to streamline user experience -->
                    <input id="reconciliation_date" class="form-control" name="reconciliation_date" type="date" value="{{ date.today().strftime('%Y-%m-%d') }}">
                </div>

                <!-- Certified -->
                <div class="mb-3">
                    <label class="form-label">Certified:</label>
                    <!-- Radio buttons to select if the task is certified. Provides binary choice between 'Yes' or 'No' -->
                    <div>
                        <input type="radio" id="certified_yes" name="certified" value="true">
                        <label for="certified_yes">Yes</label>
                    </div>
                    <div>
                        <input type="radio" id="certified_no" name="certified" value="false">
                        <label for="certified_no">No</label>
                    </div>
                </div>
            </div>

            <!-- Column 2: Task Details -->
            <div class="col-md-4">
                <!-- Status Radio Buttons -->
                <div class="mb-3">
                    <label class="form-label">Status:</label>
                    <!-- Radio buttons for task status selection. Allows users to specify the current stage of the task -->
                    <div>
                        <input type="radio" id="statusBacklog" name="status" value="Backlog">
                        <label for="statusBacklog">Backlog</label>
                    </div>
                    <div>
                        <input type="radio" id="statusToDo" name="status" value="To Do">
                        <label for="statusToDo">To Do</label>
                    </div>
                    <div>
                        <input type="radio" id="statusInProgress" name="status" value="In Progress">
                        <label for="statusInProgress">In Progress</label>
                    </div>
                    <div>
                        <input type="radio" id="statusDone" name="status" value="Done">
                        <label for="statusDone">Done</label>
                    </div>
                </div>

                <!-- Priority Radio Buttons -->
                <div class="mb-3">
                    <label class="form-label">Priority:</label>
                    <!-- Radio buttons for task priority selection, categorizing the urgency of the task -->
                    <div>
                        <input type="radio" id="priorityNone" name="priority" value="None">
                        <label for="priorityNone">None</label>
                    </div>
                    <div>
                        <input type="radio" id="priorityLow" name="priority" value="Low">
                        <label for="priorityLow">Low</label>
                    </div>
                    <div>
                        <input type="radio" id="priorityMedium" name="priority" value="Medium">
                        <label for="priorityMedium">Medium</label>
                    </div>
                    <div>
                        <input type="radio" id="priorityHigh" name="priority" value="High">
                        <label for="priorityHigh">High</label>
                    </div>
                </div>

                <!-- Start Date -->
                <div class="mb-3">
                    <label for="start_date" class="form-label">Start Date:</label>
                    <!-- Date input for task start date. By default, it suggests today's date to facilitate immediate task scheduling -->
                    <input id="start_date" class="form-control" name="start_date" type="date" value="{{ date.today().strftime('%Y-%m-%d') }}">
                </div>

                <!-- Due Date -->
                <div class="mb-3">
                    <label for="due_date" class="form-label">Due Date:</label>
                    <!-- Date input for task due date. Helps set a deadline for the task completion -->
                    <input id="due_date" class="form-control" name="due_date" type="date" value="{{ date.today().strftime('%Y-%m-%d') }}">
                </div>
            </div>

            <!-- Column 3: Descriptions and Notes -->
            <div class="col-md-4">
                <!-- Task Description -->
                <div class="mb-3">
                    <label for="description" class="form-label">Task Description:</label>
                    <!-- Text area for a detailed task description. Provides an opportunity to elaborate on the task’s requirements -->
                    <textarea id="description" class="form-control" name="description"></textarea>
                </div>

                <!-- Blocker Description -->
                <div class="mb-3">
                    <label for="blocker_desc" class="form-label">Blocker Description:</label>
                    <!-- Text area for any blockers related to the task. Describes issues that may impede task progress -->
                    <textarea id="blocker_desc" class="form-control" name="blocker_desc"></textarea>
                </div>

                <!-- Blocker Responsible -->
                <div class="mb-3">
                    <label for="blocker_responsible" class="form-label">Blocker Responsible:</label>
                    <!-- Text area to specify who is responsible for resolving the blocker. Clarifies accountability for issue resolution -->
                    <textarea id="blocker_responsible" class="form-control" name="blocker_responsible"></textarea>
                </div>

                <!-- Additional Notes -->
                <div class="mb-3">
                    <label for="notes" class="form-label">Additional Notes:</label>
                    <!-- Text area for any additional notes. Allows the user to add any extra information or context -->
                    <textarea id="notes" class="form-control" name="notes"></textarea>
                </div>
            </div>
        </div>

        <!-- Submit Button -->
        <button class="btn btn-primary" type="submit">Create Task</button>
    </div>
</form>

<!-- Include the JavaScript file for create functionality -->
<script src="{{ url_for('static', filename='js/createTasks.js') }}"></script>



File: _kanban_board.html
----------------------------
<!-- 
    Filename: kanban.html
    Developed by Stefania Galatolo, with a sprinkle of magic from ChatGPT 4o.
    Description:
    - This file defines the Kanban board interface for the task management application.
    - It creates a visual board with four columns: Backlog, To Do, In Progress, and Done.
    - Tasks will be dynamically populated into these columns based on their status in the database.
    - Includes a "Due Today" button for filtering tasks that are due today.
    - Integrates with Sortable.js to provide drag-and-drop functionality for task cards.
    - References an external JavaScript file ('kanban.js') that contains the logic for dynamic rendering and updating of tasks.
    
    Interactions:
    - The board relies on the JavaScript file 'kanban.js' to handle:
        * Fetching tasks from the server using AJAX.
        * Populating the columns with task data.
        * Implementing drag-and-drop to move tasks between columns and update their status.
        * Filtering tasks due today when the "Due Today" button is clicked.
    - Sortable.js library is included for enhancing user interaction through drag-and-drop.
    - The tasks data is initially fetched from the server-side Flask route and rendered dynamically into each column.
    - Updates made on the board are sent back to the server to persist the changes in the database.
    
    Usage:
    - The user can interact with the Kanban board by dragging task cards between columns.
    - Clicking the "Due Today" button filters and displays tasks that have a due date set for today.
    - This template is part of the front-end interface and is essential for providing a visual representation of task statuses.

    Inputs:
    - Task data fetched from the server using JavaScript (from the database).
    
    Outputs:
    - Dynamic visual representation of tasks within the Kanban board columns.
    - Sends updates to the server when tasks are moved between columns.
-->

<h1 class="mb-4">Kanban Board</h1>

<!-- "Due Today" button: Filters tasks to show only those due today -->
<button id="dueTodayBtn" class="btn btn-primary mb-3">Due Today</button>

<!-- Kanban Board Columns: Contains four columns to categorize tasks based on their status -->
<div class="row mt-4 kanban-board">
    <!-- Backlog Column: Displays tasks that are not yet started -->
    <div class="col-lg-3 kanban-column" id="backlog">
        <label class="form-label">Backlog</label>
        <!-- Backlog tasks will be dynamically populated here via JavaScript -->
    </div>
    <!-- To Do Column: Displays tasks that are ready to be worked on -->
    <div class="col-lg-3 kanban-column" id="todo">
        <label class="form-label">To Do</label>
        <!-- To Do tasks will be dynamically populated here via JavaScript -->
    </div>
    <!-- In Progress Column: Displays tasks currently being worked on -->
    <div class="col-lg-3 kanban-column" id="inprogress">
        <label class="form-label">In Progress</label>
        <!-- In Progress tasks will be dynamically populated here via JavaScript -->
    </div>
    <!-- Done Column: Displays tasks that have been completed -->
    <div class="col-lg-3 kanban-column" id="done">
        <label class="form-label">Done</label>
        <!-- Done tasks will be dynamically populated here via JavaScript -->
    </div>
</div>

<!-- Include Sortable.js for enabling drag-and-drop functionality on the Kanban board -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
<!-- Reference to the custom JavaScript file for Kanban functionality 
    - This script handles:
      * Fetching and rendering tasks
      * Implementing drag-and-drop to update task statuses
      * Filtering tasks due today -->
<script src="{{ url_for('static', filename='js/kanban.js') }}"></script>



File: _modify_form.html
----------------------------
<!--
    File: modify_task_form.html
    Developed by: Stefania Galatolo, assisted by ChatGPT 4.0
    Description:
    This file contains the HTML form used for modifying an existing task within the application.
    Users can update various task attributes, such as POS Name, POS ID, reconciliation date, certification status,
    task status, priority, start date, due date, task description, blocker description, blocker responsible, and additional notes.

    Key Features:
    - Task ID input: Identifies the specific task to be modified.
    - POS Name and POS ID dropdowns: Allow selection of point-of-sale identifiers.
    - Various input fields and radio buttons for updating task properties.
    - The form submits a POST request to the '/modify' route, which should be handled server-side by Flask to update the task in the database.
    - It includes a JavaScript file 'modifyTasks.js' for handling any client-side interactivity or validation.

    Flow:
    - The user fills out the form fields.
    - On form submission, a POST request is sent to the server.
    - The server processes the data and updates the relevant task in the database.
    - Feedback is given to the user based on the success or failure of the operation.

    Correlations with Other Files:
    - modifyTasks.js: Provides client-side logic for the modify form.
    - app.py (Flask backend): Contains the route '/modify' that processes the form submission.
    - taskflow.db: The database where task updates are stored.
    - styles.css: May contain styles for the form and its elements.

    Note: This form relies on data passed from the Flask backend, such as 'pos_data', which should be available in the context where this template is rendered.
-->

<form id="modifyTaskForm" method="POST" action="/modify">
    <div class="container-fluid">
        <div class="row">
            <!-- Task ID Input -->
            <!--
                Input field for the unique Task ID.
                This ID is used to identify which task is being modified.
                It is required to match an existing task in the database.
            -->
            <div class="col-md-4">
                <div class="mb-3">
                    <label for="task_id" class="form-label" style="font-weight: bold; font-size: 1.2em;">Task ID:</label>
                    <input id="task_id" class="form-control" name="task_id" type="text" placeholder="Enter Task ID" required>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Column 1 -->
            <div class="col-md-4">
                <!-- POS Name Selection -->
                <!--
                    Dropdown for selecting the POS (Point of Sale) Name.
                    Dynamically populated using Flask's template rendering with data from 'pos_data'.
                    The selected POS Name is sent with the form data upon submission.
                -->
                <div class="mb-3">
                    <label for="pos_name" class="form-label">POS Name:</label>
                    <select id="pos_name" class="form-control" name="pos_name" required>
                        <option value="" disabled selected>Select POS Name</option>
                        {% for pos in pos_data %}
                            <option value="{{ pos['pos_name'] }}" data-pos-id="{{ pos['pos_id'] }}">{{ pos['pos_name'] }}</option>
                        {% endfor %}
                    </select>
                </div>

                <!-- POS ID Selection -->
                <!--
                    Dropdown for selecting the POS ID.
                    Correlates with the POS Name and is used to uniquely identify the POS in the database.
                    The selected POS ID is sent with the form data upon submission.
                -->
                <div class="mb-3">
                    <label for="pos_id" class="form-label">POS ID:</label>
                    <select id="pos_id" class="form-control" name="pos_id" required>
                        <option value="" disabled selected>Select POS ID</option>
                        {% for pos in pos_data %}
                            <option value="{{ pos['pos_id'] }}" data-pos-name="{{ pos['pos_name'] }}">{{ pos['pos_id'] }}</option>
                        {% endfor %}
                    </select>
                </div>

                <!-- Reconciliation Date -->
                <!--
                    Input for specifying the reconciliation date.
                    Defaults to the current date using Flask's 'date.today()' method.
                    Used to track when the task was last reconciled.
                -->
                <div class="mb-3">
                    <label for="reconciliation_date" class="form-label">Reconciliation Date:</label>
                    <input id="reconciliation_date" class="form-control" name="reconciliation_date" type="date" value="{{ date.today().strftime('%Y-%m-%d') }}">
                </div>

                <!-- Certified -->
                <!--
                    Radio buttons for selecting whether the task is certified.
                    Options are 'Yes' or 'No', representing a boolean value ('true' or 'false').
                    Helps in tracking the certification status of a task.
                -->
                <div class="mb-3">
                    <label class="form-label">Certified:</label>
                    <div>
                        <input type="radio" id="certified_yes" name="certified" value="true">
                        <label for="certified_yes">Yes</label>
                    </div>
                    <div>
                        <input type="radio" id="certified_no" name="certified" value="false">
                        <label for="certified_no">No</label>
                    </div>
                </div>
            </div>

            <!-- Column 2 -->
            <div class="col-md-4">
                <!-- Status Radio Buttons -->
                <!--
                    Radio buttons to set the task status.
                    Options include 'Backlog', 'To Do', 'In Progress', and 'Done'.
                    Used to indicate the current state of the task.
                -->
                <div class="mb-3">
                    <label class="form-label">Status:</label>
                    <div>
                        <input type="radio" id="statusBacklog" name="status" value="Backlog">
                        <label for="statusBacklog">Backlog</label>
                    </div>
                    <div>
                        <input type="radio" id="statusToDo" name="status" value="To Do">
                        <label for="statusToDo">To Do</label>
                    </div>
                    <div>
                        <input type="radio" id="statusInProgress" name="status" value="In Progress">
                        <label for="statusInProgress">In Progress</label>
                    </div>
                    <div>
                        <input type="radio" id="statusDone" name="status" value="Done">
                        <label for="statusDone">Done</label>
                    </div>
                </div>

                <!-- Priority Radio Buttons -->
                <!--
                    Radio buttons to set the priority level of the task.
                    Options include 'None', 'Low', 'Medium', and 'High'.
                    Helps in prioritizing tasks for better task management.
                -->
                <div class="mb-3">
                    <label class="form-label">Priority:</label>
                    <div>
                        <input type="radio" id="priorityNone" name="priority" value="None">
                        <label for="priorityNone">None</label>
                    </div>
                    <div>
                        <input type="radio" id="priorityLow" name="priority" value="Low">
                        <label for="priorityLow">Low</label>
                    </div>
                    <div>
                        <input type="radio" id="priorityMedium" name="priority" value="Medium">
                        <label for="priorityMedium">Medium</label>
                    </div>
                    <div>
                        <input type="radio" id="priorityHigh" name="priority" value="High">
                        <label for="priorityHigh">High</label>
                    </div>
                </div>

                <!-- Start Date -->
                <!--
                    Input for specifying the start date of the task.
                    Defaults to the current date using Flask's 'date.today()' method.
                    Used to track when the task is scheduled to begin.
                -->
                <div class="mb-3">
                    <label for="start_date" class="form-label">Start Date:</label>
                    <input id="start_date" class="form-control" name="start_date" type="date" value="{{ date.today().strftime('%Y-%m-%d') }}">
                </div>

                <!-- Due Date -->
                <!--
                    Input for specifying the due date of the task.
                    Defaults to the current date using Flask's 'date.today()' method.
                    Helps in tracking the deadline for the task's completion.
                -->
                <div class="mb-3">
                    <label for="due_date" class="form-label">Due Date:</label>
                    <input id="due_date" class="form-control" name="due_date" type="date" value="{{ date.today().strftime('%Y-%m-%d') }}">
                </div>
            </div>

            <!-- Column 3 -->
            <div class="col-md-4">
                <!-- Task Description -->
                <!--
                    Text area for entering a detailed description of the task.
                    Provides context and additional information about the task.
                -->
                <div class="mb-3">
                    <label for="description" class="form-label">Task Description:</label>
                    <textarea id="description" class="form-control" name="description"></textarea>
                </div>

                <!-- Blocker Description -->
                <!--
                    Text area for describing any blockers preventing task progress.
                    Used to identify and communicate obstacles that need resolution.
                -->
                <div class="mb-3">
                    <label for="blocker_desc" class="form-label">Blocker Description:</label>
                    <textarea id="blocker_desc" class="form-control" name="blocker_desc"></textarea>
                </div>

                <!-- Blocker Responsible -->
                <!--
                    Text area to specify the person responsible for the blocker.
                    Helps in assigning responsibility for resolving obstacles.
                -->
                <div class="mb-3">
                    <label for="blocker_responsible" class="form-label">Blocker Responsible:</label>
                    <textarea id="blocker_responsible" class="form-control" name="blocker_responsible"></textarea>
                </div>

                <!-- Additional Notes -->
                <!--
                    Text area for adding any additional notes or comments about the task.
                    Can include important details or reminders for the task.
                -->
                <div class="mb-3">
                    <label for="notes" class="form-label">Additional Notes:</label>
                    <textarea id="notes" class="form-control" name="notes"></textarea>
                </div>
            </div>
        </div>

        <!-- Modify Button -->
        <!--
            Button to submit the form data.
            Sends a POST request to the server to update the task with the new details.
        -->
        <button class="btn btn-primary" type="submit" id="modifyBtn">Modify</button>
    </div>
</form>

<!-- Include the JavaScript file for modify functionality -->
<!--
    Link to 'modifyTasks.js' for handling client-side interactivity.
    This script may include form validation, AJAX requests, or other dynamic functionalities.
-->
<script src="{{ url_for('static', filename='js/modifyTasks.js') }}"></script>



File: _sidebar.html
----------------------------
<!-- 
File: _sidebar.html (or similar, depending on where this is being included)
Author: Stefania Galatolo, assisted by ChatGPT 4o
---
This template is responsible for rendering the filter sidebar in the task management application. 
It provides the user interface elements for filtering tasks based on various criteria, such as POS number, POS name, status, priority, and date range.
These filters are essential for narrowing down the list of tasks displayed in the main task view. 
---
Inputs: 
    - `pos_data` (context variable): List of POS entries fetched from the database, each containing `pos_id` and `pos_name` for selection options.
Outputs:
    - Filtered task list based on user input through the filter options provided in this sidebar.
Correlations with Other Files:
    - This template is typically included in a larger layout or view, such as `tasks.html` or a similar file where task filtering is needed.
    - The filter options here interact with JavaScript functions (potentially in `tasksLookup.js`) to dynamically update the task display without reloading the page.
-->

<!-- Search Bar -->
<div class="filter-group mb-4"> <!-- Grouping for custom styling of the search bar -->
    <h2 class="filter-title">Filter</h2> <!-- Title for the filter section -->
    <label for="taskSearch" class="filter-label">Search Tasks:</label> <!-- Label for the search input field -->
    <!-- 
    Search Input: Allows users to search for tasks by a keyword.
    - ID: taskSearch
    - Class: form-control (Bootstrap class for styling)
    - Placeholder: Provides a hint to the user on what to enter.
    - Type: text (standard text input)
    -->
    <input id="taskSearch" class="form-control" placeholder="Search tasks..." type="text">
</div>

<!-- POS Group -->
<div class="filter-group mb-4"> <!-- Grouping for POS-related filters -->
    <label for="filterPosID" class="filter-label">POS Number:</label> <!-- Label for the POS Number filter -->
    <!-- 
    POS Number Dropdown: Allows filtering tasks by the POS ID.
    - ID: filterPosID
    - Class: form-select (Bootstrap class for styling)
    - Options: Populated dynamically with `pos_data` context variable
    - First Option: "All" to indicate no filtering
    -->
    <select id="filterPosID" class="form-select mb-2">
        <option value="">All</option> <!-- Default option to show all POS entries -->
        {% for pos in pos_data %}
        <!-- Looping through `pos_data` to populate the dropdown options -->
        <option value="{{ pos.pos_id }}">{{ pos.pos_id }}</option> <!-- Option value and display are set to `pos_id` -->
        {% endfor %}
    </select>

    <label for="filterPosName" class="filter-label">POS Name:</label> <!-- Label for the POS Name filter -->
    <!-- 
    POS Name Dropdown: Allows filtering tasks by the POS Name.
    - ID: filterPosName
    - Class: form-select (Bootstrap class for styling)
    - Options: Populated dynamically with `pos_data` context variable
    - First Option: "All" to indicate no filtering
    -->
    <select id="filterPosName" class="form-select">
        <option value="">All</option> <!-- Default option to show all POS entries -->
        {% for pos in pos_data %}
        <!-- Looping through `pos_data` to populate the dropdown options -->
        <option value="{{ pos.pos_name }}">{{ pos.pos_name }}</option> <!-- Option value and display are set to `pos_name` -->
        {% endfor %}
    </select>
</div>

<!-- Status Filters -->
<div class="filter-group mb-4"> <!-- Grouping for task status filters -->
    <label class="filter-label">Status:</label> <!-- Label for status filters -->
    <!-- 
    Status Checkboxes: Allows users to filter tasks by their current status.
    - Each checkbox has an ID corresponding to the status it represents.
    - Value: Set to the status that will be used for filtering.
    -->
    <div>
        <input type="checkbox" id="statusBacklog" value="Backlog"> Backlog
    </div>
    <div>
        <input type="checkbox" id="statusToDo" value="To Do"> To Do
    </div>
    <div>
        <input type="checkbox" id="statusInProgress" value="In Progress"> In Progress
    </div>
    <div>
        <input type="checkbox" id="statusDone" value="Done"> Done
    </div>
</div>

<!-- Priority Filters -->
<div class="filter-group mb-4"> <!-- Grouping for task priority filters -->
    <label class="filter-label">Priority:</label> <!-- Label for priority filters -->
    <!-- 
    Priority Checkboxes: Allows users to filter tasks based on their priority level.
    - Each checkbox has an ID corresponding to the priority it represents.
    - Value: Set to the priority level that will be used for filtering.
    -->
    <div>
        <input type="checkbox" id="priorityNone" value="None"> None
    </div>
    <div>
        <input type="checkbox" id="priorityLow" value="Low"> Low
    </div>
    <div>
        <input type="checkbox" id="priorityMedium" value="Medium"> Medium
    </div>
    <div>
        <input type="checkbox" id="priorityHigh" value="High"> High
    </div>
</div>

<!-- Reconciliation Dates Group -->
<div class="filter-group mb-4"> <!-- Grouping for date filters -->
    <label for="startDate" class="filter-label">Start Date:</label> <!-- Label for start date filter -->
    <!-- 
    Start Date Input: Allows filtering tasks based on their start date.
    - ID: startDate
    - Type: date (provides a date picker UI)
    - Value: Set to the current date by default using `strftime` for formatting.
    -->
    <input type="date" id="startDate" class="form-control mb-2" value="{{ date.today().strftime('%Y-%m-%d') }}">

    <label for="endDate" class="filter-label">Due Date:</label> <!-- Label for end date filter -->
    <!-- 
    End Date Input: Allows filtering tasks based on their due date.
    - ID: endDate
    - Type: date (provides a date picker UI)
    - Value: Set to the current date by default using `strftime` for formatting.
    -->
    <input type="date" id="endDate" class="form-control" value="{{ date.today().strftime('%Y-%m-%d') }}">
</div>

<!-- Filter Buttons -->
<div class="filter-buttons"> <!-- Grouping for filter action buttons -->
    <!-- 
    Apply Filters Button: Triggers the filtering process based on selected criteria.
    - ID: filterBtn
    - Class: btn btn-primary (Bootstrap classes for styling)
    -->
    <button id="filterBtn" class="btn btn-primary mb-2">Apply Filters</button>
    <!-- 
    Clear Filters Button: Resets all filters to their default state.
    - ID: clearFilterBtn
    - Class: btn btn-secondary (Bootstrap classes for styling)
    -->
    <button id="clearFilterBtn" class="btn btn-secondary mb-2">Clear Filters</button>
</div>


File: _tasks_body.html
----------------------------
<!-- 
    Developed by Stefania Galatolo, assisted by ChatGPT 4. 
    In this collaboration, ChatGPT helped Stefania keep things organized and smooth—because let's face it, 
    even with all that CS50 knowledge, things can get messy! 
-->

<!-- 
    tasks-wrapper: This wrapper contains the main task management table.
    The table displays all tasks retrieved from the backend and rendered dynamically using Flask's Jinja templating engine.
    Pagination buttons are generated by JavaScript and placed in the paginationContainer div.
    
    Inputs: 
    - Task data is provided by Flask as a list of task objects.
    - The task data includes attributes like task_id, pos_id, pos_name, task_status, etc.
    
    Outputs:
    - A dynamic table displaying the tasks, with support for pagination and responsiveness.
    - The JavaScript file 'tasksLookup.js' handles pagination and potentially other dynamic interactions.
-->
<div class="tasks-wrapper">
    <h2 class="mt-0">Tasks</h2>

    <!-- Pagination Controls -->
    <!-- Pagination controls are generated dynamically through JavaScript -->
    <div id="paginationContainer" class="pagination-container mt-3">
        <!-- Pagination buttons will be dynamically inserted here by the JavaScript -->
    </div>

    <!-- Table containing task details -->
    <!-- The table is populated dynamically using data provided by Flask (Jinja templating) -->
    <div class="table-responsive">
        <table class="table table-striped mt-3">
            <thead>
                <tr>
                    <!-- Columns are task attributes such as Task ID, POS ID, Name, etc. -->
                    <th>Task ID</th>
                    <th>POS ID</th>
                    <th>POS Name</th>
                    <th>Rec. Date</th>
                    <th>Certified</th>
                    <th>Task Desc.</th>
                    <th>Status</th>
                    <th>Priority</th>
                    <th>Blockers Desc.</th>
                    <th>Blockers Resp</th>
                    <th>Start Date</th>
                    <th>Due Date</th>
                    <th class="notes-column">Notes</th>
                </tr>
            </thead>
            <tbody id="taskTableBody">
                <!-- Task rows are dynamically generated by Flask's Jinja templating system -->
                {% for task in tasks %}
                <tr>
                    <td>{{ task.task_id }}</td>
                    <td>{{ task.pos_id }}</td>
                    <td>{{ task.pos_name }}</td>
                    <td>{{ task.rec_date }}</td>
                    <td>{{ task.rec_certified }}</td>
                    <td>{{ task.task_desc }}</td>
                    <td>{{ task.task_status }}</td>
                    <td>{{ task.task_priority }}</td>
                    <td>{{ task.blocker_desc }}</td>
                    <td>{{ task.blocker_responsible }}</td>
                    <td>{{ task.task_start_date }}</td>
                    <td>{{ task.task_due_date }}</td>
                    <td>{{ task.task_notes }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
</div>

<!-- 
    This script tag references the tasksLookup.js file located in the static/js/ folder.
    This JavaScript file is responsible for handling dynamic table updates, such as pagination, sorting, and filtering.
-->
<script src="{{ url_for('static', filename='js/tasksLookup.js') }}"></script>



--- Directory: ./core/__pycache__ ---

--- Directory: ./docs ---

File: agile_development_process.txt
----------------------------
# Agile Development Process

The objective of this project is to develop a Kanban board task management system for the accounts payable department of a grocery and consumer goods retailer with 28 points of sale. The application transitions from managing a CSV file to implementing a robust SQL database and is developed using Python, Flask, HTML, CSS, and JavaScript. An Agile approach is employed, with work broken down into sprints and managed through Git and GitHub using Visual Studio Code.

The core feature is a Kanban board that allows users to interact with task records in the database via a graphical user interface, providing functionality for updating records through drag-and-drop actions.

The project aims to deliver an intuitive task management tool, inspired by popular applications such as Trello and Jira, closely mirroring the structure of the CS50 finance problem set.

**Note:** This is a solo developer project, and the estimated timeline is an initial sketch that may be revised as the project progresses. The total estimated time is spread over approximately three to four weeks.

## Sprint 0: Project Planning & Stakeholder Requirements (Week 1)
**Objective:** Establish the project scope and compile all necessary requirements.

- **Task 1:** Stakeholder Identification
  - Identify the primary stakeholder and outline their needs for the accounts payable management tool.

- **Task 2:** Define Project Objectives
  - Set the scope of the project, focusing on essential features such as task tracking, visualization in a Kanban board, and drag-and-drop task management.

- **Task 3:** User Stories Creation
  - Develop user stories to represent key functionalities:
    - User authentication and secure task management access.
    - Visualization of tasks in a Kanban board format.
    - CRUD (Create, Read, Update, Delete) operations on tasks.
    - Advanced task filtering and search capabilities.

- **Task 4:** User Story Prioritization
  - Prioritize user stories based on their impact and feasibility, focusing on core functionalities such as the Kanban board and basic task management.

- **Task 5:** Product Backlog Creation
  - Create a product backlog that details all identified features and tasks, establishing a foundation for sprint planning.

## Sprint 1: Environment Setup & User Authentication (Week 1-2)
**Objective:** Configure the development environment and implement user authentication.

- **Task 1:** Repository Initialization
  - Initialize a GitHub repository for version control and set up local development in Visual Studio Code.

- **Task 2:** Project Structure Setup
  - Establish the Flask project structure with a virtual environment, organizing directories for templates, static assets, and application logic.

- **Task 3:** Database Schema Design for User Accounts
  - Use SQLAlchemy to design the database schema for user accounts, including tables for user credentials and session management.

- **Task 4:** Implement User Authentication
  - Develop Flask routes for user registration, login, and logout functionalities.
  - Implement input validation and password hashing to enhance security.
  - Create session management to maintain user states.

- **Task 5:** Front-End Template Development
  - Design and implement HTML and CSS templates for user registration, login, and logout interfaces.

## Sprint 2: Core Task Management Development (Week 2-3)
**Objective:** Implement the foundational task management features, including task creation and display.

- **Task 1:** Task Database Schema Design
  - Create an SQLAlchemy schema for tasks, including fields such as `id`, `title`, `description`, `status`, `priority`, and timestamps.

- **Task 2:** Develop Task Display Routes
  - Implement Flask routes to display tasks on the home page, integrating with the database to fetch task data.

- **Task 3:** Implement Task Creation
  - Create a form for task creation with server-side validation.
  - Develop Flask routes to handle form submissions and insert task data into the database.

- **Task 4:** Data Validation and Sanitization
  - Implement input validation and sanitization to ensure data integrity and security.

- **Task 5:** Task Data Storage and Display
  - Store tasks in the database and utilize Jinja2 templates to render tasks in a table format on the home page.

## Sprint 3: Kanban Board Implementation (Week 3)
**Objective:** Develop an interactive Kanban board for task visualization and management.

- **Task 1:** Kanban Board Research and Library Selection
  - Investigate available JavaScript libraries for implementing a Kanban board and select an appropriate one for integration.

- **Task 2:** Develop Kanban Page Route
  - Create a Flask route to serve the Kanban board page, integrating it with the existing task management system.

- **Task 3:** Implement Drag-and-Drop Functionality
  - Use the chosen JavaScript library to enable drag-and-drop functionality within the Kanban board, allowing tasks to be moved between columns.

- **Task 4:** Implement Database Updates from Kanban Board
  - Develop AJAX calls to update task status in the database when tasks are moved on the Kanban board.

- **Task 5:** Dynamic Data Integration
  - Fetch task data from the database and populate the Kanban board dynamically using JSON.

- **Task 6:** User Interface Refinement
  - Enhance the user interface with CSS for a polished look and smooth user interactions.

## Sprint 4: Testing & Debugging (Week 3-4)
**Objective:** Conduct comprehensive testing and debugging to ensure application stability and performance.

- **Task 1:** Unit Testing for Flask Routes
  - Write unit tests for critical Flask routes, including user authentication and task management endpoints.

- **Task 2:** End-to-End Testing
  - Perform end-to-end testing of key user stories to ensure the application behaves as expected.

- **Task 3:** Debugging and Issue Resolution
  - Identify and resolve any bugs discovered during testing, focusing on data flow and user interaction issues.

- **Task 4:** Functional Testing of Core Features
  - Test core functionalities such as user authentication, task creation, and the Kanban board for consistency and reliability.

- **Task 5:** Cross-Browser and Responsive Design Verification
  - Verify the application's compatibility across different browsers and devices, ensuring a responsive design.

## Sprint 5: Deployment & Presentation Preparation (Week 4)
**Objective:** Deploy the application to a production environment and prepare for the final presentation.

- **Task 1:** Production Environment Setup
  - Set up the production environment using Gunicorn or a preferred platform for deployment.

- **Task 2:** Database Migration
  - Migrate the SQL database schema and data to the production server.

- **Task 3:** Final Testing on Live Environment
  - Conduct a final round of testing on the deployed application to ensure all features are functioning correctly.

- **Task 4:** Presentation Preparation
  - Prepare a final presentation summarizing the project goals, key features, challenges, and a live demonstration of the application.

- **Task 5:** Final Code Push and Release Tagging
  - Push all final changes to GitHub and tag the release version for reference.

## Sprint 6: Presentation & Feedback Collection (Week 4)
**Objective:** Present the project and gather feedback for future improvements.

- **Task 1:** Deliver the Presentation
  - Conduct a presentation showcasing the application, demonstrating key features and the problem it solves.

- **Task 2:** Live Demonstration
  - Perform a live demonstration of the application's functionality, highlighting the Kanban board and task management capabilities.

- **Task 3:** Collect Feedback
  - Gather feedback on the application from stakeholders or audience members, noting areas for potential improvement.

- **Task 4:** Reflection and Planning for Future Enhancements
  - Reflect on the feedback received and outline a plan for any post-presentation improvements or future feature development.

---

This Agile development process outlines a structured approach to building a comprehensive Kanban board task management system. The estimated timeline is spread over approximately three to four weeks, recognizing that this is a solo developer project and may require adjustments as the project evolves.



File: product_backlog.md
----------------------------
# Product Backlog

This document outlines the product backlog for the task management application. Each item is prioritized, and details include the description, priority, and status.

## Backlog Items

### 1. User Authentication
- **Description:** Implement user registration and login functionality.
- **Priority:** High
- **Status:** Completed
- **Tasks:**
  - Create user model in the database
  - Develop registration and login forms
  - Implement user session management

### 2. Task Creation
- **Description:** Allow users to create tasks with details like description, status, priority, and due dates.
- **Priority:** High
- **Status:** Completed
- **Tasks:**
  - Develop task creation form
  - Implement form validation
  - Store task details in the database

### 3. Task Modification
- **Description:** Provide functionality to modify existing tasks.
- **Priority:** High
- **Status:** In Progress
- **Tasks:**
  - Develop task modification form
  - Implement the update functionality for task attributes
  - Ensure data synchronization between front-end and back-end

### 4. Kanban Board
- **Description:** Create a Kanban board for visualizing tasks in different statuses.
- **Priority:** High
- **Status:** Completed
- **Tasks:**
  - Design the Kanban board layout with columns for Backlog, To Do, In Progress, and Done
  - Integrate drag-and-drop functionality using Sortable.js
  - Implement task status updates on drop events

### 5. Task Filtering and Search
- **Description:** Implement task filtering and search functionality.
- **Priority:** Medium
- **Status:** Completed
- **Tasks:**
  - Develop a sidebar for task filtering by POS, status, priority, and dates
  - Implement search functionality to find tasks by keywords
  - Integrate real-time filtering and search in the task list

### 6. Task Pagination
- **Description:** Add pagination to handle large numbers of tasks.
- **Priority:** Medium
- **Status:** Completed
- **Tasks:**
  - Implement pagination controls in the task table
  - Fetch and display tasks in pages
  - Ensure smooth navigation between pages

### 7. Task Due Today Filter
- **Description:** Allow users to filter tasks that are due today.
- **Priority:** Low
- **Status:** Completed
- **Tasks:**
  - Add "Due Today" button on the Kanban board
  - Implement filtering logic to show only tasks due today

### 8. Task Notes
- **Description:** Enable adding and viewing notes for each task.
- **Priority:** Low
- **Status:** Completed
- **Tasks:**
  - Create a text area for notes in task creation and modification forms
  - Store and display notes for each task

### 9. Error Handling and Validation
- **Description:** Implement comprehensive error handling and input validation across the application.
- **Priority:** Medium
- **Status:** Completed
- **Tasks:**
  - Validate user inputs in all forms
  - Implement error messages and alerts for invalid inputs
  - Ensure back-end error handling for database operations

### 10. Responsive Design
- **Description:** Ensure the application is responsive and user-friendly on all devices.
- **Priority:** Low
- **Status:** Completed
- **Tasks:**
  - Apply responsive design principles using Bootstrap
  - Test UI on different screen sizes and devices
  - Optimize the layout for mobile users

## Upcoming Features

### 11. Task Assignment (Future)
- **Description:** Allow users to assign tasks to different users.
- **Priority:** To Be Decided
- **Status:** Planned
- **Tasks:**
  - Develop user assignment feature in task forms
  - Display assigned users on the Kanban board
  - Implement filtering by assigned user

### 12. Notifications (Future)
- **Description:** Implement notifications for task updates and deadlines.
- **Priority:** To Be Decided
- **Status:** Planned
- **Tasks:**
  - Design a notification system for important task updates
  - Integrate notifications with the user interface
  - Implement email notifications for deadlines

## Backlog Prioritization

- **High Priority:** User Authentication, Task Creation, Task Modification, Kanban Board
- **Medium Priority:** Task Filtering and Search, Task Pagination, Error Handling and Validation
- **Low Priority:** Task Due Today Filter, Task Notes, Responsive Design
- **Future Features:** Task Assignment, Notifications

---

This product backlog will guide the development and prioritization of tasks. It will be continuously updated as the project progresses and new requirements are identified.



File: product_requirements.md
----------------------------
# Kanban Board Task Management System - Requirements

## Project Overview

The goal of this project is to develop a web-based Kanban board task management system for a grocery and consumer goods retailer with 28 points of sale. The system aims to enhance task management by transitioning from a static Excel spreadsheet to a more robust and scalable SQL database. The development follows Agile principles, focusing on delivering core functionalities iteratively while allowing flexibility for future enhancements.

## Stakeholder Requirements

### 1. Core Functionalities

The project will deliver a minimum viable product (MVP) that includes the following core functionalities, designed to meet the primary needs of the accounts payable department:

#### 1.1 Data Migration
- **Requirement 1.1.1:** Migrate existing tasks from an Excel workbook to an SQL database using SQLAlchemy. The workbook includes fields such as `Grocery Store/Headquarter`, `Task Title`, `Task Status`, `Task Priority`, `Grocery Store Location`, `Task Start Date`, `Task Finish Date`, and `Notes`.
- **Requirement 1.1.2:** Design a database schema that reflects the structure of the Excel workbook, establishing appropriate tables and relationships to support future enhancements.

#### 1.2 Task Management
- **Requirement 1.2.1:** Implement a web interface using Flask that allows users to perform CRUD (Create, Read, Update, Delete) operations on tasks.
- **Requirement 1.2.2:** Users should be able to:
  - **Create New Tasks:** Enter task details through a form, including title, status, priority, start and finish dates, location, and relevant notes.
  - **View Tasks:** Display tasks in a structured format with filtering options for ease of access.
  - **Update Tasks:** Modify existing task details, such as changing the task status or editing descriptions.
  - **Delete Tasks:** Remove tasks from the database when they are no longer relevant.

#### 1.3 Querying and Filtering
- **Requirement 1.3.1:** Provide users with a query interface to filter tasks based on various criteria, including task status, start and finish dates, priority, and POS location.
- **Requirement 1.3.2:** Return a filtered list of tasks that match the selected criteria, facilitating effective task management and prioritization.

#### 1.4 Kanban Board Interface
- **Requirement 1.4.1:** Develop an interactive Kanban board interface that visually organizes tasks into columns based on their status (e.g., Backlog, To Do, In Progress, Done).
- **Requirement 1.4.2:** Integrate the Kanban board with the task filtering system to dynamically update based on user-selected criteria.
- **Requirement 1.4.3:** Display key task details (e.g., title, priority, dates) within the Kanban board for quick reference.
- **Requirement 1.4.4:** Ensure a user-friendly interface with clear visual distinctions between task statuses and priorities.

### 2. User Interface and Experience

The system should be designed with a focus on user-friendly interaction and accessibility, ensuring ease of use and efficient navigation.

#### 2.1 User Interface Design
- **Requirement 2.1.1:** Create a clean, responsive web interface with a consistent design across all pages, emphasizing usability.
- **Requirement 2.1.2:** Use visual elements like color-coding and layout to differentiate task statuses and priorities on the Kanban board.

#### 2.2 User Experience
- **Requirement 2.2.1:** Provide immediate feedback to users for all actions taken (e.g., task creation, updates, or deletion) to enhance user interaction.
- **Requirement 2.2.2:** Implement validation and error handling mechanisms to guide users and reduce the risk of incorrect data entry.

### 3. Agile Development and Future Enhancements

The project will follow Agile methodologies, focusing on iterative development, continuous feedback, and adaptability to changing requirements.

#### 3.1 Agile Iterations and Sprints
- **Requirement 3.1.1:** Divide the development process into sprints, each aimed at delivering a subset of the core functionalities.
- **Requirement 3.1.2:** Conduct sprint reviews and testing to ensure alignment with stakeholder requirements and identify areas for improvement.

#### 3.2 Future Enhancements
- **Requirement 3.2.1:** Design the system with scalability and flexibility in mind to accommodate future enhancements.
- **Potential Enhancements:**
  - **Drag-and-Drop Functionality:** Implement a feature to allow users to drag tasks between columns on the Kanban board.
  - **User Authentication:** Develop user accounts and role-based access control to secure the task management system.
  - **Advanced Reporting:** Enable the generation and export of reports based on task data for deeper insights.
  - **External Tool Integration:** Explore integrating with external tools such as Google Sheets, Trello, or email notifications for enhanced functionality.

#### 3.3 Documentation and Delivery
- **Requirement 3.3.1:** Provide comprehensive documentation, including a README file detailing project structure, setup instructions, and user guidance.
- **Requirement 3.3.2:** Record a video demonstration showcasing the project’s functionalities, as per the submission guidelines.
- **Requirement 3.3.3:** Submit the project following the CS50 edX submission process, with an open path for future development based on stakeholder feedback.

## Conclusion

The Kanban Board Task Management System is designed to provide an immediate and effective solution for managing tasks, transitioning from a spreadsheet-based system to a web-based application. By adopting Agile principles, the project emphasizes delivering core functionalities first while maintaining flexibility for future enhancements, ensuring a scalable and user-centric solution.



File: project_timeline.md
----------------------------
# Kanban Board Task Management System - Estimated Timeline

## Project Timeline Overview

This timeline provides an estimated schedule for the development of the Kanban Board Task Management System. Given that this project is a solo effort undertaken as a side project alongside a full-time job, the outlined schedule is provisional and subject to change. The timeline is designed to be flexible and will be adjusted based on sprint reviews and revisions as part of the Agile development process.

### Estimated Timeline:

#### 1. Planning and Setup (2-3 days)
- **Objective:** Establish the project's foundation through thorough planning and environment setup.
  - **Finalize Database Schema:** Design and finalize the SQL database schema based on the structure of the initial data set from the spreadsheet.
  - **Setup Project Environment:** Configure the Flask project environment in Visual Studio Code, including the installation of required dependencies (Flask, SQLAlchemy).
  - **Initial Flask Setup:** Implement a basic Flask application structure with routes and templates to lay the groundwork for future development.

#### 2. Data Migration (2-3 days)
- **Objective:** Transition existing data from a spreadsheet to a structured SQL database.
  - **Data Cleaning:** Ensure the spreadsheet data is clean, consistent, and ready for migration to prevent data integrity issues.
  - **Migration Script:** Develop a Python script to read the Excel file and populate the SQL database using SQLAlchemy.
  - **Test Migration:** Execute the migration process and verify the integrity and accuracy of the transferred records.

#### 3. Core Functionality Development (7-10 days)
- **Objective:** Implement core task management features, including CRUD operations and task filtering.
  - **Task Management:** 
    - Develop features for creating, viewing, updating, and deleting tasks.
    - Perform thorough testing of CRUD operations to ensure data consistency and reliability.
  - **Querying and Filtering:**
    - Build the user interface for filtering tasks based on various criteria such as status, dates, and location.
    - Implement backend logic to handle queries and dynamically filter tasks.
    - Test the filtering functionality under various scenarios to ensure accuracy.

#### 4. Kanban Board Development (5-7 days)
- **Objective:** Create an interactive Kanban board for task visualization and management.
  - **Kanban Board Interface:**
    - Develop the Kanban board interface, incorporating columns for different task statuses.
    - Integrate filtering options with the Kanban board to allow dynamic updates.
  - **UI/UX Refinement:**
    - Enhance the user interface for improved usability and aesthetics, using CSS for styling.
    - Test the Kanban board for responsiveness and usability across different devices.

#### 5. Testing and Refinement (4-6 days)
- **Objective:** Conduct comprehensive testing and refinement of the application.
  - **Bug Fixing:** Identify and resolve any issues or bugs uncovered during testing.
  - **Peer Review:** If possible, gather feedback from a peer or mentor to identify potential areas for improvement.
  - **Final Testing:** Perform end-to-end testing to ensure all features function correctly and the application is stable and reliable.

#### 6. Documentation and Submission (3-4 days)
- **Objective:** Finalize documentation and prepare for project submission.
  - **README and Documentation:** Write detailed documentation, including a comprehensive README file with setup instructions, features, and usage guidelines.
  - **Video Demo:** Record a video demonstration of the project's features and functionality as required.
  - **Final Review and Submission:** Conduct a final review of all project components and submit the project following the CS50 guidelines.

### Total Estimated Time: 23-33 days (3-4 weeks)

### Considerations Affecting the Timeline:
- **Time Allocation:** Progress will vary depending on the time available to dedicate to the project alongside other commitments.
- **Learning Curve:** New concepts in Flask, SQLAlchemy, or Kanban board implementation may require additional time for learning and experimentation.
- **Complexity and Scope Adjustments:** Unforeseen challenges, particularly in data migration or feature implementation, may extend the timeline.
- **Testing and Debugging:** The depth of testing and the number of bugs encountered may impact the overall schedule.

### Notes on the Timeline
This timeline is a provisional estimate designed to guide the development process. Given that this is a solo project being developed as a side project, the schedule is inherently flexible. Adjustments will be made based on the progress observed during each sprint, with a focus on delivering a functional and polished product.

---

This estimated timeline aligns with Agile development principles, providing a structured yet adaptable approach to managing the project schedule.



File: refactoring_roadmap.txt
----------------------------
### Roadmap for Refactoring `app.py` and `helpers.py`

#### Goal
- Incrementally refactor `app.py` to move reusable functions and components to `helpers.py` to improve code organization and maintainability.
- Ensure that no existing functionality is disrupted during the refactoring process.

#### Step 1: **Preliminary Analysis and Preparation**
1. **Backup**: Create a backup of the current `app.py` and `helpers.py` files before starting the refactoring process.
2. **Test Baseline**: Run the current application to establish a baseline for testing. Ensure that all routes and functionalities work as expected.

#### Step 2: **Identify Helper Functions for Extraction**
1. **Extract Database Connection Setup**:
   - Move `create_engine`, `MetaData`, and table definitions (`tasks_table`, `pos_table`, etc.) to `helpers.py`.
   - Update `helpers.py` to include the database setup and reflection.
   - Import these elements back into `app.py` from `helpers.py`.

2. **Extract `get_paginated_tasks`**:
   - Move the `get_paginated_tasks` function to `helpers.py`.
   - Ensure it can handle the base query correctly by passing it as an argument.

3. **Extract Reusable Query Functions**:
   - Identify and extract repetitive database queries, such as fetching POS data and task formatting, into `helpers.py`.
   - For example, create a function like `fetch_pos_data` to handle POS data retrieval and `format_task` to format task data for rendering.

4. **Error Handling**:
   - Leave the `errorhandler` function in `app.py` for now, as it is directly tied to Flask's error handling mechanism.

#### Step 3: **Incremental Refactoring**
1. **Move Database Setup to `helpers.py`**:
   - Move the database setup code, including `engine`, `metadata`, `SessionLocal`, and table reflections (`tasks_table`, `pos_table`, etc.), to `helpers.py`.
   - Ensure `helpers.py` contains only the setup logic without establishing any connections immediately.
   - Import the necessary components into `app.py`.

2. **Test**: After moving the database setup, test the application to ensure it still runs correctly and that all routes function as expected.

3. **Move `get_paginated_tasks` to `helpers.py`**:
   - Move the `get_paginated_tasks` function to `helpers.py`.
   - Modify `app.py` to import and use this function from `helpers.py`.

4. **Test**: Verify that pagination functionality works as expected after moving `get_paginated_tasks`.

5. **Extract and Refactor Repetitive Code**:
   - Identify repetitive code blocks, such as task data formatting and POS data fetching in `app.py`.
   - Create helper functions in `helpers.py` for these tasks (e.g., `fetch_pos_data` and `format_task`).
   - Replace the repetitive code in `app.py` with calls to these helper functions.

6. **Test**: After extracting these helper functions, ensure the application continues to function correctly, particularly routes that involve task and POS data processing.

#### Step 4: **Code Cleanup and Optimization**
1. **Review and Clean Up `app.py`**:
   - Ensure that `app.py` now only contains route definitions and high-level logic.
   - Make sure that all helper functions and database-related logic have been moved to `helpers.py`.

2. **Review and Optimize `helpers.py`**:
   - Check `helpers.py` for any redundant code or possible further simplification.
   - Ensure that `helpers.py` contains all necessary helper functions and that they are well-documented.

#### Step 5: **Final Testing and Validation**
1. **Full Test Suite**:
   - Conduct a full test suite for the application to ensure all functionalities work as expected, including user registration, login, task creation, task modification, filtering, and error handling.
2. **Code Review**:
   - Perform a code review to ensure code quality, readability, and adherence to best practices.
3. **Error Handling**:
   - Ensure that error handling is consistent and effective throughout the application.
4. **Performance Testing**:
   - Test the application for performance issues, especially with database queries and pagination.

#### Step 6: **Deployment Preparation**
1. **Prepare for Deployment**:
   - Ensure that all necessary configurations are set for the production environment (e.g., logging levels, database connections).
2. **Documentation**:
   - Update any documentation to reflect the new code structure, including where helper functions and database setup are located.

#### Step 7: **Deployment and Monitoring**
1. **Deploy**:
   - Deploy the refactored application to the production environment.
2. **Monitor**:
   - Monitor the application post-deployment for any issues or errors.

### Summary
By following this roadmap, we can refactor the `app.py` and `helpers.py` in a careful and incremental manner. Each step involves a clear task followed by testing to ensure that the refactoring does not disrupt any existing functionality.


File: sprint_review_report.md
----------------------------
# Kanban Board Task Management System - Project Development Overview

This project was developed as the final assignment for the CS50 course by Harvard on EdX 2024. It addresses a real-world need for a more robust and scalable task management system by converting a static Excel spreadsheet into a SQL database, which serves as the foundation for a web-based Kanban board application. The development process adhered to Agile methodology, enabling iterative development and continuous feedback. 

## Requirements and Objectives

- **Project Goal:** To create a Kanban board task management system tailored for a grocery and consumer goods retailer with 28 points of sale.
- **Core Functionalities:**
  - Implement a Kanban board for visualizing and managing tasks.
  - Provide user authentication and secure access to the task management system.
  - Enable CRUD operations and advanced filtering options for tasks.
- **Scope:** Develop a web-based solution using Python, Flask, SQLAlchemy, HTML, CSS, and JavaScript.

## Product Backlog

The initial product backlog was created to outline all features and tasks required to meet the project objectives. It was prioritized based on the core functionalities needed for the Kanban board system, including:

1. **User Authentication:** Secure login, registration, and session management.
2. **Task Management:** CRUD operations for task creation, updating, and deletion.
3. **Kanban Board:** Implementation of a dynamic Kanban board with drag-and-drop functionality.
4. **Filtering and Search:** Advanced filtering options for tasks by POS, status, and priority.
5. **Pagination:** Server-side pagination for efficient task display.

## Sprint Breakdown and Development

### Sprint 0: Project Planning & Requirements Gathering (Week 1)
- **Objective:** Define project scope, gather requirements, and establish the initial product backlog.
- **Tasks:**
  - Identified stakeholders and outlined the system requirements.
  - Defined project objectives and created initial user stories (e.g., user authentication, task management).
  - Prioritized user stories and populated the product backlog.
  - Estimated effort and defined a preliminary timeline for each feature.

### Sprint 1: Environment Setup & User Authentication (Week 1-2)
- **Objective:** Set up the development environment and implement basic user authentication.
- **User Stories Addressed:**
  - As a user, I want to securely log in and register to access my tasks.
- **Tasks:**
  - Set up Git repository and integrated with GitHub for version control.
  - Configured Flask project structure and established the development environment.
  - Designed the SQLAlchemy schema for user accounts, including secure password hashing and session management.
  - Developed and tested user registration, login, and logout functionalities.
  - Created front-end templates for user authentication interfaces.

### Sprint 2: Core Task Management Implementation (Week 2-3)
- **Objective:** Develop the foundational task management features.
- **User Stories Addressed:**
  - As a user, I need to create, edit, and delete tasks to manage my workflow.
- **Tasks:**
  - Designed the database schema for tasks, including fields for task attributes (e.g., title, status, priority).
  - Developed Flask routes for task display and management.
  - Implemented a form-based task creation process with validation and input sanitization.
  - Stored task data in the SQL database and rendered tasks using Jinja2 templates on the front-end.

### Sprint 3: Kanban Board Development (Week 3)
- **Objective:** Implement an interactive Kanban board for task visualization and management.
- **User Stories Addressed:**
  - As a user, I want to visualize tasks on a Kanban board and move them between columns.
- **Tasks:**
  - Researched JavaScript libraries and selected one for implementing the drag-and-drop Kanban board.
  - Developed the Kanban board page, integrating it with the task management system.
  - Implemented drag-and-drop functionality to allow tasks to be moved between columns.
  - Integrated AJAX calls to update task status in the database in real-time.
  - Enhanced the user interface for a seamless user experience.

### Sprint 4: Advanced Features & Filtering Implementation (Week 3-4)
- **Objective:** Enhance task management with advanced features such as filtering, search, and pagination.
- **User Stories Addressed:**
  - As a user, I want to filter and search tasks by various criteria (e.g., POS, status).
  - As a user, I need to view tasks in a paginated format for better navigation.
- **Tasks:**
  - Developed advanced filtering mechanisms including text-based search, POS-based filtering, and date range filtering.
  - Implemented server-side pagination using SQLAlchemy’s `LIMIT` and `OFFSET` clauses.
  - Created front-end controls for dynamic pagination, enabling smooth navigation through tasks.
  - Tested and refined filtering and pagination functionalities to ensure consistency and performance.

### Sprint 5: Testing, Debugging, & Refactoring (Week 4)
- **Objective:** Ensure application stability through testing, debugging, and code refactoring.
- **User Stories Addressed:**
  - As a user, I want a reliable system that performs consistently across different use cases.
- **Tasks:**
  - Conducted unit and integration testing for core functionalities, including authentication, task management, and Kanban board interactions.
  - Identified and resolved bugs, focusing on data flow and user interaction issues.
  - Refactored `app.py` to move reusable functions to `helpers.py`, enhancing code maintainability.
  - Improved error handling and consolidated exception logging for better debugging.

### Sprint 6: Deployment & Presentation Preparation (Week 4)
- **Objective:** Deploy the application to a production environment and prepare for the final presentation.
- **Tasks:**
  - Set up a production environment using Gunicorn.
  - Migrated the database schema and data to the production server.
  - Conducted a final round of testing on the live environment to ensure functionality.
  - Prepared the final presentation to demonstrate the application, highlighting key features and user stories.

## Agile Development Practices and Methodology

Throughout the project, Agile principles and practices were employed to ensure efficient progress and adaptability:
- **Incremental Delivery:** Each sprint delivered a functional increment, providing a shippable product increment by the end of each sprint.
- **Continuous Feedback and Iteration:** Regular reviews and testing were conducted at the end of each sprint, allowing for continuous feedback and iteration.
- **Backlog Refinement:** The product backlog was continually refined based on the outcomes of each sprint and stakeholder feedback.
- **Test-Driven Development (TDD):** Emphasized writing tests for key functionalities before implementation to ensure code reliability and quality.
- **Modular Architecture:** The codebase was structured into reusable components to facilitate scalability and ease of maintenance.

## Conclusion

This project utilized Agile methodology to develop a robust, scalable, and user-friendly Kanban board task management system. The iterative process allowed for continuous improvement and adaptation, ensuring the final product met the requirements and provided a solid foundation for future enhancements.



File: user_stories.md
----------------------------
# User Stories

This document outlines the user stories that have been defined and implemented for the task management application. Each user story follows the standard format "As a [user role], I want [goal] so that [reason]."

## User Stories

### 1. User Registration and Authentication
- **As a new user, I want to register an account so that I can securely access the task management system.**
  - **Acceptance Criteria:**
    - User can provide a username and password to create a new account.
    - System validates the uniqueness of the username.
    - Password is securely hashed and stored.
    - Registration form provides feedback for successful or failed registration.
- **As a returning user, I want to log in with my credentials so that I can access my tasks.**
  - **Acceptance Criteria:**
    - User can log in using the registered username and password.
    - System authenticates the user and starts a session upon successful login.
    - User is redirected to the main tasks page after logging in.

### 2. Task Creation
- **As a user, I want to create a new task so that I can track my work and deadlines.**
  - **Acceptance Criteria:**
    - User can access a form to input task details such as description, status, priority, start date, and due date.
    - System validates required fields and provides feedback for missing or incorrect inputs.
    - Task is saved in the database and displayed in the task list and Kanban board upon creation.

### 3. Task Modification
- **As a user, I want to modify an existing task so that I can update its details or correct mistakes.**
  - **Acceptance Criteria:**
    - User can select a task and access a form to modify its details.
    - System allows updating fields like description, status, priority, and dates.
    - Changes are saved to the database and reflected in the task list and Kanban board.
    - Partial updates are supported, allowing the user to modify only specific fields.

### 4. Task Visualization with Kanban Board
- **As a user, I want to visualize my tasks on a Kanban board so that I can easily track their progress.**
  - **Acceptance Criteria:**
    - User can see tasks organized into columns: Backlog, To Do, In Progress, and Done.
    - Tasks are represented as cards that show key information like description, status, and due date.
    - User can drag and drop task cards between columns to update their status.
    - Status updates are automatically saved to the database.

### 5. Task Filtering and Search
- **As a user, I want to filter tasks by criteria such as status, priority, and dates so that I can focus on specific tasks.**
  - **Acceptance Criteria:**
    - User can apply filters for POS, status, priority, and date range using a sidebar.
    - Only tasks matching the selected criteria are displayed in the task list and Kanban board.
    - System provides a search bar to find tasks by keywords.

### 6. Task Pagination
- **As a user, I want to navigate through a large number of tasks easily so that I can find tasks without scrolling excessively.**
  - **Acceptance Criteria:**
    - Task list supports pagination to break up large numbers of tasks into manageable pages.
    - User can navigate between pages using pagination controls.
    - System displays the total number of pages and current page.

### 7. Due Today Filter
- **As a user, I want to quickly see tasks that are due today so that I can prioritize my immediate work.**
  - **Acceptance Criteria:**
    - User can click a "Due Today" button on the Kanban board.
    - System filters and displays only tasks with a due date set for today.
    - Filter can be cleared to show all tasks again.

### 8. Adding Notes to Tasks
- **As a user, I want to add notes to my tasks so that I can include additional information or reminders.**
  - **Acceptance Criteria:**
    - User can add notes when creating or modifying a task.
    - Notes are saved to the database and displayed in the task details.
    - Notes field is optional and can be left empty if not needed.

### 9. Error Handling and User Feedback
- **As a user, I want to receive feedback when an error occurs so that I can understand what went wrong.**
  - **Acceptance Criteria:**
    - System provides error messages for invalid inputs or failed operations.
    - Errors are logged in the system for debugging purposes.
    - User receives clear instructions or prompts to correct the issue.

### 10. Responsive Design
- **As a user, I want the application to be accessible and functional on various devices so that I can use it on the go.**
  - **Acceptance Criteria:**
    - User interface adapts to different screen sizes using responsive design principles.
    - Kanban board and task list are fully functional on mobile, tablet, and desktop devices.
    - Forms and controls are user-friendly and accessible on all device types.

## Future User Stories

### 11. Task Assignment
- **As an admin, I want to assign tasks to specific users so that I can delegate work and track responsibilities.**
  - **Acceptance Criteria:**
    - Admin can assign tasks to different users through a dropdown selection.
    - Assigned user information is displayed on the task card.
    - System allows filtering tasks by assigned user.

### 12. Notifications
- **As a user, I want to receive notifications for important task updates and deadlines so that I can stay informed.**
  - **Acceptance Criteria:**
    - System sends notifications for task status changes, approaching deadlines, or new assignments.
    - Notifications are displayed in-app or sent via email based on user preferences.
    - User can configure notification settings in their profile.

---

This document captures the primary user stories for the application, outlining the functionality from a user's perspective. These user stories are aimed at guiding the development process and ensuring the application meets user needs effectively.



--- Directory: ./helpers ---

File: all_code_structure.txt
----------------------------

--- Directory: ./.git ---

--- Directory: ./.git/branches ---

--- Directory: ./.git/hooks ---

--- Directory: ./.git/info ---

--- Directory: ./.git/logs ---

--- Directory: ./.git/logs/refs ---

--- Directory: ./.git/logs/refs/heads ---

--- Directory: ./.git/logs/refs/heads/feature ---

--- Directory: ./.git/logs/refs/heads/init ---

--- Directory: ./.git/logs/refs/remotes ---

--- Directory: ./.git/logs/refs/remotes/origin ---

--- Directory: ./.git/logs/refs/remotes/origin/feature ---

--- Directory: ./.git/logs/refs/remotes/origin/init ---

--- Directory: ./.git/objects ---

--- Directory: ./.git/objects/00 ---

--- Directory: ./.git/objects/01 ---

--- Directory: ./.git/objects/02 ---

--- Directory: ./.git/objects/03 ---

--- Directory: ./.git/objects/04 ---

--- Directory: ./.git/objects/05 ---

--- Directory: ./.git/objects/06 ---

--- Directory: ./.git/objects/07 ---

--- Directory: ./.git/objects/08 ---

--- Directory: ./.git/objects/09 ---

--- Directory: ./.git/objects/0a ---

--- Directory: ./.git/objects/0b ---

--- Directory: ./.git/objects/0c ---

--- Directory: ./.git/objects/0d ---

--- Directory: ./.git/objects/0e ---

--- Directory: ./.git/objects/0f ---

--- Directory: ./.git/objects/10 ---

--- Directory: ./.git/objects/11 ---

--- Directory: ./.git/objects/12 ---

--- Directory: ./.git/objects/13 ---

--- Directory: ./.git/objects/14 ---

--- Directory: ./.git/objects/15 ---

--- Directory: ./.git/objects/16 ---

--- Directory: ./.git/objects/17 ---

--- Directory: ./.git/objects/18 ---

--- Directory: ./.git/objects/1a ---

--- Directory: ./.git/objects/1b ---

--- Directory: ./.git/objects/1c ---

--- Directory: ./.git/objects/1d ---

--- Directory: ./.git/objects/1e ---

--- Directory: ./.git/objects/1f ---

--- Directory: ./.git/objects/20 ---

--- Directory: ./.git/objects/21 ---

--- Directory: ./.git/objects/22 ---

--- Directory: ./.git/objects/23 ---

--- Directory: ./.git/objects/24 ---

--- Directory: ./.git/objects/25 ---

--- Directory: ./.git/objects/26 ---

--- Directory: ./.git/objects/27 ---

--- Directory: ./.git/objects/28 ---

--- Directory: ./.git/objects/29 ---

--- Directory: ./.git/objects/2a ---

--- Directory: ./.git/objects/2b ---

--- Directory: ./.git/objects/2c ---

--- Directory: ./.git/objects/2d ---

--- Directory: ./.git/objects/2e ---

--- Directory: ./.git/objects/2f ---

--- Directory: ./.git/objects/30 ---

--- Directory: ./.git/objects/31 ---

--- Directory: ./.git/objects/32 ---

--- Directory: ./.git/objects/33 ---

--- Directory: ./.git/objects/34 ---

--- Directory: ./.git/objects/35 ---

--- Directory: ./.git/objects/36 ---

--- Directory: ./.git/objects/37 ---

--- Directory: ./.git/objects/38 ---

--- Directory: ./.git/objects/39 ---

--- Directory: ./.git/objects/3a ---

--- Directory: ./.git/objects/3b ---

--- Directory: ./.git/objects/3c ---

--- Directory: ./.git/objects/3d ---

--- Directory: ./.git/objects/3e ---

--- Directory: ./.git/objects/3f ---

--- Directory: ./.git/objects/40 ---

--- Directory: ./.git/objects/41 ---

--- Directory: ./.git/objects/42 ---

--- Directory: ./.git/objects/43 ---

--- Directory: ./.git/objects/44 ---

--- Directory: ./.git/objects/45 ---

--- Directory: ./.git/objects/46 ---

--- Directory: ./.git/objects/47 ---

--- Directory: ./.git/objects/48 ---

--- Directory: ./.git/objects/49 ---

--- Directory: ./.git/objects/4a ---

--- Directory: ./.git/objects/4b ---

--- Directory: ./.git/objects/4c ---

--- Directory: ./.git/objects/4d ---

--- Directory: ./.git/objects/4e ---

--- Directory: ./.git/objects/4f ---

--- Directory: ./.git/objects/50 ---

--- Directory: ./.git/objects/51 ---

--- Directory: ./.git/objects/52 ---

--- Directory: ./.git/objects/53 ---

--- Directory: ./.git/objects/54 ---

--- Directory: ./.git/objects/55 ---

--- Directory: ./.git/objects/56 ---

--- Directory: ./.git/objects/57 ---

--- Directory: ./.git/objects/58 ---

--- Directory: ./.git/objects/59 ---

--- Directory: ./.git/objects/5a ---

--- Directory: ./.git/objects/5b ---

--- Directory: ./.git/objects/5c ---

--- Directory: ./.git/objects/5e ---

--- Directory: ./.git/objects/5f ---

--- Directory: ./.git/objects/60 ---

--- Directory: ./.git/objects/61 ---

--- Directory: ./.git/objects/62 ---

--- Directory: ./.git/objects/63 ---

--- Directory: ./.git/objects/64 ---

--- Directory: ./.git/objects/65 ---

--- Directory: ./.git/objects/66 ---

--- Directory: ./.git/objects/67 ---

--- Directory: ./.git/objects/69 ---

--- Directory: ./.git/objects/6a ---

--- Directory: ./.git/objects/6b ---

--- Directory: ./.git/objects/6c ---

--- Directory: ./.git/objects/6d ---

--- Directory: ./.git/objects/6e ---

--- Directory: ./.git/objects/6f ---

--- Directory: ./.git/objects/70 ---

--- Directory: ./.git/objects/71 ---

--- Directory: ./.git/objects/72 ---

--- Directory: ./.git/objects/74 ---

--- Directory: ./.git/objects/75 ---

--- Directory: ./.git/objects/76 ---

--- Directory: ./.git/objects/77 ---

--- Directory: ./.git/objects/78 ---

--- Directory: ./.git/objects/79 ---

--- Directory: ./.git/objects/7a ---

--- Directory: ./.git/objects/7b ---

--- Directory: ./.git/objects/7c ---

--- Directory: ./.git/objects/7d ---

--- Directory: ./.git/objects/7e ---

--- Directory: ./.git/objects/7f ---

--- Directory: ./.git/objects/80 ---

--- Directory: ./.git/objects/81 ---

--- Directory: ./.git/objects/82 ---

--- Directory: ./.git/objects/83 ---

--- Directory: ./.git/objects/84 ---

--- Directory: ./.git/objects/85 ---

--- Directory: ./.git/objects/86 ---

--- Directory: ./.git/objects/87 ---

--- Directory: ./.git/objects/88 ---

--- Directory: ./.git/objects/89 ---

--- Directory: ./.git/objects/8a ---

--- Directory: ./.git/objects/8b ---

--- Directory: ./.git/objects/8c ---

--- Directory: ./.git/objects/8d ---

--- Directory: ./.git/objects/8e ---

--- Directory: ./.git/objects/8f ---

--- Directory: ./.git/objects/90 ---

--- Directory: ./.git/objects/91 ---

--- Directory: ./.git/objects/92 ---

--- Directory: ./.git/objects/95 ---

--- Directory: ./.git/objects/97 ---

--- Directory: ./.git/objects/98 ---

--- Directory: ./.git/objects/99 ---

--- Directory: ./.git/objects/9a ---

--- Directory: ./.git/objects/9b ---

--- Directory: ./.git/objects/9c ---

--- Directory: ./.git/objects/9d ---

--- Directory: ./.git/objects/9e ---

--- Directory: ./.git/objects/9f ---

--- Directory: ./.git/objects/a0 ---

--- Directory: ./.git/objects/a1 ---

--- Directory: ./.git/objects/a2 ---

--- Directory: ./.git/objects/a3 ---

--- Directory: ./.git/objects/a4 ---

--- Directory: ./.git/objects/a5 ---

--- Directory: ./.git/objects/a6 ---

--- Directory: ./.git/objects/a7 ---

--- Directory: ./.git/objects/a8 ---

--- Directory: ./.git/objects/a9 ---

--- Directory: ./.git/objects/aa ---

--- Directory: ./.git/objects/ab ---

--- Directory: ./.git/objects/ac ---

--- Directory: ./.git/objects/ad ---

--- Directory: ./.git/objects/ae ---

--- Directory: ./.git/objects/af ---

--- Directory: ./.git/objects/b2 ---

--- Directory: ./.git/objects/b3 ---

--- Directory: ./.git/objects/b4 ---

--- Directory: ./.git/objects/b5 ---

--- Directory: ./.git/objects/b6 ---

--- Directory: ./.git/objects/b7 ---

--- Directory: ./.git/objects/b8 ---

--- Directory: ./.git/objects/b9 ---

--- Directory: ./.git/objects/ba ---

--- Directory: ./.git/objects/bb ---

--- Directory: ./.git/objects/bc ---

--- Directory: ./.git/objects/bd ---

--- Directory: ./.git/objects/bf ---

--- Directory: ./.git/objects/c0 ---

--- Directory: ./.git/objects/c1 ---

--- Directory: ./.git/objects/c2 ---

--- Directory: ./.git/objects/c3 ---

--- Directory: ./.git/objects/c4 ---

--- Directory: ./.git/objects/c5 ---

--- Directory: ./.git/objects/c6 ---

--- Directory: ./.git/objects/c7 ---

--- Directory: ./.git/objects/c8 ---

--- Directory: ./.git/objects/c9 ---

--- Directory: ./.git/objects/ca ---

--- Directory: ./.git/objects/cb ---

--- Directory: ./.git/objects/cc ---

--- Directory: ./.git/objects/cd ---

--- Directory: ./.git/objects/ce ---

--- Directory: ./.git/objects/cf ---

--- Directory: ./.git/objects/d0 ---

--- Directory: ./.git/objects/d1 ---

--- Directory: ./.git/objects/d2 ---

--- Directory: ./.git/objects/d3 ---

--- Directory: ./.git/objects/d4 ---

--- Directory: ./.git/objects/d5 ---

--- Directory: ./.git/objects/d7 ---

--- Directory: ./.git/objects/d8 ---

--- Directory: ./.git/objects/d9 ---

--- Directory: ./.git/objects/da ---

--- Directory: ./.git/objects/db ---

--- Directory: ./.git/objects/dc ---

--- Directory: ./.git/objects/de ---

--- Directory: ./.git/objects/df ---

--- Directory: ./.git/objects/e0 ---

--- Directory: ./.git/objects/e1 ---

--- Directory: ./.git/objects/e2 ---

--- Directory: ./.git/objects/e3 ---

--- Directory: ./.git/objects/e4 ---

--- Directory: ./.git/objects/e5 ---

--- Directory: ./.git/objects/e6 ---

--- Directory: ./.git/objects/e7 ---

--- Directory: ./.git/objects/e8 ---

--- Directory: ./.git/objects/e9 ---

--- Directory: ./.git/objects/ea ---

--- Directory: ./.git/objects/eb ---

--- Directory: ./.git/objects/ed ---

--- Directory: ./.git/objects/ee ---

--- Directory: ./.git/objects/ef ---

--- Directory: ./.git/objects/f0 ---

--- Directory: ./.git/objects/f1 ---

--- Directory: ./.git/objects/f3 ---

--- Directory: ./.git/objects/f4 ---

--- Directory: ./.git/objects/f5 ---

--- Directory: ./.git/objects/f6 ---

--- Directory: ./.git/objects/f7 ---

--- Directory: ./.git/objects/f8 ---

--- Directory: ./.git/objects/fa ---

--- Directory: ./.git/objects/fb ---

--- Directory: ./.git/objects/fc ---

--- Directory: ./.git/objects/fd ---

--- Directory: ./.git/objects/ff ---

--- Directory: ./.git/objects/info ---

--- Directory: ./.git/objects/pack ---

--- Directory: ./.git/refs ---

--- Directory: ./.git/refs/heads ---

--- Directory: ./.git/refs/heads/feature ---

--- Directory: ./.git/refs/heads/init ---

--- Directory: ./.git/refs/remotes ---

--- Directory: ./.git/refs/remotes/origin ---

--- Directory: ./.git/refs/remotes/origin/feature ---

--- Directory: ./.git/refs/remotes/origin/init ---

--- Directory: ./.git/refs/tags ---

--- Directory: ./core ---

File: app.py
----------------------------
"""
File: app.py
Developer: Stefania Galatolo
Assisted by: ChatGPT 4.0 (because coding alone is overrated!)

Description:
This is the main application file for the Task Management Tool, developed as the final project for CS50 by Harvard on EdX 2024. 
The app manages tasks in a grocery store's accounts payable system, leveraging Python, Flask, and SQLAlchemy to provide an intuitive 
user interface with features like task creation, modification, and a Kanban board for visual task management.

ChatGPT's role: 
Stefania could have totally written this herself, but why reinvent the wheel when you have a super-intelligent assistant? 
So, I came in to help with some of the heavy lifting, commenting, and making sure everything is as clear as day. 
No code lines were left behind!

This file includes:
- App configuration and setup
- User authentication (registration, login, logout)
- Task management routes (create, modify, filter)
- Kanban board rendering and task updates
- Error handling and logging
- API endpoints for task and POS data retrieval

Correlations:
- Utilizes helper functions and constants from helpers.py for modularity and reusability.
- Interacts with the database via SQLAlchemy Core.
- Integrates with templates in the 'templates' directory for UI rendering.
- Implements RESTful API principles for client-server interactions.
"""

from flask import Flask, flash, redirect, render_template, request, session, jsonify
from flask_session import Session
from sqlalchemy import select, and_, or_, desc, func
from werkzeug.security import check_password_hash, generate_password_hash
from werkzeug.exceptions import default_exceptions
from helpers import (
    apology, 
    login_required, 
    get_paginated_tasks, 
    fetch_pos_data, 
    format_task, 
    engine, 
    tasks_table, 
    pos_table, 
    rec_table, 
    blockers_table, 
    users_table
)
from datetime import date, datetime
import logging
import traceback

# Configure application
app = Flask(__name__)

# Ensure templates are auto-reloaded
app.config["TEMPLATES_AUTO_RELOAD"] = True

# Configure session to use filesystem (instead of signed cookies)
app.config["SESSION_PERMANENT"] = False
app.config["SESSION_TYPE"] = "filesystem"
Session(app)

# Create a logger object
logger = logging.getLogger(__name__)

# Disable default Flask logging to console
log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR)

# Set a constant for the number of records per page
RECORDS_PER_PAGE = 15

@app.route("/")
@login_required
def index():
    """
    Redirect to the kanban page as the homepage.

    This route serves as the default landing page after login. 
    It redirects users to the Kanban board, which provides an overview of all tasks.

    Returns:
        - redirect to the '/kanban' route.
    """
    return redirect("/kanban")

@app.route("/register", methods=["GET", "POST"])
def register():
    """
    Register a new user by collecting username and password inputs.
    Handles form validation, password hashing, and user registration in the database.

    Methods:
        GET: Renders the registration form.
        POST: Processes the registration data, validates it, and inserts a new user into the database.

    Returns:
        - On GET: Render the registration page.
        - On POST success: Redirect to the login page.
        - On POST failure: Render an apology or show an error message.
    """
    if request.method == "POST":
        # Validate form inputs
        if not request.form.get("username"):
            return apology("must provide username", 400)
        elif not request.form.get("password"):
            return apology("must provide password", 400)
        elif request.form.get("password") != request.form.get("confirmation"):
            return apology("passwords do not match", 400)

        # Hash the user's password
        hash_pw = generate_password_hash(request.form.get("password"))

        # Insert new user into the database
        try:
            with engine.connect() as conn:
                conn.execute(users_table.insert().values(username=request.form.get("username"), password_hash=hash_pw))
                conn.commit()
            flash("Registration successful! Please log in.")
        except Exception as e:
            logger.error(f"Error during registration: {e}")
            return apology("username already exists", 400)

        return redirect("/login")
    else:
        return render_template("register.html")

@app.route("/login", methods=["GET", "POST"])
def login():
    """
    Log the user in by checking username and password.
    Clears any existing user session and sets a new session on successful login.

    Methods:
        GET: Renders the login form.
        POST: Authenticates the user against the database and starts a new session.

    Returns:
        - On GET: Render the login page.
        - On POST success: Redirect to the kanban page.
        - On POST failure: Show an error message and prompt the user to try again.
    """
    # Clear any existing user session
    session.clear()

    if request.method == "POST":
        # Ensure username and password are provided
        if not request.form.get("username"):
            flash("Must provide username")
            return redirect("/login")
        if not request.form.get("password"):
            flash("Must provide password")
            return redirect("/login")

        # Query database for username
        with engine.connect() as conn:
            query = select(users_table.c.user_id, users_table.c.username, users_table.c.password_hash).where(users_table.c.username == request.form.get("username"))
            rows = conn.execute(query).fetchall()

        # Validate username and password
        if len(rows) != 1:
            flash("Username does not exist. Please register.")
            return redirect("/register")
        elif not check_password_hash(rows[0][2], request.form.get("password")):
            flash("Incorrect password. Please try again.")
            return redirect("/login")

        # Remember which user has logged in
        session["user_id"] = rows[0][0]
        flash("Logged in successfully!")
        return redirect("/kanban")
    else:
        return render_template("login.html")

@app.route("/logout")
def logout():
    """
    Log the user out by clearing the session data.

    Returns:
        - Redirect to the login page after clearing the session.
    """
    session.clear()
    flash("You have been logged out.")
    return redirect("/login")

@app.route("/tasks")
@login_required
def tasks():
    """
    Display all tasks with pagination.

    This route fetches tasks from the database and renders them on the 'tasks.html' page.
    Utilizes helper functions to format tasks and fetch POS data.

    Query Parameters:
        page (int): Page number for pagination. Defaults to 1.

    Returns:
        - Render the 'tasks.html' template with task data, POS data, and pagination info.
    """
    page = request.args.get('page', 1, type=int)

    base_query = select(
        tasks_table.c.task_id,
        tasks_table.c.task_desc,
        tasks_table.c.task_status,
        tasks_table.c.task_priority,
        tasks_table.c.task_start_date,
        tasks_table.c.task_due_date,
        tasks_table.c.task_notes,
        pos_table.c.pos_id,
        pos_table.c.pos_name,
        rec_table.c.rec_date,
        rec_table.c.rec_certified,
        blockers_table.c.blocker_desc,
        blockers_table.c.blocker_responsible
    ).select_from(
        tasks_table
        .join(pos_table, tasks_table.c.pos_id == pos_table.c.pos_id)
        .outerjoin(rec_table, tasks_table.c.rec_id == rec_table.c.rec_id)
        .outerjoin(blockers_table, tasks_table.c.blocker_id == blockers_table.c.blocker_id)
    ).order_by(desc(tasks_table.c.task_id))

    try:
        # Fetch paginated tasks
        tasks, total_records, total_pages = get_paginated_tasks(base_query, page, RECORDS_PER_PAGE)

        if not tasks:
            logger.warning("No tasks returned from the database.")

        # Format tasks for rendering
        formatted_tasks = [format_task(task) for task in tasks]

        # Fetch POS data for the dropdowns
        pos_data = fetch_pos_data()

        logger.debug(f"Formatted tasks for rendering: {formatted_tasks}")
        return render_template("tasks.html", tasks=formatted_tasks, pos_data=pos_data, page=page, total_pages=total_pages, date=date)

    except Exception as e:
        logger.error(f"Error displaying tasks: {traceback.format_exc()}")
        flash("An error occurred while loading tasks.")
        return redirect("/")

@app.route("/filter_tasks", methods=["POST"])
@login_required
def filter_tasks():
    """
    Filter tasks based on given criteria with pagination.

    This route processes filtering options submitted via a JSON request. It constructs a SQLAlchemy 
    query with dynamic filters and returns a paginated list of tasks matching the criteria.

    Request JSON:
        - search_query (str): Text to search in task descriptions, notes, or POS names.
        - pos_id (int): POS ID to filter by.
        - pos_name (str): POS Name to filter by.
        - start_date (str): Start date to filter tasks from.
        - end_date (str): End date to filter tasks until.
        - statuses (list): List of task statuses to filter by.
        - priorities (list): List of task priorities to filter by.
        - page (int): Page number for pagination.

    Returns:
        - JSON response with tasks, current page, and total pages.
    """
    data = request.get_json()
    page = data.get('page', 1)

    if data is None:
        logger.error("No data received in request")
        return jsonify({"error": "No data received"}), 400

    search_query = data.get("search_query", "").strip()
    pos_id = data.get("pos_id")
    pos_name = data.get("pos_name", "").strip()
    start_date = data.get("start_date")
    end_date = data.get("end_date")
    statuses = data.get("statuses", [])
    priorities = data.get("priorities", [])

    logger.debug(f"Received data from client: {data}")

    base_query = select(
        tasks_table.c.task_id,
        tasks_table.c.task_desc,
        tasks_table.c.task_status,
        tasks_table.c.task_priority,
        tasks_table.c.task_start_date,
        tasks_table.c.task_due_date,
        tasks_table.c.task_notes,
        pos_table.c.pos_id,
        pos_table.c.pos_name,
        rec_table.c.rec_date,
        rec_table.c.rec_certified,
        blockers_table.c.blocker_desc,
        blockers_table.c.blocker_responsible
    ).select_from(
        tasks_table.join(pos_table, tasks_table.c.pos_id == pos_table.c.pos_id)
        .outerjoin(rec_table, tasks_table.c.rec_id == rec_table.c.rec_id)
        .outerjoin(blockers_table, tasks_table.c.blocker_id == blockers_table.c.blocker_id)
    )

    conditions = []

    # Apply search query filter
    if search_query:
        conditions.append(or_(
            func.lower(tasks_table.c.task_desc).like(f"%{search_query.lower()}%"),
            func.lower(tasks_table.c.task_notes).like(f"%{search_query.lower()}%"),
            func.lower(pos_table.c.pos_name).like(f"%{search_query.lower()}%")
        ))

    # Apply filters if provided
    if pos_id:
        conditions.append(pos_table.c.pos_id == pos_id)
    if pos_name:
        conditions.append(pos_table.c.pos_name.ilike(f"%{pos_name}%"))
    if statuses:
        conditions.append(tasks_table.c.task_status.in_(statuses))
    if priorities:
        conditions.append(tasks_table.c.task_priority.in_(priorities))
    if start_date:
        try:
            start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
            conditions.append(tasks_table.c.task_start_date >= start_date)
        except ValueError:
            logger.error(f"Invalid start date format: {start_date}")
    if end_date:
        try:
            end_date = datetime.strptime(end_date, '%Y-%m-%d').date()
            conditions.append(tasks_table.c.task_due_date <= end_date)
        except ValueError:
            logger.error(f"Invalid end date format: {end_date}")

    # Combine conditions if any
    if conditions:
        base_query = base_query.where(and_(*conditions))

    base_query = base_query.order_by(desc(tasks_table.c.task_id))

    logger.debug(f"Executing query with conditions: {str(base_query)}")

    try:
        # Fetch paginated tasks
        tasks, total_records, total_pages = get_paginated_tasks(base_query, page, RECORDS_PER_PAGE)
        logger.debug(f"Fetched tasks: {tasks}")
    except Exception as e:
        logger.error(f"Error fetching filtered tasks: {traceback.format_exc()}")
        return jsonify({"error": "An error occurred while fetching tasks."}), 500

    # Format the tasks to send back to the client
    tasks_list = [format_task(task) for task in tasks]

    logger.debug(f"Returning tasks list to client: {tasks_list}")
    return jsonify(tasks=tasks_list, page=page, total_pages=total_pages)

@app.route("/create", methods=["GET", "POST"])
@login_required
def create_task():
    """
    Handle the creation of a new task or display the create task page with existing tasks.

    Methods:
        GET: Fetches existing tasks and POS data to display on the task creation page.
        POST: Validates and inserts a new task into the database. Optionally inserts related 
              blocker and reconciliation data.

    Returns:
        - On GET: Render the 'create.html' template with tasks and POS data.
        - On POST success: Redirect to the tasks page.
        - On POST failure: Show an error message and prompt the user to try again.
    """
    if request.method == "POST":
        # Get form data
        pos_id = request.form.get("pos_id")

        # Optional fields
        reconciliation_date = request.form.get("reconciliation_date") or None
        certified = request.form.get("certified") or None
        description = request.form.get("description") or None
        status = request.form.get("status") or None
        priority = request.form.get("priority") or None
        start_date = request.form.get("start_date") or None
        due_date = request.form.get("due_date") or None
        notes = request.form.get("notes") or None
        blocker_desc = request.form.get("blocker_desc") or None
        blocker_responsible = request.form.get("blocker_responsible") or None

        # Convert date strings to Python date objects if present
        try:
            if start_date:
                start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
            if due_date:
                due_date = datetime.strptime(due_date, '%Y-%m-%d').date()
            if reconciliation_date:
                reconciliation_date = datetime.strptime(reconciliation_date, '%Y-%m-%d').date()
        except ValueError as e:
            flash("Invalid date format. Please use YYYY-MM-DD.")
            return redirect("/create")

        # Validate required fields
        if not pos_id:
            flash("POS ID is required.")
            return redirect("/create")

        try:
            with engine.connect() as conn:
                # Insert the new task into the tasks table
                task_insert = tasks_table.insert().values(
                    pos_id=pos_id,
                    task_desc=description,
                    task_status=status,
                    task_priority=priority,
                    task_start_date=start_date,
                    task_due_date=due_date,
                    task_notes=notes
                )
                result = conn.execute(task_insert)
                task_id = result.inserted_primary_key[0]  # Get the inserted task ID

                # Insert the related blocker information if provided
                blocker_id = None
                if blocker_desc or blocker_responsible:
                    blocker_insert = blockers_table.insert().values(
                        blocker_desc=blocker_desc,
                        blocker_responsible=blocker_responsible,
                        task_id=task_id,  # Link with the new task
                        pos_id=pos_id
                    )
                    blocker_result = conn.execute(blocker_insert)
                    blocker_id = blocker_result.inserted_primary_key[0]  # Get the inserted blocker ID

                # Insert reconciliation information into rec_table if needed
                rec_id = None
                if reconciliation_date or certified is not None:
                    rec_insert = rec_table.insert().values(
                        rec_date=reconciliation_date,
                        rec_certified=(certified == 'true') if certified else None,
                        task_id=task_id,  # Link with the new task
                        pos_id=pos_id,
                        blocker_id=blocker_id  # Link with the new blocker if created
                    )
                    rec_result = conn.execute(rec_insert)
                    rec_id = rec_result.inserted_primary_key[0]  # Get the inserted rec ID

                # Update the task record with blocker_id and rec_id if they were created
                conn.execute(
                    tasks_table.update()
                    .where(tasks_table.c.task_id == task_id)
                    .values(blocker_id=blocker_id, rec_id=rec_id)
                )

                conn.commit()
            flash("Task created successfully!")
        except Exception as e:
            logger.error(f"Error creating task: {traceback.format_exc()}")
            flash("An error occurred while creating the task.")
            return redirect("/create")

        return redirect("/tasks")
    else:
        # Fetch POS data for the form dropdown
        pos_data = fetch_pos_data()

        # Fetch tasks similarly to the `/tasks` route to display them on the create page
        query = select(
            tasks_table.c.task_id,
            tasks_table.c.task_desc,
            tasks_table.c.task_status,
            tasks_table.c.task_priority,
            tasks_table.c.task_start_date,
            tasks_table.c.task_due_date,
            tasks_table.c.task_notes,
            pos_table.c.pos_id,
            pos_table.c.pos_name,
            rec_table.c.rec_date,
            rec_table.c.rec_certified,
            blockers_table.c.blocker_desc,
            blockers_table.c.blocker_responsible
        ).select_from(
            tasks_table
            .join(pos_table, tasks_table.c.pos_id == pos_table.c.pos_id)
            .outerjoin(rec_table, tasks_table.c.rec_id == rec_table.c.rec_id)
            .outerjoin(blockers_table, tasks_table.c.blocker_id == blockers_table.c.blocker_id)
        ).order_by(desc(tasks_table.c.task_id))

        tasks = engine.connect().execute(query).fetchall()

        # Format tasks for rendering in template
        formatted_tasks = [format_task(task) for task in tasks]

        # Render the create.html with tasks and POS data
        return render_template("create.html", pos_data=pos_data, tasks=formatted_tasks, date=date)

@app.route("/api/get_task/<int:task_id>", methods=["GET"])
@login_required
def get_task(task_id):
    """
    Fetch the task details for a given task_id and return them as JSON.

    Args:
        task_id (int): The ID of the task to fetch.

    Returns:
        - JSON response with task details if found.
        - JSON error response if task not found or an error occurs.
    """
    try:
        with engine.connect() as conn:
            query = select(
                tasks_table.c.task_id,
                tasks_table.c.task_desc,
                tasks_table.c.task_status,
                tasks_table.c.task_priority,
                tasks_table.c.task_start_date,
                tasks_table.c.task_due_date,
                tasks_table.c.task_notes,
                pos_table.c.pos_id,
                pos_table.c.pos_name,
                rec_table.c.rec_date,
                rec_table.c.rec_certified,
                blockers_table.c.blocker_desc,
                blockers_table.c.blocker_responsible
            ).select_from(
                tasks_table
                .join(pos_table, tasks_table.c.pos_id == pos_table.c.pos_id)
                .outerjoin(rec_table, tasks_table.c.rec_id == rec_table.c.rec_id)
                .outerjoin(blockers_table, tasks_table.c.blocker_id == blockers_table.c.blocker_id)
            ).where(tasks_table.c.task_id == task_id)

            task = conn.execute(query).fetchone()

            if task:
                # Format the task details for JSON response
                task_data = format_task(task)
                return jsonify({"success": True, "task": task_data})
            else:
                return jsonify({"success": False, "message": "Task not found."})

    except Exception as e:
        logger.error(f"Error fetching task: {traceback.format_exc()}")
        return jsonify({"success": False, "message": "An error occurred while fetching the task."}), 500

@app.route("/modify", methods=["GET", "POST"])
@login_required
def modify_task():
    """
    Handle the modification of an existing task or display the modify task page with existing tasks.

    Methods:
        GET: Fetches existing tasks and POS data to display on the modification page.
        POST: Updates the task information in the database. Optionally updates related 
              blocker and reconciliation data.

    Returns:
        - On GET: Render the 'modify.html' template with tasks and POS data.
        - On POST success: Redirect to the modify page.
        - On POST failure: Show an error message and prompt the user to try again.
    """
    if request.method == "POST":
        # Get form data
        task_id = request.form.get("task_id")
        pos_id = request.form.get("pos_id")

        # Optional fields
        reconciliation_date = request.form.get("reconciliation_date") or None
        certified = request.form.get("certified") or None
        description = request.form.get("description") or None
        status = request.form.get("status") or None
        priority = request.form.get("priority") or None
        start_date = request.form.get("start_date") or None
        due_date = request.form.get("due_date") or None
        notes = request.form.get("notes") or None
        blocker_desc = request.form.get("blocker_desc") or None
        blocker_responsible = request.form.get("blocker_responsible") or None

        # Convert date strings to Python date objects if present
        try:
            if start_date:
                start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
            if due_date:
                due_date = datetime.strptime(due_date, '%Y-%m-%d').date()
            if reconciliation_date:
                reconciliation_date = datetime.strptime(reconciliation_date, '%Y-%m-%d').date()
        except ValueError as e:
            flash("Invalid date format. Please use YYYY-MM-DD.")
            return redirect("/modify")

        # Validate required fields
        if not task_id or not pos_id:
            flash("Task ID and POS ID are required.")
            return redirect("/modify")

        try:
            with engine.connect() as conn:
                # Update the task in the tasks table
                task_update = tasks_table.update().where(tasks_table.c.task_id == task_id).values(
                    pos_id=pos_id,
                    task_desc=description,
                    task_status=status,
                    task_priority=priority,
                    task_start_date=start_date,
                    task_due_date=due_date,
                    task_notes=notes
                )
                conn.execute(task_update)

                # Update the related blocker information if provided
                if blocker_desc or blocker_responsible:
                    # Check if blocker already exists for this task
                    blocker_exists = conn.execute(
                        select(blockers_table.c.blocker_id).where(blockers_table.c.task_id == task_id)
                    ).fetchone()

                    if blocker_exists:
                        # Update existing blocker
                        conn.execute(
                            blockers_table.update().where(blockers_table.c.task_id == task_id).values(
                                blocker_desc=blocker_desc,
                                blocker_responsible=blocker_responsible
                            )
                        )
                    else:
                        # Insert new blocker if it doesn't exist
                        conn.execute(
                            blockers_table.insert().values(
                                blocker_desc=blocker_desc,
                                blocker_responsible=blocker_responsible,
                                task_id=task_id,
                                pos_id=pos_id
                            )
                        )

                # Update reconciliation information if needed
                if reconciliation_date or certified is not None:
                    # Check if reconciliation already exists for this task
                    rec_exists = conn.execute(
                        select(rec_table.c.rec_id).where(rec_table.c.task_id == task_id)
                    ).fetchone()

                    if rec_exists:
                        # Update existing reconciliation
                        conn.execute(
                            rec_table.update().where(rec_table.c.task_id == task_id).values(
                                rec_date=reconciliation_date,
                                rec_certified=(certified == 'true') if certified else None
                            )
                        )
                    else:
                        # Insert new reconciliation if it doesn't exist
                        conn.execute(
                            rec_table.insert().values(
                                rec_date=reconciliation_date,
                                rec_certified=(certified == 'true') if certified else None,
                                task_id=task_id,
                                pos_id=pos_id
                            )
                        )

                conn.commit()
            flash("Task modified successfully!")  # Only display success if everything works
            return redirect("/modify")

        except Exception as e:
            logger.error(f"Error modifying task: {traceback.format_exc()}")
            flash("An error occurred while modifying the task.")
            return redirect("/modify")

    else:
        # Fetch POS data for the form dropdown
        pos_data = fetch_pos_data()

        # Fetch tasks similarly to the `/tasks` route to display them on the modify page
        query = select(
            tasks_table.c.task_id,
            tasks_table.c.task_desc,
            tasks_table.c.task_status,
            tasks_table.c.task_priority,
            tasks_table.c.task_start_date,
            tasks_table.c.task_due_date,
            tasks_table.c.task_notes,
            pos_table.c.pos_id,
            pos_table.c.pos_name,
            rec_table.c.rec_date,
            rec_table.c.rec_certified,
            blockers_table.c.blocker_desc,
            blockers_table.c.blocker_responsible
        ).select_from(
            tasks_table
            .join(pos_table, tasks_table.c.pos_id == pos_table.c.pos_id)
            .outerjoin(rec_table, tasks_table.c.rec_id == rec_table.c.rec_id)
            .outerjoin(blockers_table, tasks_table.c.blocker_id == blockers_table.c.blocker_id)
        ).order_by(desc(tasks_table.c.task_id))

        tasks = engine.connect().execute(query).fetchall()

        # Format tasks for rendering in template
        formatted_tasks = [format_task(task) for task in tasks]

        # Render the modify.html with tasks and POS data
        return render_template("modify.html", pos_data=pos_data, tasks=formatted_tasks, date=date)

@app.route("/kanban")
@login_required
def kanban():
    """
    Render the Kanban board page with POS data for filters.

    The Kanban board provides a visual overview of tasks, categorized by status.
    Fetches POS data for filtering purposes.

    Returns:
        - Render the 'kanban.html' template with POS data.
    """
    try:
        with engine.connect() as conn:
            pos_data = conn.execute(select(pos_table.c.pos_id, pos_table.c.pos_name)).fetchall()

        return render_template("kanban.html", pos_data=pos_data, date=datetime.today())
    except Exception as e:
        return jsonify({"error": "Error loading Kanban board"}), 500

@app.route("/api/kanban_tasks", methods=["POST"])
@login_required
def get_kanban_tasks():
    """
    Fetch all tasks for the Kanban board, with filters.

    This route processes filtering options submitted via a JSON request and returns a list 
    of tasks for rendering on the Kanban board.

    Request JSON:
        - search_query (str): Text to search in task descriptions.
        - pos_id (int): POS ID to filter by.
        - pos_name (str): POS Name to filter by.
        - start_date (str): Start date to filter tasks from.
        - end_date (str): End date to filter tasks until.
        - statuses (list): List of task statuses to filter by.
        - priorities (list): List of task priorities to filter by.

    Returns:
        - JSON response with filtered tasks.
    """
    try:
        data = request.get_json()
        search_query = data.get("search_query", "").strip()
        pos_id = data.get("pos_id")
        pos_name = data.get("pos_name", "").strip()
        start_date = data.get("start_date")
        end_date = data.get("end_date")
        statuses = data.get("statuses", [])
        priorities = data.get("priorities", [])

        with engine.connect() as conn:
            query = select(
                tasks_table.c.task_id,
                tasks_table.c.task_desc,
                tasks_table.c.task_status,
                tasks_table.c.task_priority,
                tasks_table.c.task_due_date,
                pos_table.c.pos_id,
                pos_table.c.pos_name
            ).select_from(
                tasks_table.join(pos_table, tasks_table.c.pos_id == pos_table.c.pos_id)
            )

            conditions = []
            if search_query:
                conditions.append(tasks_table.c.task_desc.ilike(f"%{search_query}%"))
            if pos_id:
                conditions.append(pos_table.c.pos_id == pos_id)
            if pos_name:
                conditions.append(pos_table.c.pos_name.ilike(f"%{pos_name}%"))
            if start_date:
                start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
                conditions.append(tasks_table.c.task_due_date >= start_date)
            if end_date:
                end_date = datetime.strptime(end_date, '%Y-%m-%d').date()
                conditions.append(tasks_table.c.task_due_date <= end_date)
            if statuses:
                conditions.append(tasks_table.c.task_status.in_(statuses))
            if priorities:
                conditions.append(tasks_table.c.task_priority.in_(priorities))

            if conditions:
                query = query.where(and_(*conditions))

            tasks = conn.execute(query).fetchall()

        tasks_list = [
            {
                "task_id": task.task_id,
                "task_desc": task.task_desc,
                "task_status": task.task_status,
                "task_priority": task.task_priority,
                "task_due_date": task.task_due_date.strftime('%Y-%m-%d') if task.task_due_date else "n/a",
                "pos_id": task.pos_id,
                "pos_name": task.pos_name
            } for task in tasks
        ]
        return jsonify({"tasks": tasks_list})

    except Exception as e:
        return jsonify({"error": "Failed to fetch tasks."}), 500

@app.route("/api/update_task_status/<int:task_id>", methods=["POST"])
@login_required
def update_task_status(task_id):
    """
    Update the task's status when dragged and dropped on the Kanban board.

    Args:
        task_id (int): The ID of the task to update.

    Request JSON:
        - status (str): The new status of the task.

    Returns:
        - JSON response indicating success or failure.
    """
    logger.debug(f"Received request to update task with ID: {task_id}")

    # Retrieve the new status from the request
    new_status = request.json.get('status')
    logger.debug(f"New status from request for task {task_id}: {new_status}")

    # Check if new_status is valid
    if not new_status:
        logger.error(f"No status provided for task {task_id}")
        return jsonify(success=False, message="No status provided"), 400

    try:
        with engine.connect() as conn:
            logger.debug(f"Executing update query for task {task_id} to set status to {new_status}")

            # Execute the update query
            result = conn.execute(
                tasks_table.update()
                .where(tasks_table.c.task_id == task_id)
                .values(task_status=new_status)
            )

            # Check how many rows were affected
            rows_affected = result.rowcount
            logger.debug(f"Rows affected by the update for task {task_id}: {rows_affected}")

            if rows_affected == 0:
                logger.error(f"Task {task_id} not found in the database. No rows affected.")
                return jsonify(success=False, message="Task not found"), 404

            conn.commit()  # Commit the transaction
            logger.debug(f"Successfully committed the status update for task {task_id} to {new_status}")

        # Log the success response
        response = jsonify(success=True)
        logger.debug(f"Returning success response for task {task_id}: {response.json}")
        return response

    except Exception as e:
        # Log the detailed error traceback
        logger.error(f"Exception occurred while updating task {task_id} status: {e}")
        logger.error(traceback.format_exc())
        return jsonify(success=False, message="Failed to update task status"), 500

@app.route("/api/pos_names", methods=["GET"])
@login_required
def get_pos_names():
    """
    Fetch POS names based on selected POS ID.

    Query Parameters:
        pos_id (int): The ID of the POS to fetch names for.

    Returns:
        - JSON response with POS names if found.
        - JSON error response if POS ID is not provided or an error occurs.
    """
    pos_id = request.args.get("pos_id")
    if pos_id:
        with engine.connect() as conn:
            pos_names = conn.execute(select(pos_table.c.pos_name).where(pos_table.c.pos_id == pos_id)).fetchall()
        pos_names_list = [pos_name[0] for pos_name in pos_names]
        return jsonify(success=True, pos_names=pos_names_list)
    return jsonify(success=False)

@app.route("/api/pos_ids", methods=["GET"])
@login_required
def get_pos_ids():
    """
    Fetch POS IDs based on selected POS Name.

    Query Parameters:
        pos_name (str): The name of the POS to fetch IDs for.

    Returns:
        - JSON response with POS IDs if found.
        - JSON error response if POS name is not provided or an error occurs.
    """
    pos_name = request.args.get("pos_name")
    if pos_name:
        with engine.connect() as conn:
            pos_ids = conn.execute(select(pos_table.c.pos_id).where(pos_table.c.pos_name == pos_name)).fetchall()
        pos_ids_list = [pos_id[0] for pos_id in pos_ids]
        return jsonify(success=True, pos_ids=pos_ids_list)
    return jsonify(success=False)

@app.route("/api/pos_names_and_ids", methods=["GET"])
@login_required
def get_all_pos_names_and_ids():
    """
    Fetch all POS Names and POS IDs for filter reset.

    Returns:
        - JSON response with all distinct POS names and IDs.
        - JSON error response if an error occurs.
    """
    try:
        with engine.connect() as conn:
            pos_names = conn.execute(select(pos_table.c.pos_name).distinct()).fetchall()
            pos_ids = conn.execute(select(pos_table.c.pos_id).distinct()).fetchall()

        pos_names_list = [pos_name[0] for pos_name in pos_names]
        pos_ids_list = [pos_id[0] for pos_id in pos_ids]

        return jsonify(success=True, pos_names=pos_names_list, pos_ids=pos_ids_list)

    except Exception as e:
        return jsonify(success=False, message="Failed to fetch POS Names and IDs."), 500

def errorhandler(e):
    """
    Handle errors by returning a custom error message.

    Args:
        e (Exception): The exception that was raised.

    Returns:
        - Rendered apology template with the error message and code.
    """
    logger.error(f"Error occurred: {e}")
    return apology(e.name, e.code)

# Listen for errors
for code in default_exceptions:
    app.errorhandler(code)(errorhandler)

if __name__ == "__main__":
    app.run(debug=False)  # Set debug to False to avoid detailed traceback in terminal



File: helpers.py
----------------------------
"""
helpers.py

Developed by Stefania Galatolo, assisted by ChatGPT 4o, because let's be honest, coding is always better with a little AI magic.
Stefania's coding journey was made more exciting with ChatGPT's witty banter and occasional dad jokes. Together, they tackled the 
task management app, making sure no task was left unhandled (or uncommented). 

This file serves as the utility hub for the task management application. It includes helper functions for interacting with the 
SQLite database, handling pagination, fetching POS data, formatting tasks for display, and managing user sessions. 

Key Components:
- Database Setup: Establishes a connection to the SQLite database and reflects its schema.
- Helper Functions: Includes utility functions for pagination, POS data retrieval, and task formatting.
- Decorators and Error Handling: Contains decorators for route protection and rendering apology messages.

Dependencies:
- Flask: Used for web framework capabilities, including session management and rendering templates.
- SQLAlchemy: Provides ORM capabilities to interact with the SQLite database.
- Logging: Facilitates error logging for debugging and monitoring purposes.
"""

from flask import redirect, render_template, session
from functools import wraps
from sqlalchemy import create_engine, MetaData, Table, select, func
from sqlalchemy.orm import sessionmaker
from datetime import date, datetime
from math import ceil
import logging
import traceback

# Configure logging to overwrite the log file at each run
logging.basicConfig(
    filename='app.log',
    level=logging.DEBUG,
    format='%(asctime)s %(levelname)s:%(message)s',
    filemode='w'
)

# Create a logger object
logger = logging.getLogger(__name__)

# Set up SQLAlchemy to connect to the SQLite database
# Using SQLAlchemy to establish a connection with the database, 
# making it possible to query and manipulate data using ORM methods.
DATABASE_URL = "sqlite:///taskflow.db"
engine = create_engine(DATABASE_URL, echo=False)
metadata = MetaData()
metadata.reflect(bind=engine)

# Load tables from the database into SQLAlchemy Table objects
# Reflects the database schema into Table objects, making it easier 
# to query and manage the data in those tables.
tasks_table = Table('tasks', metadata, autoload_with=engine)
pos_table = Table('pos', metadata, autoload_with=engine)
rec_table = Table('rec', metadata, autoload_with=engine)
blockers_table = Table('blockers', metadata, autoload_with=engine)
users_table = Table('users', metadata, autoload_with=engine)

# Configure session maker
# Establishes a session factory for interacting with the database, 
# ensuring queries are executed in the context of a session.
SessionLocal = sessionmaker(bind=engine)

def get_paginated_tasks(base_query, page, per_page):
    """
    Helper function to paginate tasks based on the provided query.

    This function takes a base SQLAlchemy query, applies pagination, 
    and returns a subset of results based on the current page and the 
    number of items per page.

    Parameters:
    - base_query (SQLAlchemy Select): The base query to paginate.
    - page (int): The current page number.
    - per_page (int): The number of items to display per page.

    Returns:
    - tasks (List): A list of paginated tasks.
    - total_records (int): The total number of records.
    - total_pages (int): The total number of pages.

    Note: This function logs an error message if pagination fails and returns empty values.
    """
    try:
        total_records_query = select(func.count()).select_from(base_query.alias())
        total_records = engine.connect().execute(total_records_query).scalar()
        total_pages = ceil(total_records / per_page)
        paginated_query = base_query.limit(per_page).offset((page - 1) * per_page)
        tasks = engine.connect().execute(paginated_query).fetchall()
        return tasks, total_records, total_pages
    except Exception as e:
        logger.error(f"Error during pagination: {traceback.format_exc()}")
        return [], 0, 0

def fetch_pos_data():
    """
    Helper function to fetch POS data for dropdowns.

    Retrieves POS (Point of Sale) data from the database to populate 
    dropdown menus in the UI, aiding in task filtering and creation.

    Returns:
    - pos_data (List): A list of tuples containing POS IDs and names.

    Note: Logs an error if fetching POS data fails and returns an empty list.
    """
    try:
        with engine.connect() as conn:
            pos_data = conn.execute(select(pos_table.c.pos_id, pos_table.c.pos_name)).fetchall()
        return pos_data
    except Exception as e:
        logger.error(f"Error fetching POS data: {traceback.format_exc()}")
        return []

def format_task(task):
    """
    Helper function to format task data for rendering.

    Formats a task object into a dictionary with all relevant fields 
    properly formatted for display purposes, such as converting dates 
    into readable strings.

    Parameters:
    - task (SQLAlchemy RowProxy): The task record to format.

    Returns:
    - formatted_task (dict): A dictionary containing the formatted task data.
    
    Keys include:
    - task_id, task_desc, task_status, task_priority, task_start_date, 
      task_due_date, task_notes, pos_id, pos_name, rec_date, rec_certified, 
      blocker_desc, blocker_responsible.
    """
    task_start_date = task.task_start_date.strftime('%Y-%m-%d') if isinstance(task.task_start_date, date) else "n/a"
    task_due_date = task.task_due_date.strftime('%Y-%m-%d') if isinstance(task.task_due_date, date) else "n/a"
    rec_date = task.rec_date.strftime('%Y-%m-%d') if isinstance(task.rec_date, date) else "n/a"

    return {
        "task_id": task.task_id if task.task_id is not None else "n/a",
        "task_desc": task.task_desc if task.task_desc is not None else "n/a",
        "task_status": task.task_status if task.task_status is not None else "n/a",
        "task_priority": task.task_priority if task.task_priority is not None else "n/a",
        "task_start_date": task_start_date,
        "task_due_date": task_due_date,
        "task_notes": task.task_notes if task.task_notes is not None else "n/a",
        "pos_id": task.pos_id if task.pos_id is not None else "n/a",
        "pos_name": task.pos_name if task.pos_name is not None else "n/a",
        "rec_date": rec_date,
        "rec_certified": "Yes" if task.rec_certified is True else "No" if task.rec_certified is False else "n/a",
        "blocker_desc": task.blocker_desc if task.blocker_desc is not None else "n/a",
        "blocker_responsible": task.blocker_responsible if task.blocker_responsible is not None else "n/a"
    }

def login_required(f):
    """
    Decorate routes to require login.

    A decorator function that wraps around route functions to enforce 
    user authentication. If a user is not logged in, they are redirected 
    to the login page.

    Parameters:
    - f (function): The route function to be decorated.

    Returns:
    - decorated_function (function): The wrapped function with authentication check.
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if session.get("user_id") is None:
            return redirect("/login")
        return f(*args, **kwargs)
    return decorated_function

def apology(message, code=400):
    """
    Render message as an apology to the user.

    Renders an apology message to the user using the 'apology.html' 
    template. Typically used to display error messages in a user-friendly 
    manner.

    Parameters:
    - message (str): The error message to display.
    - code (int): The HTTP status code to return (default is 400).

    Returns:
    - tuple (Response, int): The rendered template and HTTP status code.
    """
    return render_template("apology.html", top=code, bottom=message), code



--- Directory: ./core/flask_session ---

--- Directory: ./core/static ---

--- Directory: ./core/static/css ---

File: style.css
----------------------------
/* 
* Stefania Galatolo's Masterpiece
* Developed in collaboration with ChatGPT 4o, because who needs solo coding when you have an AI sidekick that never complains about coffee breaks?
* 
* File: style.css
* Purpose: Provides the visual styling for the entire task management application, ensuring a user-friendly and aesthetically pleasing interface.
*
* Key Sections:
* - Body and General Styles: Defines the foundational styles for the entire app to ensure a clean, modern look.
* - Navbar: Styles for the navigation bar to maintain consistency across the app and improve user navigation.
* - Buttons and Inputs: Creates a cohesive appearance for form elements and buttons, ensuring they are easy to interact with.
* - Task Table: Ensures that tasks are displayed in an organized and easily digestible manner within tables.
* - Kanban Board: Sets up the styles for the task Kanban board, enabling users to visually manage tasks.
* - Filter Sidebar: Styles for the filter section allowing users to sort tasks efficiently.
*/

/* 
* General styles for the entire page 
* Setting the font and background color to establish a clean, modern look
*/
body {
    font-family: Arial, sans-serif !important; /* Ensures a consistent, legible font across the app */
    background-color: #f8f9fa !important; /* Light background for a calm, neutral appearance */
    margin: 0 !important;
    padding: 0 !important;
    text-align: left !important;
}

/* 
* Navbar styles 
* Designed to be minimalistic and ensure easy navigation with clear, distinct links
*/
.navbar {
    background-color: #f8f9fa !important; /* Matches the page background for seamless integration */
    border-bottom: 1px solid #ddd !important; /* Subtle border for separation from the content */
}

.navbar a {
    color: black !important; /* Black text for high contrast and readability */
    font-weight: 500 !important; /* Slightly bolder text for emphasis */
    text-align: left !important;
}

.navbar a:hover {
    color: #007bff !important; /* Blue on hover to indicate interactivity */
}

.navbar .navbar-nav .nav-link {
    color: black !important;
}

.navbar-brand {
    color: black !important; /* Brand text remains black for consistency */
}

.navbar .btn {
    background-color: #007bff !important; /* Primary color for call-to-action */
    padding: 8px 16px !important; /* Ample padding for a touch-friendly button */
    border-radius: 4px !important; /* Rounded corners for a modern look */
    font-size: 16px !important;
    color: white !important;
    text-align: left !important;
}

.navbar .btn:hover {
    background-color: #0056b3 !important; /* Darker shade on hover to indicate action */
    color: white !important;
}

/* 
* Button styles 
* Uniform appearance for primary action buttons throughout the app
*/
.btn-primary {
    background-color: #007bff !important; /* Matches the primary theme color */
    border: none !important; /* Removing border for a cleaner look */
    color: white !important;
    padding: 10px 20px !important; /* Increased padding for a more prominent button */
    border-radius: 4px !important;
    cursor: pointer !important;
    text-align: left !important;
}

.btn-primary:hover {
    background-color: #0056b3 !important; /* Hover effect for user feedback */
}

/* 
* Styling for the main container 
* Provides spacing around the content for better readability
*/
.container {
    margin-top: 20px !important; /* Adds space at the top for breathing room */
    text-align: left !important;
}

/* 
* Form input styles 
* Ensures inputs are styled uniformly and are easy to interact with
*/
input[type="text"],
input[type="password"],
textarea,
select {
    width: 100% !important; /* Full-width inputs for consistency */
    padding: 8px !important;
    margin-bottom: 10px !important;
    border: 1px solid #ccc !important; /* Light border to outline the input fields */
    border-radius: 4px !important;
    text-align: left !important;
}

/* 
* Focused input styles 
* Highlights focused elements to improve user navigation
*/
input[type="text"]:focus,
input[type="password"]:focus,
textarea:focus,
select:focus {
    border-color: #007bff !important; /* Blue border to indicate focus */
    text-align: left !important;
}

/* 
* Table styles 
* Enhances the task list table for better data visualization
*/
.table {
    width: 100% !important;
    margin-bottom: 20px !important; /* Space below the table for separation */
    border-collapse: collapse !important; /* Collapse borders for a cleaner table */
    text-align: left !important;
}

.table th,
.table td {
    padding: 12px !important; /* Padding for better readability */
    border-bottom: 1px solid #ddd !important; /* Light border for row separation */
    vertical-align: top !important;
    white-space: normal !important;
}

.table th {
    background-color: #007bff !important; /* Blue background for header row */
    color: white !important;
}

.table tr:hover {
    background-color: #f1f1f1 !important; /* Highlight row on hover for focus */
}

/* 
* Styles for the "Notes" column 
* Specific width to ensure text wraps properly without overflowing
*/
.notes-column {
    width: 40em !important;
    min-width: 30em !important;
    max-width: 40em !important;
    white-space: normal !important;
    word-wrap: break-word !important;
}

/* 
* Table responsive 
* Enables horizontal scrolling for tables on smaller screens
*/
.table-responsive {
    overflow-x: auto !important;
    text-align: left !important;
}

/* 
* Additional padding for task container 
* Provides space around tasks for a cleaner layout
*/
.tasks-wrapper {
    padding: 15px !important;
    text-align: left !important;
}

/* 
* Kanban Board Styling 
* Defines the layout and appearance of the Kanban board
*/
.kanban-board {
    display: flex !important; /* Flexbox for a responsive layout */
    justify-content: space-between !important; /* Evenly space columns */
    margin-top: 20px !important;
    text-align: left !important;
}

.kanban-column {
    width: 23% !important; /* Equal width for all columns */
    background-color: #e9ecef !important; /* Light background for distinction */
    padding: 10px !important;
    border-radius: 5px !important; /* Rounded corners for modern design */
    border: 1px solid #ddd !important;
    text-align: left !important;
}

.kanban-column h2 {
    font-size: 18px !important;
    margin-top: 0 !important;
    margin-bottom: 15px !important;
    text-align: left !important;
}

.kanban-card {
    background-color: white !important;
    padding: 10px !important;
    border-radius: 5px !important; /* Slightly rounded corners */
    margin-bottom: 10px !important;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important; /* Subtle shadow for depth */
    cursor: pointer !important; /* Indicates that cards are draggable */
    text-align: left !important;
}

/* 
* Filter Sidebar Styling 
* Ensures the filter section is clearly structured and easy to use
*/
.filter-group {
    margin-bottom: 16px !important;
    text-align: left !important;
}

.filter-title {
    font-size: 1.5em !important; /* Larger text for section titles */
    margin-bottom: 10px !important;
    text-align: left !important;
}

.filter-label {
    display: block !important; /* Block display for full-width labels */
    margin-bottom: 5px !important;
    font-weight: bold !important; /* Bold for emphasis */
    text-align: left !important;
}

.filter-buttons {
    display: flex !important; /* Flexbox for easy arrangement */
    gap: 10px !important; /* Space between buttons */
    text-align: left !important;
}

/* 
* Date picker consistency 
* Full-width styling for date inputs to match other form elements
*/
input[type="date"] {
    width: 100% !important;
    text-align: left !important;
}

/* 
* Form control and group styles 
* Consistent appearance for form elements
*/
.form-control {
    width: 100% !important;
    padding: 8px !important;
    margin-bottom: 10px !important;
    border: 1px solid #ccc !important;
    border-radius: 4px !important;
    text-align: left !important;
}

.form-group {
    margin-bottom: 20px !important;
    text-align: left !important;
}

/* 
* Textarea styles 
* Allow vertical resizing for better user experience
*/
textarea {
    resize: vertical !important; /* Allow users to adjust height */
    overflow: auto !important;
    width: 100% !important;
    padding: 8px !important;
    border: 1px solid #ccc !important;
    border-radius: 4px !important;
    text-align: left !important;
}

/* 
* Highlight the Task ID field 
* Provides visual emphasis on the Task ID input to indicate its importance
*/
#task_id {
    border: 2px solid #007bff; /* Blue border to match the primary color scheme */
    background-color: #f0f8ff; /* Very light blue background */
    font-size: 1.1em; /* Slightly larger font */
    padding: 10px; /* Extra padding for prominence */
}

/* 
* Add a focus effect to the Task ID input 
* Enhances user feedback when interacting with this specific field
*/
#task_id:focus {
    border-color: #0056b3; /* Darker blue on focus */
    box-shadow: 0 0 5px rgba(0, 123, 255, 0.5); /* Subtle glow effect */
}



--- Directory: ./core/static/images ---

--- Directory: ./core/static/js ---

File: createTasks.js
----------------------------
/*
 * Stefania Galatolo's JavaScript Magic
 * Developed in collaboration with ChatGPT 4o, because even the most brilliant minds need a little AI-powered magic wand now and then!
 * 
 * File: createTasks.js
 * 
 * Purpose: This file is responsible for handling the interactivity of the task creation form in the task management app. 
 * It manages the synchronization of Point of Sale (POS) fields (both POS Name and POS ID) to ensure consistency when the user selects a POS. 
 * Additionally, it enforces mutual exclusivity for the 'Certified True' and 'Certified False' checkboxes, 
 * ensuring that only one can be selected at a time.
 * 
 * Key Features:
 * - Synchronization between POS Name and POS ID dropdowns.
 * - Mutual exclusivity enforcement for 'Certified True' and 'Certified False' checkboxes.
 * - Event-driven architecture using JavaScript's event listeners to respond to user actions.
 * 
 * Correlation with Other Files:
 * - Works in conjunction with the HTML form elements that contain POS Name, POS ID, and certification checkboxes.
 * - Ensures data consistency before form submission, thereby aiding in maintaining data integrity within the backend database.
 * 
 * Flow:
 * 1. When the DOM content is fully loaded, the script initializes event listeners for the POS dropdowns and certification checkboxes.
 * 2. The `syncPosFields` function is triggered whenever a change event occurs on either POS dropdown, updating the corresponding field to keep them synchronized.
 * 3. The `handleCertifiedCheckboxes` function manages the certification checkboxes, ensuring only one checkbox can be selected at any given time.
 */

document.addEventListener("DOMContentLoaded", function () {
    // Elements for POS selection
    const posNameSelect = document.getElementById("pos_name"); // Dropdown for selecting POS Name
    const posIDSelect = document.getElementById("pos_id"); // Dropdown for selecting POS ID
    const certifiedTrueCheckbox = document.getElementById("certified_true"); // Checkbox for 'Certified True'
    const certifiedFalseCheckbox = document.getElementById("certified_false"); // Checkbox for 'Certified False'

    // Function to synchronize POS ID and POS Name based on selection
    // This function is called whenever the user changes the selected option in either the POS Name or POS ID dropdowns.
    // It updates the corresponding field to ensure consistency between the POS Name and POS ID.
    function syncPosFields(event) {
        if (event.target === posNameSelect) {
            // When POS Name is selected, update POS ID accordingly
            const selectedPosNameOption = posNameSelect.options[posNameSelect.selectedIndex];
            posIDSelect.value = selectedPosNameOption.getAttribute("data-pos-id");
        } else if (event.target === posIDSelect) {
            // When POS ID is selected, update POS Name accordingly
            const selectedPosIDOption = posIDSelect.options[posIDSelect.selectedIndex];
            posNameSelect.value = selectedPosIDOption.getAttribute("data-pos-name");
        }
    }

    // Event listeners for POS selection
    // These listeners call the `syncPosFields` function to keep the POS Name and POS ID fields synchronized.
    // This ensures that changing one field updates the other to maintain data integrity.
    posNameSelect.addEventListener("change", syncPosFields);
    posIDSelect.addEventListener("change", syncPosFields);

    // Function to ensure only one certified checkbox is selected at a time
    // This function is called when the user changes the state of either certification checkbox.
    // It enforces mutual exclusivity, ensuring that only one checkbox ('Certified True' or 'Certified False') can be selected at a time.
    function handleCertifiedCheckboxes(event) {
        if (event.target.checked) { // Only proceed if the checkbox is being checked
            if (event.target.id === "certified_true") {
                certifiedFalseCheckbox.checked = false; // Uncheck 'Certified False' if 'Certified True' is checked
            } else if (event.target.id === "certified_false") {
                certifiedTrueCheckbox.checked = false; // Uncheck 'Certified True' if 'Certified False' is checked
            }
        }
    }

    // Event listeners for Certified checkboxes
    // These listeners ensure mutual exclusivity between 'Certified True' and 'Certified False'.
    // They call the `handleCertifiedCheckboxes` function whenever the state of a checkbox is changed.
    certifiedTrueCheckbox.addEventListener("change", handleCertifiedCheckboxes);
    certifiedFalseCheckbox.addEventListener("change", handleCertifiedCheckboxes);
});



File: kanban.js
----------------------------
/*
 * kanban.js
 * Developed by Stefania Galatolo, with a little help (or a lot) from ChatGPT 4o. 
 * Let's just say Stefania was about to be lost in the JavaScript jungle, but luckily, ChatGPT swung in on a vine and helped out!
 *
 * This script is responsible for handling the entire functionality of the Kanban board in the task management tool.
 * It manages task filtering, fetching tasks from the server, updating task statuses through a drag-and-drop interface, and initializing the Kanban board columns.
 * The script utilizes the Fetch API for backend communication and Sortable.js for implementing drag-and-drop functionality on the board.
 *
 * Key functionalities include:
 * - Fetching and displaying tasks in the Kanban board
 * - Filtering tasks based on search queries, POS IDs, POS Names, statuses, and priorities
 * - Updating task status through drag-and-drop interaction
 * - Ensuring synchronization of the front-end display with the backend database
 *
 * Inputs:
 * - User interactions such as searching, filtering, and dragging tasks
 * - API responses from the server containing task data, POS names, and POS IDs
 *
 * Outputs:
 * - Dynamically updated Kanban board reflecting the current state of tasks
 * - Visual feedback and task status updates sent to the backend
 */

// Runs when the DOM content is fully loaded
document.addEventListener("DOMContentLoaded", function () {
    // DOM elements references for task search, filtering, and Kanban columns
    // These elements are crucial for user interaction with the task filtering system and the Kanban board
    const taskSearchInput = document.getElementById("taskSearch"); // Input field for task search
    const filterBtn = document.getElementById("filterBtn"); // Button to apply filters
    const clearFilterBtn = document.getElementById("clearFilterBtn"); // Button to clear all filters
    const posIDSelect = document.getElementById("filterPosID"); // Dropdown for selecting POS IDs
    const posNameSelect = document.getElementById("filterPosName"); // Dropdown for selecting POS Names
    const startDateInput = document.getElementById("startDate"); // Input field for start date filter
    const endDateInput = document.getElementById("endDate"); // Input field for end date filter
    const dueTodayBtn = document.getElementById("dueTodayBtn"); // Button to filter tasks due today

    // DOM elements for Kanban columns, representing task statuses
    const backlogColumn = document.getElementById("backlog");
    const todoColumn = document.getElementById("todo");
    const inProgressColumn = document.getElementById("inprogress");
    const doneColumn = document.getElementById("done");

    // Flags to prevent multiple fetch calls during dropdown updates
    // These prevent duplicate network requests when updating dropdown options
    let isPosIDUpdating = false; 
    let isPosNameUpdating = false;

    /**
     * Sets up date inputs to show today's date by default
     * Used to provide a default filter for tasks due today, enhancing user experience
     */
    function getTodayDate() {
        const today = new Date();
        const yyyy = today.getFullYear();
        const mm = String(today.getMonth() + 1).padStart(2, '0');
        const dd = String(today.getDate()).padStart(2, '0');
        return `${yyyy}-${mm}-${dd}`;
    }

    // Today's date is computed once to be used as the default for date filters
    const todayDate = getTodayDate();
    setDateInputPlaceholders();

    /**
     * Sets placeholders and default values for date inputs to today's date
     * Ensures that the date inputs have user-friendly defaults
     */
    function setDateInputPlaceholders() {
        startDateInput.value = todayDate;
        endDateInput.value = todayDate;
        startDateInput.placeholder = todayDate;
        endDateInput.placeholder = todayDate;
    }

    /**
     * Gets the values of all selected checkboxes
     * @param {string} selector - CSS selector to identify the checkboxes
     * @returns {Array} - Array of values of checked checkboxes
     */
    function getSelectedCheckboxValues(selector) {
        const checkboxes = document.querySelectorAll(selector);
        return Array.from(checkboxes)
            .filter(checkbox => checkbox.checked)
            .map(checkbox => checkbox.value);
    }

    /**
     * Fetches all POS names and IDs to populate the dropdowns
     * Interacts with the backend API to get the list of POS names and IDs
     */
    function fetchAllPosNamesAndIds() {
        fetch('/api/pos_names_and_ids')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Populate POS Name dropdown with data received from the backend
                    posNameSelect.innerHTML = '<option value="">All</option>';
                    data.pos_names.forEach(posName => {
                        const option = document.createElement("option");
                        option.value = posName;
                        option.textContent = posName;
                        posNameSelect.appendChild(option);
                    });

                    // Populate POS ID dropdown with data received from the backend
                    posIDSelect.innerHTML = '<option value="">All</option>';
                    data.pos_ids.forEach(posId => {
                        const option = document.createElement("option");
                        option.value = posId;
                        option.textContent = posId;
                        posIDSelect.appendChild(option);
                    });
                }
            })
            .catch(error => console.error("Error fetching POS Names and IDs:", error));
    }

    /**
     * Fetches POS Names based on selected POS ID
     * Prevents redundant fetches using a flag and updates the POS Name dropdown
     * @param {string} posId - The POS ID selected by the user
     */
    function fetchPosNames(posId) {
        if (!isPosIDUpdating) {
            isPosIDUpdating = true;
            fetch(`/api/pos_names?pos_id=${posId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Update POS Name dropdown based on POS ID selection
                        posNameSelect.innerHTML = '<option value="">All</option>';
                        data.pos_names.forEach(posName => {
                            const option = document.createElement("option");
                            option.value = posName;
                            option.textContent = posName;
                            posNameSelect.appendChild(option);
                        });
                        // Auto-select the only option if only one POS name is returned
                        if (data.pos_names.length === 1) {
                            posNameSelect.value = data.pos_names[0];
                        }
                    }
                })
                .catch(error => console.error("Error fetching POS Names:", error))
                .finally(() => isPosIDUpdating = false);
        }
    }

    /**
     * Fetches POS IDs based on selected POS Name
     * Prevents redundant fetches using a flag and updates the POS ID dropdown
     * @param {string} posName - The POS Name selected by the user
     */
    function fetchPosNumbers(posName) {
        if (!isPosNameUpdating) {
            isPosNameUpdating = true;
            fetch(`/api/pos_ids?pos_name=${posName}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Update POS ID dropdown based on POS Name selection
                        posIDSelect.innerHTML = '<option value="">All</option>';
                        data.pos_ids.forEach(posId => {
                            const option = document.createElement("option");
                            option.value = posId;
                            option.textContent = posId;
                            posIDSelect.appendChild(option);
                        });
                        // Auto-select the only option if only one POS ID is returned
                        if (data.pos_ids.length === 1) {
                            posIDSelect.value = data.pos_ids[0];
                        }
                    }
                })
                .catch(error => console.error("Error fetching POS IDs:", error))
                .finally(() => isPosNameUpdating = false);
        }
    }

    // Event listeners to update POS names/IDs when the dropdown selection changes
    posIDSelect.addEventListener("change", function () {
        const selectedPosId = posIDSelect.value;
        if (selectedPosId) {
            fetchPosNames(selectedPosId);
        }
    });

    posNameSelect.addEventListener("change", function () {
        const selectedPosName = posNameSelect.value;
        if (selectedPosName) {
            fetchPosNumbers(selectedPosName);
        }
    });

    /**
     * Fetches tasks based on the provided filter criteria and displays them on the Kanban board
     * This function clears existing tasks from the board and re-populates it with filtered tasks
     * @param {Object} data - The filter criteria to be sent to the backend
     */
    function fetchAndDisplayKanbanTasks(data) {
        fetch("/api/kanban_tasks", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data),
        })
        .then(response => response.json())
        .then(data => {
            // Clear the task cards inside each column while preserving the label
            backlogColumn.querySelectorAll('.task-card').forEach(e => e.remove());
            todoColumn.querySelectorAll('.task-card').forEach(e => e.remove());
            inProgressColumn.querySelectorAll('.task-card').forEach(e => e.remove());
            doneColumn.querySelectorAll('.task-card').forEach(e => e.remove());

            // Render tasks in the appropriate columns
            if (data.tasks && data.tasks.length > 0) {
                data.tasks.forEach(task => {
                    const taskCard = document.createElement("div");
                    taskCard.className = "card task-card mb-3";
                    taskCard.setAttribute("data-task-id", task.task_id);
                    taskCard.setAttribute("data-task-status", task.task_status); // To track status for drag-and-drop
                    taskCard.innerHTML = `
                        <div class="card-body">
                            <h5 class="card-title">${task.task_desc || 'No Description'}</h5>
                            <p class="card-text"><strong>Status:</strong> ${task.task_status}</p>
                            <p class="card-text"><strong>Priority:</strong> ${task.task_priority}</p>
                            <p class="card-text"><strong>Due Date:</strong> ${task.task_due_date}</p>
                        </div>
                    `;

                    // Append the task card directly to the relevant column
                    if (task.task_status === "Backlog") {
                        backlogColumn.appendChild(taskCard);
                    } else if (task.task_status === "To Do") {
                        todoColumn.appendChild(taskCard);
                    } else if (task.task_status === "In Progress") {
                        inProgressColumn.appendChild(taskCard);
                    } else if (task.task_status === "Done") {
                        doneColumn.appendChild(taskCard);
                    }
                });
            } else {
                // Handle case where no tasks are found
                backlogColumn.innerHTML += "<p>No Backlog tasks found.</p>";
                todoColumn.innerHTML += "<p>No To Do tasks found.</p>";
                inProgressColumn.innerHTML += "<p>No In Progress tasks found.</p>";
                doneColumn.innerHTML += "<p>No Done tasks found.</p>";
            }

            // Reinitialize sortable for drag-and-drop functionality after rendering tasks
            initializeSortable();
        })
        .catch(error => console.error("Error fetching Kanban tasks:", error));
    }

    // Event listener for the filter button
    // Applies filters based on user input and fetches matching tasks
    filterBtn.addEventListener("click", function () {
        const posID = posIDSelect.value;
        const posName = posNameSelect.value;
        const startDate = startDateInput.value !== todayDate ? startDateInput.value : null;
        const endDate = endDateInput.value !== todayDate ? endDateInput.value : null;
        const selectedStatuses = getSelectedCheckboxValues("input[id^='status']");
        const selectedPriorities = getSelectedCheckboxValues("input[id^='priority']");
        const searchQuery = taskSearchInput.value;

        const data = {
            pos_id: posID,
            pos_name: posName,
            start_date: startDate,
            end_date: endDate,
            statuses: selectedStatuses,
            priorities: selectedPriorities,
            search_query: searchQuery
        };

        fetchAndDisplayKanbanTasks(data);
    });

    // "Due Today" button event listener
    // Fetches tasks due today and displays them on the Kanban board
    dueTodayBtn.addEventListener("click", function () {
        const todayDate = getTodayDate();

        // Create a data object to send to the backend
        const data = {
            start_date: todayDate,
            end_date: todayDate
        };

        // Call the function to fetch and display tasks filtered by today's date
        fetchAndDisplayKanbanTasks(data);
    });

    // Event listener for task search input
    // Fetches tasks based on the search query entered by the user
    taskSearchInput.addEventListener("input", function () {
        const query = taskSearchInput.value;
        const posID = posIDSelect.value;
        const posName = posNameSelect.value;
        const startDate = startDateInput.value !== todayDate ? startDateInput.value : null;
        const endDate = endDateInput.value !== todayDate ? endDateInput.value : null;
        const selectedStatuses = getSelectedCheckboxValues("input[id^='status']");
        const selectedPriorities = getSelectedCheckboxValues("input[id^='priority']");

        const data = {
            search_query: query,
            pos_id: posID,
            pos_name: posName,
            start_date: startDate,
            end_date: endDate,
            statuses: selectedStatuses,
            priorities: selectedPriorities
        };

        fetchAndDisplayKanbanTasks(data);
    });

    // Event listener for the clear filter button
    // Clears all filter inputs and fetches all tasks without any filters
    clearFilterBtn.addEventListener("click", function () {
        // Clear filter inputs
        posIDSelect.value = "";
        posNameSelect.value = "";
        taskSearchInput.value = "";
        setDateInputPlaceholders();

        // Uncheck all checkboxes
        document.querySelectorAll("input[id^='status'], input[id^='priority']").forEach(checkbox => {
            checkbox.checked = false;
        });

        // Re-fetch POS names and IDs
        fetchAllPosNamesAndIds();

        // Fetch all tasks with no filters
        fetchAndDisplayKanbanTasks({
            search_query: "",
            pos_id: "",
            pos_name: "",
            start_date: null,
            end_date: null,
            statuses: [],
            priorities: []
        });
    });

    // Initial fetch of tasks when the page loads
    // This ensures the Kanban board is populated as soon as the user visits the page
    fetchAndDisplayKanbanTasks({});

    /**
     * Handles updating task status in both the frontend and backend
     * @param {HTMLElement} taskElement - The task element that has been dragged and dropped
     */
    function handleTaskStatusUpdate(taskElement) {
        const taskId = taskElement.getAttribute('data-task-id');
        const previousStatus = taskElement.getAttribute('data-task-status');

        // Identify the new status based on the column where the task is dropped
        let newStatus = '';
        const parentColumnId = taskElement.parentElement.id;

        if (parentColumnId === 'backlog') {
            newStatus = 'Backlog';
        } else if (parentColumnId === 'todo') {
            newStatus = 'To Do';
        } else if (parentColumnId === 'inprogress') {
            newStatus = 'In Progress';
        } else if (parentColumnId === 'done') {
            newStatus = 'Done';
        }

        if (newStatus && newStatus !== previousStatus) {
            // Update the status in the UI
            const statusElement = Array.from(taskElement.querySelectorAll('.card-text')).find(p => p.innerText.includes('Status'));
            statusElement.innerHTML = `<strong>Status:</strong> ${newStatus}`;
            taskElement.setAttribute('data-task-status', newStatus);

            // Send the updated status to the backend
            fetch(`/api/update_task_status/${taskId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ status: newStatus })
            })
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    console.error(`Failed to update task ${taskId} in the database.`);
                    // Revert the UI if the update fails
                    statusElement.innerHTML = `<strong>Status:</strong> ${previousStatus}`;
                    taskElement.setAttribute('data-task-status', previousStatus);
                }
            })
            .catch(error => {
                console.error(`Error updating task ${taskId} status:`, error);
                // Revert the UI in case of an error
                statusElement.innerHTML = `<strong>Status:</strong> ${previousStatus}`;
                taskElement.setAttribute('data-task-status', previousStatus);
            });
        }
    }

    /**
     * Initializes sortable for drag-and-drop functionality on each column
     * Uses Sortable.js to enable reordering of tasks within and across columns
     */
    function initializeSortable() {
        new Sortable(backlogColumn, {
            group: 'kanban',
            animation: 150,
            onEnd: function (evt) {
                handleTaskStatusUpdate(evt.item);  // Call status update handler on drop
            }
        });

        new Sortable(todoColumn, {
            group: 'kanban',
            animation: 150,
            onEnd: function (evt) {
                handleTaskStatusUpdate(evt.item);  // Call status update handler on drop
            }
        });

        new Sortable(inProgressColumn, {
            group: 'kanban',
            animation: 150,
            onEnd: function (evt) {
                handleTaskStatusUpdate(evt.item);  // Call status update handler on drop
            }
        });

        new Sortable(doneColumn, {
            group: 'kanban',
            animation: 150,
            onEnd: function (evt) {
                handleTaskStatusUpdate(evt.item);  // Call status update handler on drop
            }
        });
    }
});



File: modifyTasks.js
----------------------------
/**
 * modifyTasks.js
 * Developed by Stefania Galatolo, with a little help from ChatGPT 4.0.
 * (Coding is tough, and sometimes it's just better to have a co-pilot who never sleeps, right?)
 *
 * This script is responsible for handling the modification of tasks in the task management application.
 * It supports key operations such as:
 * - Synchronizing POS (Point of Sale) fields between their name and ID.
 * - Clearing the task modification form.
 * - Fetching existing task data from the server based on user input.
 * - Submitting modified task data back to the server for update.
 * 
 * This script interacts with the server using GET and POST requests and communicates with
 * specific API endpoints (`/api/get_task/{task_id}` and `/api/modify_task/{task_id}`).
 * 
 * Important connections:
 * - This file communicates with `app.py` in the backend, where Flask routes handle the task data requests.
 * - It also works with the HTML form elements on the `modify.html` template page, ensuring that task modification fields are synced.
 */

document.addEventListener("DOMContentLoaded", function () {
    // Get references to key elements within the document for task modification.
    const taskIdInput = document.getElementById("task_id"); // Input for the task ID, used to fetch and modify tasks.
    const modifyBtn = document.getElementById("modifyBtn"); // Button to trigger task modification.

    // Elements for POS (Point of Sale) selection
    const posNameSelect = document.getElementById("pos_name"); // Dropdown to select POS by name.
    const posIDSelect = document.getElementById("pos_id"); // Dropdown to select POS by ID.

    // Certified radio buttons for user to mark if the task is certified or not.
    const certifiedYesRadio = document.getElementById("certified_yes");
    const certifiedNoRadio = document.getElementById("certified_no");

    /**
     * Synchronizes POS fields between POS name and POS ID.
     * This ensures that when one field (POS name or POS ID) is updated, the corresponding
     * value in the other field is also updated to reflect the selected POS correctly.
     *
     * @param {Event} event - The change event triggered when the POS fields are modified.
     */
    function syncPosFields(event) {
        // If POS name is changed, update the POS ID field to match.
        if (event.target === posNameSelect) {
            const selectedPosNameOption = posNameSelect.options[posNameSelect.selectedIndex];
            posIDSelect.value = selectedPosNameOption.getAttribute("data-pos-id");
        } 
        // If POS ID is changed, update the POS name field to match.
        else if (event.target === posIDSelect) {
            const selectedPosIDOption = posIDSelect.options[posIDSelect.selectedIndex];
            posNameSelect.value = selectedPosIDOption.getAttribute("data-pos-name");
        }
    }

    // Attach event listeners to POS selection elements to ensure they stay synchronized.
    posNameSelect.addEventListener("change", syncPosFields);
    posIDSelect.addEventListener("change", syncPosFields);

    /**
     * Clears all form fields, resetting them to their default values.
     * This function is useful when no task is selected or when a task needs to be cleared
     * (e.g., when the user enters an invalid task ID).
     */
    function clearFormFields() {
        posNameSelect.value = ""; // Clear POS name
        posIDSelect.value = "";   // Clear POS ID
        document.getElementById("description").value = ""; // Clear description
        
        // Uncheck all status and priority radio buttons
        document.querySelectorAll('input[name="status"]').forEach(radio => radio.checked = false);
        document.querySelectorAll('input[name="priority"]').forEach(radio => radio.checked = false);

        document.getElementById("start_date").value = ""; // Clear start date
        document.getElementById("due_date").value = ""; // Clear due date
        document.getElementById("reconciliation_date").value = ""; // Clear reconciliation date
        document.getElementById("notes").value = ""; // Clear notes
        document.getElementById("blocker_desc").value = ""; // Clear blocker description
        document.getElementById("blocker_responsible").value = ""; // Clear blocker responsible person

        // Clear certified radio buttons
        certifiedYesRadio.checked = false;
        certifiedNoRadio.checked = false;
    }

    /**
     * Fetches task data from the server based on the provided task ID.
     * This function sends a GET request to the `/api/get_task/{task_id}` endpoint
     * to retrieve the task data. The form fields are then populated with the fetched task details.
     * 
     * @param {string} taskId - The ID of the task to fetch data for.
     * 
     * The server response should include task information such as POS, description, status, priority, 
     * and reconciliation details, which will be reflected in the form fields.
     */
    function fetchTaskData(taskId) {
        if (taskId) {
            fetch(`/api/get_task/${taskId}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error("Network response was not ok");
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        // Populate the form fields with the fetched task data
                        posNameSelect.value = data.task.pos_name;
                        posIDSelect.value = data.task.pos_id;
                        document.getElementById("description").value = data.task.task_desc;

                        // Ensure the status and priority radio buttons are properly selected
                        const statusRadio = document.querySelector(`input[name="status"][value="${data.task.task_status}"]`);
                        if (statusRadio) statusRadio.checked = true;

                        const priorityRadio = document.querySelector(`input[name="priority"][value="${data.task.task_priority}"]`);
                        if (priorityRadio) priorityRadio.checked = true;

                        document.getElementById("start_date").value = data.task.task_start_date;
                        document.getElementById("due_date").value = data.task.task_due_date;
                        document.getElementById("reconciliation_date").value = data.task.rec_date;
                        document.getElementById("notes").value = data.task.task_notes;
                        document.getElementById("blocker_desc").value = data.task.blocker_desc;
                        document.getElementById("blocker_responsible").value = data.task.blocker_responsible;

                        // Set the certified radio buttons based on the fetched data
                        if (data.task.rec_certified === 'Yes') {
                            certifiedYesRadio.checked = true;
                            certifiedNoRadio.checked = false;
                        } else if (data.task.rec_certified === 'No') {
                            certifiedYesRadio.checked = false;
                            certifiedNoRadio.checked = true;
                        } else {
                            certifiedYesRadio.checked = false;
                            certifiedNoRadio.checked = false;
                        }
                    } else {
                        alert(data.message || "Task not found!");
                        console.error("API Error:", data);
                    }
                })
                .catch(error => {
                    console.error('Error fetching task:', error);
                    alert('Error fetching task. Please check the console for more details.');
                });
        } else {
            // Clear all fields if taskId is empty
            clearFormFields();
        }
    }

    // Listen for changes in the task ID input field to trigger task data fetching.
    taskIdInput.addEventListener("input", function () {
        const taskId = taskIdInput.value.trim();
        
        // Trigger fetch only if the input is not empty
        if (taskId) {
            fetchTaskData(taskId);
        } else {
            clearFormFields();
        }
    });

    /**
     * Sends the modified task data to the server for updating the task.
     * This function gathers all the data from the form and sends a POST request
     * to the `/api/modify_task/{task_id}` endpoint to update the task details.
     */
    function modifyTaskData() {
        const taskId = taskIdInput.value.trim();
        if (!taskId) {
            alert("Task ID is required to modify a task.");
            return;
        }

        const formData = new FormData(document.getElementById("modifyTaskForm")); // Collect form data
        const formObject = {};
        formData.forEach((value, key) => formObject[key] = value); // Convert form data to object

        fetch(`/api/modify_task/${taskId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(formObject) // Send form data as JSON
        })
        .then(response => {
            if (!response.ok) {
                console.error(`Server error: ${response.statusText}`);
                throw new Error("Error modifying task");
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                alert("Task modified successfully!");
                window.location.reload(); // Reload page upon success
            } else {
                alert(data.message || "Failed to modify task.");
            }
        })
        .catch(error => {
            console.error('Error modifying task:', error);
        });
    }

    // Listen for clicks on the "Modify" button to send the modified data.
    modifyBtn.addEventListener("click", function () {
        modifyTaskData();
    });
});



File: tasksLookup.js
----------------------------
/*
 * tasksLookup.js
 * Developed by Stefania Galatolo with invaluable assistance from ChatGPT 4.0.
 * You know, Stefania had grand plans for this feature, but it turns out that
 * async JavaScript was like a foreign language she hadn't quite mastered yet.
 * Enter ChatGPT, the silent code ninja, helping her conquer the asynchronous
 * jungle one fetch call at a time.
 * 
 * This script is a crucial part of the task management app. It handles:
 * - Fetching tasks from the server based on user input and filters.
 * - Filtering tasks by various criteria such as POS ID, POS Name, dates, status, and priority.
 * - Providing real-time search functionality as the user types.
 * - Implementing pagination to navigate through the tasks.
 * 
 * **Main Components:**
 * 1. Event Listeners: Attached to DOM elements like filter inputs, search box, and pagination controls.
 * 2. Fetch Operations: Sends requests to the server to retrieve data, populate dropdowns, and update the task table.
 * 3. Dynamic DOM Manipulation: Updates the task table and pagination controls based on server responses.
 * 
 * **Interactivity with Server and Other Files:**
 * - Communicates with the Flask backend (`/filter_tasks`, `/api/pos_names_and_ids`, etc.) to fetch and filter task data.
 * - Works alongside HTML templates and server-side routes defined in Flask to provide a dynamic task management experience.
 * - Directly manipulates HTML elements within `tasks.html` to display and filter tasks.
 */

document.addEventListener("DOMContentLoaded", function () {
    // Get references to DOM elements that are frequently used
    // These elements are used throughout the script to capture user inputs for filtering
    // and to display the fetched tasks.
    const taskSearchInput = document.getElementById("taskSearch");
    const filterBtn = document.getElementById("filterBtn");
    const clearFilterBtn = document.getElementById("clearFilterBtn");
    const taskTableBody = document.getElementById("taskTableBody");
    const posIDSelect = document.getElementById("filterPosID");
    const posNameSelect = document.getElementById("filterPosName");
    const startDateInput = document.getElementById("startDate");
    const endDateInput = document.getElementById("endDate");
    const paginationContainer = document.getElementById("paginationContainer"); // Container for pagination controls

    let isPosIDUpdating = false;  // Flags to prevent multiple simultaneous updates
    let isPosNameUpdating = false;
    let currentPage = 1; // Track the current page

    // Get today's date for setting placeholders
    // This function provides a formatted date string for today's date
    // used to set default values and placeholders for date inputs.
    function getTodayDate() {
        const today = new Date();
        const yyyy = today.getFullYear();
        const mm = String(today.getMonth() + 1).padStart(2, '0');
        const dd = String(today.getDate()).padStart(2, '0');
        return `${yyyy}-${mm}-${dd}`;
    }

    // Set date input placeholders to today's date
    const todayDate = getTodayDate();
    setDateInputPlaceholders();

    function setDateInputPlaceholders() {
        startDateInput.value = todayDate;
        endDateInput.value = todayDate;
        startDateInput.placeholder = todayDate;
        endDateInput.placeholder = todayDate;
    }

    // Helper function to get values of selected checkboxes
    // Collects all checked checkboxes matching the selector and returns their values.
    function getSelectedCheckboxValues(selector) {
        const checkboxes = document.querySelectorAll(selector);
        return Array.from(checkboxes)
            .filter(checkbox => checkbox.checked)
            .map(checkbox => checkbox.value);
    }

    // Fetch all POS Names and POS IDs for reset
    // This function fetches available POS names and IDs from the server
    // to populate the dropdowns with all available options.
    function fetchAllPosNamesAndIds() {
        fetch('/api/pos_names_and_ids')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Reset POS Name dropdown
                    posNameSelect.innerHTML = '<option value="">All</option>';
                    data.pos_names.forEach(posName => {
                        const option = document.createElement("option");
                        option.value = posName;
                        option.textContent = posName;
                        posNameSelect.appendChild(option);
                    });

                    // Reset POS ID dropdown
                    posIDSelect.innerHTML = '<option value="">All</option>';
                    data.pos_ids.forEach(posId => {
                        const option = document.createElement("option");
                        option.value = posId;
                        option.textContent = posId;
                        posIDSelect.appendChild(option);
                    });
                }
            })
            .catch(error => console.error("Error fetching POS Names and IDs:", error));
    }

    // Fetch POS Names based on selected POS ID
    // This function makes an API call to get POS names related to the selected POS ID
    // and updates the POS Name dropdown options.
    function fetchPosNames(posId) {
        if (!isPosIDUpdating) {
            isPosIDUpdating = true;
            fetch(`/api/pos_names?pos_id=${posId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        posNameSelect.innerHTML = '<option value="">All</option>'; // Reset options
                        data.pos_names.forEach(posName => {
                            const option = document.createElement("option");
                            option.value = posName;
                            option.textContent = posName;
                            posNameSelect.appendChild(option);
                        });
                        if (data.pos_names.length === 1) {
                            // If there's only one matching name, select it automatically
                            posNameSelect.value = data.pos_names[0];
                        }
                    }
                })
                .catch(error => console.error("Error fetching POS Names:", error))
                .finally(() => isPosIDUpdating = false);
        }
    }

    // Fetch POS IDs based on selected POS Name
    // This function makes an API call to get POS IDs related to the selected POS name
    // and updates the POS ID dropdown options.
    function fetchPosNumbers(posName) {
        if (!isPosNameUpdating) {
            isPosNameUpdating = true;
            fetch(`/api/pos_ids?pos_name=${posName}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        posIDSelect.innerHTML = '<option value="">All</option>'; // Reset options
                        data.pos_ids.forEach(posId => {
                            const option = document.createElement("option");
                            option.value = posId;
                            option.textContent = posId;
                            posIDSelect.appendChild(option);
                        });
                        if (data.pos_ids.length === 1) {
                            // If there's only one matching ID, select it automatically
                            posIDSelect.value = data.pos_ids[0];
                        }
                    }
                })
                .catch(error => console.error("Error fetching POS IDs:", error))
                .finally(() => isPosNameUpdating = false);
        }
    }

    // Event listener for POS ID selection change
    // Triggers fetching and updating of POS Names dropdown when POS ID changes.
    posIDSelect.addEventListener("change", function () {
        const selectedPosId = posIDSelect.value;
        if (selectedPosId) {
            fetchPosNames(selectedPosId);  // Fetch POS Names based on POS ID
        }
    });

    // Event listener for POS Name selection change
    // Triggers fetching and updating of POS IDs dropdown when POS Name changes.
    posNameSelect.addEventListener("change", function () {
        const selectedPosName = posNameSelect.value;
        if (selectedPosName) {
            fetchPosNumbers(selectedPosName);  // Fetch POS Numbers based on POS Name
        }
    });

    // Fetch and display tasks based on filter and pagination
    // This function sends a POST request to the server with the current filters
    // and renders the tasks in the table based on the response.
    function fetchAndDisplayTasks(data, page = 1) {
        console.log("Sending data to server:", data);

        data.page = page; // Include the current page number

        fetch("/filter_tasks", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data),
        })
        .then(response => response.json())
        .then(data => {
            console.log("Received data:", data);

            taskTableBody.innerHTML = ""; // Clear the table body

            if (data.tasks && data.tasks.length > 0) {
                // Iterate through the tasks and append them to the table
                data.tasks.forEach(task => {
                    const row = `
                    <tr>
                        <td>${task.task_id || 'n/a'}</td>
                        <td>${task.pos_id || 'n/a'}</td>
                        <td>${task.pos_name || 'n/a'}</td>
                        <td>${task.rec_date || 'n/a'}</td>
                        <td>${task.rec_certified || 'n/a'}</td>
                        <td>${task.task_desc || 'n/a'}</td>
                        <td>${task.task_status || 'n/a'}</td>
                        <td>${task.task_priority || 'n/a'}</td>
                        <td>${task.blocker_desc || 'n/a'}</td>
                        <td>${task.blocker_responsible || 'n/a'}</td>
                        <td>${task.task_start_date || 'n/a'}</td>
                        <td>${task.task_due_date || 'n/a'}</td>
                        <td>${task.task_notes || 'n/a'}</td>
                    </tr>`;
                    taskTableBody.innerHTML += row;
                });
                console.log("Tasks rendered successfully.");
                updatePaginationControls(data.page, data.total_pages); // Update pagination controls
            } else {
                taskTableBody.innerHTML = "<tr><td colspan='13'>No tasks found</td></tr>";
            }
        })
        .catch(error => console.error("Error fetching tasks:", error));
    }

    // Event listener for the Filter button
    // Triggers a fetch request to get tasks based on the current filter criteria.
    filterBtn.addEventListener("click", function () {
        currentPage = 1; // Reset to the first page on new filter
        const data = collectFilterData();
        fetchAndDisplayTasks(data, currentPage);
    });

    // Collect filter data from inputs
    // Collects data from all filter inputs to be sent to the server for task filtering.
    function collectFilterData() {
        const posID = posIDSelect.value;
        const posName = posNameSelect.value;
        const searchQuery = taskSearchInput.value;
        const startDate = startDateInput.value !== todayDate ? startDateInput.value : null;
        const endDate = endDateInput.value !== todayDate ? endDateInput.value : null;
        const selectedStatuses = getSelectedCheckboxValues("input[id^='status']");
        const selectedPriorities = getSelectedCheckboxValues("input[id^='priority']");

        return {
            pos_id: posID,
            pos_name: posName,
            search_query: searchQuery,
            start_date: startDate,
            end_date: endDate,
            statuses: selectedStatuses,
            priorities: selectedPriorities
        };
    }

    // Event listener for the search input field (dynamic filtering)
    // This provides real-time filtering as the user types in the search field.
    taskSearchInput.addEventListener("input", function () {
        currentPage = 1; // Reset to the first page on new search
        const data = collectFilterData();
        fetchAndDisplayTasks(data, currentPage);
    });

    // Event listener for the Clear Filter button
    // Clears all filters and resets the table to show all tasks.
    clearFilterBtn.addEventListener("click", function () {
        posIDSelect.value = "";
        posNameSelect.value = "";
        taskSearchInput.value = "";
        setDateInputPlaceholders();

        document.querySelectorAll("input[id^='status'], input[id^='priority']").forEach(checkbox => {
            checkbox.checked = false;
        });

        // Reset POS names and IDs
        fetchAllPosNamesAndIds();

        // Fetch tasks without any filters
        currentPage = 1; // Reset to the first page
        fetchAndDisplayTasks({}, currentPage);
    });

    // Initial fetch when the page loads
    fetchAndDisplayTasks({}, currentPage);

    // Update pagination controls
    // This function updates the pagination controls based on the current page and total pages.
    function updatePaginationControls(currentPage, totalPages) {
        paginationContainer.innerHTML = ""; // Clear existing controls

        // Previous link
        if (currentPage > 1) {
            const prevLink = document.createElement("a");
            prevLink.href = "#";
            prevLink.textContent = "Previous";
            prevLink.style.fontSize = "0.85em"; // Smaller font size
            prevLink.style.marginRight = "10px"; // Add some spacing
            prevLink.addEventListener("click", function (event) {
                event.preventDefault(); // Prevent default anchor behavior
                currentPage--;
                fetchAndDisplayTasks(collectFilterData(), currentPage);
            });
            paginationContainer.appendChild(prevLink);
        }

        // Page info
        const pageInfo = document.createElement("span");
        pageInfo.textContent = ` Page ${currentPage} of ${totalPages} `;
        pageInfo.style.fontSize = "0.85em"; // Smaller font size
        paginationContainer.appendChild(pageInfo);

        // Next link
        if (currentPage < totalPages) {
            const nextLink = document.createElement("a");
            nextLink.href = "#";
            nextLink.textContent = "Next";
            nextLink.style.fontSize = "0.85em"; // Smaller font size
            nextLink.style.marginLeft = "10px"; // Add some spacing
            nextLink.addEventListener("click", function (event) {
                event.preventDefault(); // Prevent default anchor behavior
                currentPage++;
                fetchAndDisplayTasks(collectFilterData(), currentPage);
            });
            paginationContainer.appendChild(nextLink);
        }
    }
});



--- Directory: ./core/templates ---

File: create.html
----------------------------
{# 
    Filename: create.html
    Developed by: Stefania Galatolo, assisted by ChatGPT 4o
    Description: 
    This template renders the "Create Task" page, providing an interface for the user to create a new task 
    and view the existing tasks in a tabular format. It extends the base layout (`layout.html`) and incorporates 
    several reusable components using Jinja2's include functionality.
    
    Collaboration Note: 
    If you're wondering how this magic happened, Stefania got by with a little help from ChatGPT 4o. Because who knew 
    rendering HTML could be such a party? Remember, friends don't let friends code alone.

    Template Structure:
    - Extends the base layout from "layout.html".
    - Sets the page title to "Create Task".
    - Renders the main content block which consists of:
        1. Sidebar: Includes "_sidebar.html" for displaying filter options.
        2. Main Content Area:
            - Header: Displays the title "Create Task".
            - Task Creation Form: Includes "_create_form.html" to provide the form for creating new tasks.
            - Tasks Table: Includes "_tasks_body.html" to render the current list of tasks in a table format.
    
    Correlations:
    - "_sidebar.html": Provides filter options, allowing users to interactively narrow down the displayed tasks.
    - "_create_form.html": Contains the form to create new tasks. When submitted, the form data is sent to the server 
      to create a new task entry in the database.
    - "_tasks_body.html": Displays a table of all current tasks. This template shows the task list without filters, 
      giving a straightforward overview of the tasks.

    Flow:
    1. User lands on the "Create Task" page.
    2. The sidebar is displayed on the left for filtering tasks.
    3. The main content area shows the task creation form at the top.
    4. Below the form, a table lists all tasks, allowing the user to see what tasks already exist.
#}

{% extends "layout.html" %}

{% block title %}
    Create Task
{% endblock %}

{% block main %}
<div class="container-fluid">
    <div class="row">
        <!-- Sidebar -->
        <div class="col-md-3">
            {% include "_sidebar.html" %} <!-- Include sidebar for filters right after the navbar -->
        </div>

        <!-- Main Content Area -->
        <div class="col-md-9">
            <h1>Create Task</h1>

            <!-- Include Create Task Form -->
            {% include "_create_form.html" %}
            
            <hr>

            <!-- All Tasks Table -->            
            {% include "_tasks_body.html" %} <!-- Only includes the tasks table, no filters -->
        </div>
    </div>
</div>
{% endblock %}



File: error.html
----------------------------
{# 
    File: error.html
    Developed by Stefania Galatolo, assisted by ChatGPT 4o, the code wizard who kept Stefania from tearing her hair out. Who knew error handling could be this much fun?
    
    ### Description:
    - This template is used to display error messages in the web application.
    - It extends the base layout (`layout.html`), inheriting the common structure and styling.
    - The `message` variable is passed to this template from the Flask route handling errors, allowing dynamic error messages to be displayed.
    
    ### Inputs:
    - `message`: A string passed from the server, containing the error message to be displayed.
    
    ### Outputs:
    - Renders an HTML page with an error message and a "Go Home" button for navigation.
    
    ### Flow:
    1. Inherits the layout from `layout.html`.
    2. Overrides the `title` block to set the page title to "Error".
    3. Overrides the `main` block to include the error message and a navigation button.
    #}
    
    {% extends "layout.html" %}
    
    {% block title %}
        Error
    {% endblock %}
    
    {% block main %}
    <div class="text-center mb-3">
        <div>
            <h1>Error</h1>
            <p>{{ message }}</p> {# Displays the error message passed from the Flask route #}
            <a href="/" class="btn btn-primary">Go Home</a> {# Button to navigate back to the home page #}
        </div>
    </div>
    {% endblock %}
    


File: kanban.html
----------------------------
<!-- kanban.html -->
{# 
    File: kanban.html
    Description: This is the main HTML template for the Kanban board feature in the task management application. 
    The template extends 'layout.html', providing a structured view of tasks categorized into different statuses 
    (e.g., Backlog, To Do, In Progress, Done) in a visual drag-and-drop board. The Kanban board is essential for 
    offering users an intuitive way to track and manage tasks through various stages of completion.

    Inputs: 
    - Extends the 'layout.html' file, which provides the common structure including header, footer, and navigation.
    - Includes '_sidebar.html' for filtering options and task navigation.
    - Includes '_kanban_board.html' for the actual Kanban board layout and task cards.

    Outputs:
    - Renders a full-page Kanban board within the layout defined in 'layout.html'.
    - Displays a sidebar with filtering options and a main section with the Kanban board.
    
    Dependencies and Correlations:
    - Depends on 'layout.html' for the overall page structure, ensuring consistent UI/UX across the application.
    - Uses '_sidebar.html' to incorporate filtering and navigation, allowing users to filter tasks displayed on the Kanban board.
    - Uses '_kanban_board.html' to render the Kanban board where tasks are categorized and can be moved between columns.
    
    Collaboration Note: 
    - Developed by Stefania Galatolo, with invaluable assistance from ChatGPT 4.0. In an unexpected twist of fate, ChatGPT became the Kanban master while Stefania heroically fought against endless divs and CSS classes. Together, they transformed chaos into a streamlined task management board.
#}

{% extends "layout.html" %}

{% block title %}
    Kanban Board
{% endblock %}

{% block main %}
<div class="container-fluid">
    <div class="row">
        <!-- Sidebar Section -->
        <div class="col-md-3">
            {# 
                This section includes the sidebar from '_sidebar.html'. 
                - The sidebar provides filtering options to allow users to filter tasks displayed on the Kanban board.
                - Filters might include options such as task priority, status, and POS ID, enhancing user experience by offering targeted task management.
                - The sidebar is rendered in a Bootstrap column (3 columns wide out of 12) for a responsive layout.
            #}
            {% include '_sidebar.html' %}
        </div>

        <!-- Kanban Board Section -->
        <div class="col-md-9">
            {# 
                This section includes the actual Kanban board from '_kanban_board.html'.
                - The Kanban board displays tasks in different columns based on their status.
                - Each task is rendered as a card that can be dragged and dropped between columns, allowing users to change the status of tasks interactively.
                - The board is responsive and rendered in a Bootstrap column (9 columns wide out of 12), occupying the main area of the page.
            #}
            {% include '_kanban_board.html' %}
        </div>
    </div>
</div>
{% endblock %}



File: layout.html
----------------------------
<!-- 
    TaskFlow Project - Final Project for CS50 by Harvard EdX 2024
    Developed by Stefania Galatolo, assisted (and occasionally rescued) by ChatGPT-4o.

    This file defines the base layout for the TaskFlow web application. It includes the main structure of the HTML page, 
    including the navigation bar, flash message display, and footer. Each page of the app inherits from this layout template 
    and injects its specific content where blocks are defined (e.g., the main content area and page title).

    The humor in this header reflects the journey of Stefania developing this project with the indispensable assistance of ChatGPT.
    Stefania could not have done this alone—ChatGPT's infinite wisdom and some Bootstrap magic saved the day!

    Main functions of this layout:
    - Provides a navigation bar with links that adjust based on user session status (logged in or logged out).
    - Renders the appropriate flash messages if any are generated (e.g., after successful log in or an error).
    - Includes a container for dynamic page content, allowing pages to inject their own specific content within the defined block.
    - Uses Bootstrap 5 for responsive design and easy styling.

    Inputs: 
    - Session variable `user_id` to determine if a user is logged in.
    - Flash messages through Flask's `get_flashed_messages` for error/success alerts.

    Outputs: 
    - A responsive navigation bar, dynamic content injection for individual pages, flash message display, and a footer.

    Other Files:
    - This file relies on external CSS (Bootstrap and custom styles) and JS files loaded through CDNs and Flask's static file structure.
    - The `url_for` function is used to link static assets (favicon, CSS) and dynamically inject the page's title and main content.
-->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, width=device-width">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

    <!-- Favicon -->
    <link rel="icon" type="image/webp" href="{{ url_for('static', filename='images/favicon.webp') }}">

    <!-- Custom styles -->
    <link href="{{ url_for('static', filename='css/style.css') }}" rel="stylesheet">

    <!-- Dynamic title block to be filled by individual pages -->
    <title>TaskFlow: {% block title %}{% endblock %}</title>
</head>

<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-md navbar-light bg-light border">
        <div class="container-fluid">
            <!-- TaskFlow brand -->
            <a class="navbar-brand" href="/"><span class="blue">Task</span><span class="red">Flow</span></a>
            <!-- Toggler for small screens -->
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <!-- Navigation links, adjusting based on user login status -->
            <div class="collapse navbar-collapse" id="navbar">
                {% if session["user_id"] %}
                    <ul class="navbar-nav me-auto mt-2">
                        <li class="nav-item"><a class="nav-link" href="/tasks">Tasks</a></li>
                        <li class="nav-item">
                            <!-- Switched to button style for Kanban link -->
                            <a class="btn btn-primary" href="/kanban">Kanban</a>
                        </li>
                        <li class="nav-item"><a class="nav-link" href="/create">Create</a></li>
                        <li class="nav-item"><a class="nav-link" href="/modify">Modify</a></li>
                    </ul>
                    <ul class="navbar-nav ms-auto mt-2">
                        <li class="nav-item"><a class="nav-link" href="/logout">Log Out</a></li>
                    </ul>
                {% else %}
                    <ul class="navbar-nav ms-auto mt-2">
                        <li class="nav-item"><a class="nav-link" href="/register">Register</a></li>
                        <li class="nav-item"><a class="nav-link" href="/login">Log In</a></li>
                    </ul>
                {% endif %}
            </div>
        </div>
    </nav>

    <!-- Flash messages (alerts for user actions) -->
    {% if get_flashed_messages() %}
        <header>
            <div class="alert alert-warning text-center mb-0" role="alert">
                {% for message in get_flashed_messages() %}
                    {{ message }}
                {% endfor %}
            </div>
        </header>
    {% endif %}

    <!-- Main content area where individual page content will be injected -->
    <main class="container py-5 text-center">
        {% block main %}{% endblock %}
    </main>

    <!-- Footer with small text -->
    <footer class="mb-5">
        <p class="mb-3 small text-center text-muted">
            &copy; 2024 TaskFlow
        </p>
    </footer>

    <!-- Bootstrap JS for interactivity (uses Bootstrap's CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
</body>

</html>



File: login.html
----------------------------
{% extends "layout.html" %}

{# 
    Log In Page Template
    Developed by Stefania Galatolo, with assistance from ChatGPT 4.0. Let's say Stefania is the brains, and ChatGPT is the assistant who brings all the fancy ideas to life. A classic "Stefania & ChatGPT" collaboration!

    This template is responsible for rendering the Log In page of the web application. It extends from the 'layout.html' file, which serves as the base template for all pages. The login form includes fields for the username and password and submits the data using the POST method to the '/login' route in the Flask application.

    Inputs:
    - Username: A text input field where the user enters their username.
    - Password: A password input field where the user enters their password.

    Outputs:
    - Redirects to the '/login' route when the form is submitted. The server processes the data, authenticates the user, and responds accordingly.

    Correlation with Other Files:
    - This template extends 'layout.html', utilizing the base layout to maintain consistent styling and structure across the application.
    - The form action points to the '/login' route defined in the 'app.py' file, where the login logic is implemented.
#}

{% block title %}
    Log In
{% endblock %}

{% block main %}
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-md-3">
                <h1 class="text-center mb-3">Log In</h1>
                {# 
                    Login Form
                    This form collects the user's username and password. It sends a POST request to the '/login' route in the server, where user authentication is handled.

                    Form Details:
                    - Action: '/login' (route in the Flask application)
                    - Method: POST (sends form data securely to the server)
                    - Input Fields:
                        - Username: Text input for the user's username. Autofocus is set for better UX.
                        - Password: Password input for secure entry. The field is masked for security.

                    On successful login, the user is typically redirected to the home page or the tasks page, depending on the application logic in 'app.py'.
                #}
                <form action="/login" method="post">
                    <div class="mb-2">
                        <input autocomplete="off" autofocus class="form-control" name="username" placeholder="Username" type="text">
                    </div>
                    <div class="mb-2">
                        <input class="form-control" name="password" placeholder="Password" type="password">
                    </div>
                    <div class="text-center">
                        <button class="btn btn-primary" type="submit">Log In</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
{% endblock %}



File: modify.html
----------------------------
{% extends "layout.html" %}

{# 
    File: modify.html 
    Author: Stefania Galatolo, with a little help from ChatGPT 4o (because even wizards need a sidekick sometimes).
    
    Overview:
    - This template is part of the task management web app.
    - It's used to render the "Modify Task" page, which allows users to modify an existing task.
    - The page layout is divided into two main sections:
        1. Sidebar: For task filtering options.
        2. Main Content Area: For task modification and task list display.
    - This file interacts with several other components:
        - Extends `layout.html` to maintain a consistent look and feel across the app.
        - Includes `_sidebar.html` for task filtering options.
        - Includes `_modify_form.html` which contains the form to modify a task.
        - Includes `_tasks_body.html` to display a table of all tasks.
    
    Inputs:
    - This template does not directly accept user input but interacts with user inputs via the included `_modify_form.html`.
    
    Outputs:
    - Displays a form to modify task details and a table listing all current tasks.
    
    Correlation with Other Files:
    - The modifications submitted via the form in `_modify_form.html` are processed by the Flask route handling task modification (typically using a POST request).
    - `_tasks_body.html` dynamically displays tasks fetched from the database.
    - `layout.html` provides the overall page structure and common elements like the navbar.
    
    Flow:
    1. User navigates to the "Modify Task" page.
    2. Sidebar allows for filtering tasks (filters defined in `_sidebar.html`).
    3. User selects a task to modify via the form (`_modify_form.html`).
    4. User submits the form, which sends the modification to the server for processing.
    5. The task table (`_tasks_body.html`) displays the updated task list.
#}

{% block title %}
    Modify Task
{% endblock %}

{% block main %}
<div class="container-fluid">
    <div class="row">
        <!-- Sidebar -->
        <div class="col-md-3">
            {% include "_sidebar.html" %} <!-- Include sidebar for filters right after the navbar -->
        </div>

        <!-- Main Content Area -->
        <div class="col-md-9">
            <h1>Modify Task</h1>

            <!-- Include Modify Task Form -->
            {% include "_modify_form.html" %}
            
            <hr>

            <!-- All Tasks Table -->            
            {% include "_tasks_body.html" %} <!-- Only includes the tasks table, no filters -->
        </div>
    </div>
</div>
{% endblock %}



File: register.html
----------------------------
{# 
    File: register.html
    Author: Stefania Galatolo, assisted by ChatGPT 4o
    Description:
    - This HTML template is responsible for rendering the registration page for new users.
    - The page extends the base layout defined in "layout.html" and includes form elements
      for user input, such as username and password fields.
    - The form data is sent to the server using a POST request to the "/register" route.
    - The inputs include:
        * `username` - A unique identifier for the user.
        * `password` - The user's password (stored securely on the server).
        * `confirmation` - Confirmation of the password to ensure it matches the first input.
    - This template works closely with the `app.py` Flask route `/register`, which handles
      user registration by validating the form data, checking for username availability, 
      and securely storing user credentials.
    - It relies on the Bootstrap framework for responsive design and styling.

    Collaboration Note:
    - Developed by Stefania Galatolo with assistance from ChatGPT 4o.
    - Despite Stefania's initial struggle with HTML forms, ChatGPT 4o lent its expertise to
      ensure the form properly submits user data. No worries, Stefania – even the best coders
      need a digital sidekick now and then!
#}

{% extends "layout.html" %} {# Extending the base template to maintain a consistent layout across the app #}

{% block title %}
    Register
{% endblock %} {# Setting the page title to "Register" #}

{% block main %}
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-md-3">
                <h1 class="text-center mb-3">Register</h1>
                <form action="/register" method="post"> {# The form sends a POST request to the "/register" route #}
                    <div class="mb-2">
                        <input autocomplete="off" autofocus class="form-control" name="username" placeholder="Username" type="text">
                        {# Username field: captures the username, ensures it's unique on submission #}
                    </div>
                    <div class="mb-2">
                        <input class="form-control" name="password" placeholder="Password" type="password">
                        {# Password field: captures the user's password securely (in plaintext here, hashed on the server) #}
                    </div>
                    <div class="mb-2">
                        <input class="form-control" name="confirmation" placeholder="Confirm Password" type="password">
                        {# Confirmation field: ensures user inputs the correct password twice to avoid errors #}
                    </div>
                    <div class="text-center">
                        <button class="btn btn-primary" type="submit">Register</button>
                        {# Submit button: submits the form data to the server for processing #}
                    </div>
                </form>
            </div>
        </div>
    </div>
{% endblock %}



File: tasks.html
----------------------------
{# 
    File: tasks.html
    Developed by: Stefania Galatolo, with a bit of (much needed) magical assistance from ChatGPT 4.0 
    (because even the best developers need a little AI help sometimes 😅).

    Description:
    This template extends 'layout.html' and is responsible for rendering the main tasks page of the web application.
    It is structured into two main sections:
    1. Sidebar Section: Includes a sidebar for filtering and navigating through the tasks. 
       This is included from the '_sidebar.html' partial template.
    2. Tasks Table Section: Displays the tasks in a structured table format.
       This section is included from the '_tasks_body.html' partial template.
    The main purpose of this template is to provide an interactive and organized view of all tasks,
    leveraging Bootstrap for responsive design. 

    Inputs:
    - None directly from this template. However, it relies on the '_sidebar.html' and '_tasks_body.html' 
      for their respective functionalities, such as filtering options and task display.

    Outputs:
    - Renders a responsive tasks page layout with a sidebar and a tasks table section.
    - The filtering actions in the sidebar will dynamically update the task list displayed in the tasks table section.

    Correlations with Other Files:
    - '_sidebar.html': Included for filtering tasks. This template contains various filtering options to help the user 
      refine the task list based on different criteria like POS, status, and priority.
    - '_tasks_body.html': Included for displaying the task list. It fetches and displays tasks in a structured table 
      format, providing a detailed view of each task's attributes.
    - 'layout.html': The base template which this template extends. It provides the overall structure and common elements 
      (like navigation bar and footer) for the page.
    
    Flow:
    1. The layout provided by 'layout.html' is extended to maintain a consistent design across the application.
    2. Within the 'main' block, the page is divided into two main sections using Bootstrap's grid system.
       a. The left section includes the sidebar, which allows users to filter tasks.
       b. The right section displays the tasks in a table format, updating based on the filters applied in the sidebar.
#}

{% extends "layout.html" %}

{% block main %}
<div class="container-fluid">
    <div class="row">
        <!-- Sidebar Section -->
        <div class="col-md-3">
            {% include '_sidebar.html' %}
        </div>

        <!-- Tasks Table Section -->
        <div class="col-md-9">
            {% include '_tasks_body.html' %}
        </div>
    </div>
</div>
{% endblock %}



File: _create_form.html
----------------------------
<!-- 
    File: create_task_form.html
    Developer: Stefania Galatolo, with ChatGPT's brilliant code insights.
    Description: This HTML file defines the form for creating a new task in the task management app.
    Stefania brought her coding A-game, but when the form needed some pizzazz, ChatGPT was there with the assists!

    Purpose:
    - This form enables users to input all necessary details for a new task, ensuring comprehensive task creation.
    - Captures information ranging from basic identifiers like POS Name and POS ID to detailed attributes such as task descriptions, dates, and blockers.
    
    Inputs Collected:
    - **POS Name and POS ID**: Identifies the Point of Sale related to the task, linking it to specific POS data.
    - **Reconciliation Date**: Records the date for financial reconciliation, defaulting to today's date.
    - **Certified**: Boolean value indicating if the task is certified (Yes/No).
    - **Status**: Current stage of the task, with options such as Backlog, To Do, In Progress, Done.
    - **Priority**: Indicates task urgency, with options including None, Low, Medium, High.
    - **Start Date and Due Date**: Define the timeline for handling the task, both defaulting to the current date.
    - **Description**: A text field for a detailed explanation of the task.
    - **Blocker Description and Responsible**: Capture any hindrances to task progress and who is responsible for resolving them.
    - **Additional Notes**: Provides space for any other pertinent information.

    Flow:
    - The user interacts with the form, selecting values and filling out necessary fields.
    - Upon submission, the form data is sent via a POST request to the "/create" route in the Flask app.
    - The server processes this data, inserts a new task record into the SQL database, and returns a response.
    - The accompanying JavaScript file 'createTasks.js' manages dynamic client-side functionalities, such as form validation or user feedback.

    Interactions with Other Files:
    - **`createTasks.js`**: Enhances form interactivity, handles client-side validation, and possibly manages dynamic field updates.
    - **Flask backend (`/create` route)**: Receives and processes the form data, storing it in the database and providing user feedback.
    - **SQL Database**: The data collected by this form is inserted into the relevant database table, contributing to the task records displayed elsewhere in the app (e.g., Kanban board, task list).
-->

<!-- Create Task Form -->
<form id="createTaskForm" method="POST" action="/create">
    <div class="container-fluid">
        <div class="row">
            <!-- Column 1: POS Information -->
            <div class="col-md-4">
                <!-- POS Name Selection -->
                <div class="mb-3">
                    <label for="pos_name" class="form-label">POS Name:</label>
                    <!-- Dropdown to select POS Name. Values are dynamically populated from the 'pos_data' passed in the Flask context -->
                    <select id="pos_name" class="form-control" name="pos_name" required>
                        <option value="" disabled selected>Select POS Name</option>
                        {% for pos in pos_data %}
                            <option value="{{ pos['pos_name'] }}" data-pos-id="{{ pos['pos_id'] }}">{{ pos['pos_name'] }}</option>
                        {% endfor %}
                    </select>
                </div>

                <!-- POS ID Selection -->
                <div class="mb-3">
                    <label for="pos_id" class="form-label">POS ID:</label>
                    <!-- Dropdown to select POS ID. This value correlates with the POS Name selected and ensures proper data association -->
                    <select id="pos_id" class="form-control" name="pos_id" required>
                        <option value="" disabled selected>Select POS ID</option>
                        {% for pos in pos_data %}
                            <option value="{{ pos['pos_id'] }}" data-pos-name="{{ pos['pos_name'] }}">{{ pos['pos_id'] }}</option>
                        {% endfor %}
                    </select>
                </div>

                <!-- Reconciliation Date -->
                <div class="mb-3">
                    <label for="reconciliation_date" class="form-label">Reconciliation Date:</label>
                    <!-- Date input for reconciliation date, defaults to today's date to streamline user experience -->
                    <input id="reconciliation_date" class="form-control" name="reconciliation_date" type="date" value="{{ date.today().strftime('%Y-%m-%d') }}">
                </div>

                <!-- Certified -->
                <div class="mb-3">
                    <label class="form-label">Certified:</label>
                    <!-- Radio buttons to select if the task is certified. Provides binary choice between 'Yes' or 'No' -->
                    <div>
                        <input type="radio" id="certified_yes" name="certified" value="true">
                        <label for="certified_yes">Yes</label>
                    </div>
                    <div>
                        <input type="radio" id="certified_no" name="certified" value="false">
                        <label for="certified_no">No</label>
                    </div>
                </div>
            </div>

            <!-- Column 2: Task Details -->
            <div class="col-md-4">
                <!-- Status Radio Buttons -->
                <div class="mb-3">
                    <label class="form-label">Status:</label>
                    <!-- Radio buttons for task status selection. Allows users to specify the current stage of the task -->
                    <div>
                        <input type="radio" id="statusBacklog" name="status" value="Backlog">
                        <label for="statusBacklog">Backlog</label>
                    </div>
                    <div>
                        <input type="radio" id="statusToDo" name="status" value="To Do">
                        <label for="statusToDo">To Do</label>
                    </div>
                    <div>
                        <input type="radio" id="statusInProgress" name="status" value="In Progress">
                        <label for="statusInProgress">In Progress</label>
                    </div>
                    <div>
                        <input type="radio" id="statusDone" name="status" value="Done">
                        <label for="statusDone">Done</label>
                    </div>
                </div>

                <!-- Priority Radio Buttons -->
                <div class="mb-3">
                    <label class="form-label">Priority:</label>
                    <!-- Radio buttons for task priority selection, categorizing the urgency of the task -->
                    <div>
                        <input type="radio" id="priorityNone" name="priority" value="None">
                        <label for="priorityNone">None</label>
                    </div>
                    <div>
                        <input type="radio" id="priorityLow" name="priority" value="Low">
                        <label for="priorityLow">Low</label>
                    </div>
                    <div>
                        <input type="radio" id="priorityMedium" name="priority" value="Medium">
                        <label for="priorityMedium">Medium</label>
                    </div>
                    <div>
                        <input type="radio" id="priorityHigh" name="priority" value="High">
                        <label for="priorityHigh">High</label>
                    </div>
                </div>

                <!-- Start Date -->
                <div class="mb-3">
                    <label for="start_date" class="form-label">Start Date:</label>
                    <!-- Date input for task start date. By default, it suggests today's date to facilitate immediate task scheduling -->
                    <input id="start_date" class="form-control" name="start_date" type="date" value="{{ date.today().strftime('%Y-%m-%d') }}">
                </div>

                <!-- Due Date -->
                <div class="mb-3">
                    <label for="due_date" class="form-label">Due Date:</label>
                    <!-- Date input for task due date. Helps set a deadline for the task completion -->
                    <input id="due_date" class="form-control" name="due_date" type="date" value="{{ date.today().strftime('%Y-%m-%d') }}">
                </div>
            </div>

            <!-- Column 3: Descriptions and Notes -->
            <div class="col-md-4">
                <!-- Task Description -->
                <div class="mb-3">
                    <label for="description" class="form-label">Task Description:</label>
                    <!-- Text area for a detailed task description. Provides an opportunity to elaborate on the task’s requirements -->
                    <textarea id="description" class="form-control" name="description"></textarea>
                </div>

                <!-- Blocker Description -->
                <div class="mb-3">
                    <label for="blocker_desc" class="form-label">Blocker Description:</label>
                    <!-- Text area for any blockers related to the task. Describes issues that may impede task progress -->
                    <textarea id="blocker_desc" class="form-control" name="blocker_desc"></textarea>
                </div>

                <!-- Blocker Responsible -->
                <div class="mb-3">
                    <label for="blocker_responsible" class="form-label">Blocker Responsible:</label>
                    <!-- Text area to specify who is responsible for resolving the blocker. Clarifies accountability for issue resolution -->
                    <textarea id="blocker_responsible" class="form-control" name="blocker_responsible"></textarea>
                </div>

                <!-- Additional Notes -->
                <div class="mb-3">
                    <label for="notes" class="form-label">Additional Notes:</label>
                    <!-- Text area for any additional notes. Allows the user to add any extra information or context -->
                    <textarea id="notes" class="form-control" name="notes"></textarea>
                </div>
            </div>
        </div>

        <!-- Submit Button -->
        <button class="btn btn-primary" type="submit">Create Task</button>
    </div>
</form>

<!-- Include the JavaScript file for create functionality -->
<script src="{{ url_for('static', filename='js/createTasks.js') }}"></script>



File: _kanban_board.html
----------------------------
<!-- 
    Filename: kanban.html
    Developed by Stefania Galatolo, with a sprinkle of magic from ChatGPT 4o.
    Description:
    - This file defines the Kanban board interface for the task management application.
    - It creates a visual board with four columns: Backlog, To Do, In Progress, and Done.
    - Tasks will be dynamically populated into these columns based on their status in the database.
    - Includes a "Due Today" button for filtering tasks that are due today.
    - Integrates with Sortable.js to provide drag-and-drop functionality for task cards.
    - References an external JavaScript file ('kanban.js') that contains the logic for dynamic rendering and updating of tasks.
    
    Interactions:
    - The board relies on the JavaScript file 'kanban.js' to handle:
        * Fetching tasks from the server using AJAX.
        * Populating the columns with task data.
        * Implementing drag-and-drop to move tasks between columns and update their status.
        * Filtering tasks due today when the "Due Today" button is clicked.
    - Sortable.js library is included for enhancing user interaction through drag-and-drop.
    - The tasks data is initially fetched from the server-side Flask route and rendered dynamically into each column.
    - Updates made on the board are sent back to the server to persist the changes in the database.
    
    Usage:
    - The user can interact with the Kanban board by dragging task cards between columns.
    - Clicking the "Due Today" button filters and displays tasks that have a due date set for today.
    - This template is part of the front-end interface and is essential for providing a visual representation of task statuses.

    Inputs:
    - Task data fetched from the server using JavaScript (from the database).
    
    Outputs:
    - Dynamic visual representation of tasks within the Kanban board columns.
    - Sends updates to the server when tasks are moved between columns.
-->

<h1 class="mb-4">Kanban Board</h1>

<!-- "Due Today" button: Filters tasks to show only those due today -->
<button id="dueTodayBtn" class="btn btn-primary mb-3">Due Today</button>

<!-- Kanban Board Columns: Contains four columns to categorize tasks based on their status -->
<div class="row mt-4 kanban-board">
    <!-- Backlog Column: Displays tasks that are not yet started -->
    <div class="col-lg-3 kanban-column" id="backlog">
        <label class="form-label">Backlog</label>
        <!-- Backlog tasks will be dynamically populated here via JavaScript -->
    </div>
    <!-- To Do Column: Displays tasks that are ready to be worked on -->
    <div class="col-lg-3 kanban-column" id="todo">
        <label class="form-label">To Do</label>
        <!-- To Do tasks will be dynamically populated here via JavaScript -->
    </div>
    <!-- In Progress Column: Displays tasks currently being worked on -->
    <div class="col-lg-3 kanban-column" id="inprogress">
        <label class="form-label">In Progress</label>
        <!-- In Progress tasks will be dynamically populated here via JavaScript -->
    </div>
    <!-- Done Column: Displays tasks that have been completed -->
    <div class="col-lg-3 kanban-column" id="done">
        <label class="form-label">Done</label>
        <!-- Done tasks will be dynamically populated here via JavaScript -->
    </div>
</div>

<!-- Include Sortable.js for enabling drag-and-drop functionality on the Kanban board -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
<!-- Reference to the custom JavaScript file for Kanban functionality 
    - This script handles:
      * Fetching and rendering tasks
      * Implementing drag-and-drop to update task statuses
      * Filtering tasks due today -->
<script src="{{ url_for('static', filename='js/kanban.js') }}"></script>



File: _modify_form.html
----------------------------
<!--
    File: modify_task_form.html
    Developed by: Stefania Galatolo, assisted by ChatGPT 4.0
    Description:
    This file contains the HTML form used for modifying an existing task within the application.
    Users can update various task attributes, such as POS Name, POS ID, reconciliation date, certification status,
    task status, priority, start date, due date, task description, blocker description, blocker responsible, and additional notes.

    Key Features:
    - Task ID input: Identifies the specific task to be modified.
    - POS Name and POS ID dropdowns: Allow selection of point-of-sale identifiers.
    - Various input fields and radio buttons for updating task properties.
    - The form submits a POST request to the '/modify' route, which should be handled server-side by Flask to update the task in the database.
    - It includes a JavaScript file 'modifyTasks.js' for handling any client-side interactivity or validation.

    Flow:
    - The user fills out the form fields.
    - On form submission, a POST request is sent to the server.
    - The server processes the data and updates the relevant task in the database.
    - Feedback is given to the user based on the success or failure of the operation.

    Correlations with Other Files:
    - modifyTasks.js: Provides client-side logic for the modify form.
    - app.py (Flask backend): Contains the route '/modify' that processes the form submission.
    - taskflow.db: The database where task updates are stored.
    - styles.css: May contain styles for the form and its elements.

    Note: This form relies on data passed from the Flask backend, such as 'pos_data', which should be available in the context where this template is rendered.
-->

<form id="modifyTaskForm" method="POST" action="/modify">
    <div class="container-fluid">
        <div class="row">
            <!-- Task ID Input -->
            <!--
                Input field for the unique Task ID.
                This ID is used to identify which task is being modified.
                It is required to match an existing task in the database.
            -->
            <div class="col-md-4">
                <div class="mb-3">
                    <label for="task_id" class="form-label" style="font-weight: bold; font-size: 1.2em;">Task ID:</label>
                    <input id="task_id" class="form-control" name="task_id" type="text" placeholder="Enter Task ID" required>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Column 1 -->
            <div class="col-md-4">
                <!-- POS Name Selection -->
                <!--
                    Dropdown for selecting the POS (Point of Sale) Name.
                    Dynamically populated using Flask's template rendering with data from 'pos_data'.
                    The selected POS Name is sent with the form data upon submission.
                -->
                <div class="mb-3">
                    <label for="pos_name" class="form-label">POS Name:</label>
                    <select id="pos_name" class="form-control" name="pos_name" required>
                        <option value="" disabled selected>Select POS Name</option>
                        {% for pos in pos_data %}
                            <option value="{{ pos['pos_name'] }}" data-pos-id="{{ pos['pos_id'] }}">{{ pos['pos_name'] }}</option>
                        {% endfor %}
                    </select>
                </div>

                <!-- POS ID Selection -->
                <!--
                    Dropdown for selecting the POS ID.
                    Correlates with the POS Name and is used to uniquely identify the POS in the database.
                    The selected POS ID is sent with the form data upon submission.
                -->
                <div class="mb-3">
                    <label for="pos_id" class="form-label">POS ID:</label>
                    <select id="pos_id" class="form-control" name="pos_id" required>
                        <option value="" disabled selected>Select POS ID</option>
                        {% for pos in pos_data %}
                            <option value="{{ pos['pos_id'] }}" data-pos-name="{{ pos['pos_name'] }}">{{ pos['pos_id'] }}</option>
                        {% endfor %}
                    </select>
                </div>

                <!-- Reconciliation Date -->
                <!--
                    Input for specifying the reconciliation date.
                    Defaults to the current date using Flask's 'date.today()' method.
                    Used to track when the task was last reconciled.
                -->
                <div class="mb-3">
                    <label for="reconciliation_date" class="form-label">Reconciliation Date:</label>
                    <input id="reconciliation_date" class="form-control" name="reconciliation_date" type="date" value="{{ date.today().strftime('%Y-%m-%d') }}">
                </div>

                <!-- Certified -->
                <!--
                    Radio buttons for selecting whether the task is certified.
                    Options are 'Yes' or 'No', representing a boolean value ('true' or 'false').
                    Helps in tracking the certification status of a task.
                -->
                <div class="mb-3">
                    <label class="form-label">Certified:</label>
                    <div>
                        <input type="radio" id="certified_yes" name="certified" value="true">
                        <label for="certified_yes">Yes</label>
                    </div>
                    <div>
                        <input type="radio" id="certified_no" name="certified" value="false">
                        <label for="certified_no">No</label>
                    </div>
                </div>
            </div>

            <!-- Column 2 -->
            <div class="col-md-4">
                <!-- Status Radio Buttons -->
                <!--
                    Radio buttons to set the task status.
                    Options include 'Backlog', 'To Do', 'In Progress', and 'Done'.
                    Used to indicate the current state of the task.
                -->
                <div class="mb-3">
                    <label class="form-label">Status:</label>
                    <div>
                        <input type="radio" id="statusBacklog" name="status" value="Backlog">
                        <label for="statusBacklog">Backlog</label>
                    </div>
                    <div>
                        <input type="radio" id="statusToDo" name="status" value="To Do">
                        <label for="statusToDo">To Do</label>
                    </div>
                    <div>
                        <input type="radio" id="statusInProgress" name="status" value="In Progress">
                        <label for="statusInProgress">In Progress</label>
                    </div>
                    <div>
                        <input type="radio" id="statusDone" name="status" value="Done">
                        <label for="statusDone">Done</label>
                    </div>
                </div>

                <!-- Priority Radio Buttons -->
                <!--
                    Radio buttons to set the priority level of the task.
                    Options include 'None', 'Low', 'Medium', and 'High'.
                    Helps in prioritizing tasks for better task management.
                -->
                <div class="mb-3">
                    <label class="form-label">Priority:</label>
                    <div>
                        <input type="radio" id="priorityNone" name="priority" value="None">
                        <label for="priorityNone">None</label>
                    </div>
                    <div>
                        <input type="radio" id="priorityLow" name="priority" value="Low">
                        <label for="priorityLow">Low</label>
                    </div>
                    <div>
                        <input type="radio" id="priorityMedium" name="priority" value="Medium">
                        <label for="priorityMedium">Medium</label>
                    </div>
                    <div>
                        <input type="radio" id="priorityHigh" name="priority" value="High">
                        <label for="priorityHigh">High</label>
                    </div>
                </div>

                <!-- Start Date -->
                <!--
                    Input for specifying the start date of the task.
                    Defaults to the current date using Flask's 'date.today()' method.
                    Used to track when the task is scheduled to begin.
                -->
                <div class="mb-3">
                    <label for="start_date" class="form-label">Start Date:</label>
                    <input id="start_date" class="form-control" name="start_date" type="date" value="{{ date.today().strftime('%Y-%m-%d') }}">
                </div>

                <!-- Due Date -->
                <!--
                    Input for specifying the due date of the task.
                    Defaults to the current date using Flask's 'date.today()' method.
                    Helps in tracking the deadline for the task's completion.
                -->
                <div class="mb-3">
                    <label for="due_date" class="form-label">Due Date:</label>
                    <input id="due_date" class="form-control" name="due_date" type="date" value="{{ date.today().strftime('%Y-%m-%d') }}">
                </div>
            </div>

            <!-- Column 3 -->
            <div class="col-md-4">
                <!-- Task Description -->
                <!--
                    Text area for entering a detailed description of the task.
                    Provides context and additional information about the task.
                -->
                <div class="mb-3">
                    <label for="description" class="form-label">Task Description:</label>
                    <textarea id="description" class="form-control" name="description"></textarea>
                </div>

                <!-- Blocker Description -->
                <!--
                    Text area for describing any blockers preventing task progress.
                    Used to identify and communicate obstacles that need resolution.
                -->
                <div class="mb-3">
                    <label for="blocker_desc" class="form-label">Blocker Description:</label>
                    <textarea id="blocker_desc" class="form-control" name="blocker_desc"></textarea>
                </div>

                <!-- Blocker Responsible -->
                <!--
                    Text area to specify the person responsible for the blocker.
                    Helps in assigning responsibility for resolving obstacles.
                -->
                <div class="mb-3">
                    <label for="blocker_responsible" class="form-label">Blocker Responsible:</label>
                    <textarea id="blocker_responsible" class="form-control" name="blocker_responsible"></textarea>
                </div>

                <!-- Additional Notes -->
                <!--
                    Text area for adding any additional notes or comments about the task.
                    Can include important details or reminders for the task.
                -->
                <div class="mb-3">
                    <label for="notes" class="form-label">Additional Notes:</label>
                    <textarea id="notes" class="form-control" name="notes"></textarea>
                </div>
            </div>
        </div>

        <!-- Modify Button -->
        <!--
            Button to submit the form data.
            Sends a POST request to the server to update the task with the new details.
        -->
        <button class="btn btn-primary" type="submit" id="modifyBtn">Modify</button>
    </div>
</form>

<!-- Include the JavaScript file for modify functionality -->
<!--
    Link to 'modifyTasks.js' for handling client-side interactivity.
    This script may include form validation, AJAX requests, or other dynamic functionalities.
-->
<script src="{{ url_for('static', filename='js/modifyTasks.js') }}"></script>



File: _sidebar.html
----------------------------
<!-- 
File: _sidebar.html (or similar, depending on where this is being included)
Author: Stefania Galatolo, assisted by ChatGPT 4o
---
This template is responsible for rendering the filter sidebar in the task management application. 
It provides the user interface elements for filtering tasks based on various criteria, such as POS number, POS name, status, priority, and date range.
These filters are essential for narrowing down the list of tasks displayed in the main task view. 
---
Inputs: 
    - `pos_data` (context variable): List of POS entries fetched from the database, each containing `pos_id` and `pos_name` for selection options.
Outputs:
    - Filtered task list based on user input through the filter options provided in this sidebar.
Correlations with Other Files:
    - This template is typically included in a larger layout or view, such as `tasks.html` or a similar file where task filtering is needed.
    - The filter options here interact with JavaScript functions (potentially in `tasksLookup.js`) to dynamically update the task display without reloading the page.
-->

<!-- Search Bar -->
<div class="filter-group mb-4"> <!-- Grouping for custom styling of the search bar -->
    <h2 class="filter-title">Filter</h2> <!-- Title for the filter section -->
    <label for="taskSearch" class="filter-label">Search Tasks:</label> <!-- Label for the search input field -->
    <!-- 
    Search Input: Allows users to search for tasks by a keyword.
    - ID: taskSearch
    - Class: form-control (Bootstrap class for styling)
    - Placeholder: Provides a hint to the user on what to enter.
    - Type: text (standard text input)
    -->
    <input id="taskSearch" class="form-control" placeholder="Search tasks..." type="text">
</div>

<!-- POS Group -->
<div class="filter-group mb-4"> <!-- Grouping for POS-related filters -->
    <label for="filterPosID" class="filter-label">POS Number:</label> <!-- Label for the POS Number filter -->
    <!-- 
    POS Number Dropdown: Allows filtering tasks by the POS ID.
    - ID: filterPosID
    - Class: form-select (Bootstrap class for styling)
    - Options: Populated dynamically with `pos_data` context variable
    - First Option: "All" to indicate no filtering
    -->
    <select id="filterPosID" class="form-select mb-2">
        <option value="">All</option> <!-- Default option to show all POS entries -->
        {% for pos in pos_data %}
        <!-- Looping through `pos_data` to populate the dropdown options -->
        <option value="{{ pos.pos_id }}">{{ pos.pos_id }}</option> <!-- Option value and display are set to `pos_id` -->
        {% endfor %}
    </select>

    <label for="filterPosName" class="filter-label">POS Name:</label> <!-- Label for the POS Name filter -->
    <!-- 
    POS Name Dropdown: Allows filtering tasks by the POS Name.
    - ID: filterPosName
    - Class: form-select (Bootstrap class for styling)
    - Options: Populated dynamically with `pos_data` context variable
    - First Option: "All" to indicate no filtering
    -->
    <select id="filterPosName" class="form-select">
        <option value="">All</option> <!-- Default option to show all POS entries -->
        {% for pos in pos_data %}
        <!-- Looping through `pos_data` to populate the dropdown options -->
        <option value="{{ pos.pos_name }}">{{ pos.pos_name }}</option> <!-- Option value and display are set to `pos_name` -->
        {% endfor %}
    </select>
</div>

<!-- Status Filters -->
<div class="filter-group mb-4"> <!-- Grouping for task status filters -->
    <label class="filter-label">Status:</label> <!-- Label for status filters -->
    <!-- 
    Status Checkboxes: Allows users to filter tasks by their current status.
    - Each checkbox has an ID corresponding to the status it represents.
    - Value: Set to the status that will be used for filtering.
    -->
    <div>
        <input type="checkbox" id="statusBacklog" value="Backlog"> Backlog
    </div>
    <div>
        <input type="checkbox" id="statusToDo" value="To Do"> To Do
    </div>
    <div>
        <input type="checkbox" id="statusInProgress" value="In Progress"> In Progress
    </div>
    <div>
        <input type="checkbox" id="statusDone" value="Done"> Done
    </div>
</div>

<!-- Priority Filters -->
<div class="filter-group mb-4"> <!-- Grouping for task priority filters -->
    <label class="filter-label">Priority:</label> <!-- Label for priority filters -->
    <!-- 
    Priority Checkboxes: Allows users to filter tasks based on their priority level.
    - Each checkbox has an ID corresponding to the priority it represents.
    - Value: Set to the priority level that will be used for filtering.
    -->
    <div>
        <input type="checkbox" id="priorityNone" value="None"> None
    </div>
    <div>
        <input type="checkbox" id="priorityLow" value="Low"> Low
    </div>
    <div>
        <input type="checkbox" id="priorityMedium" value="Medium"> Medium
    </div>
    <div>
        <input type="checkbox" id="priorityHigh" value="High"> High
    </div>
</div>

<!-- Reconciliation Dates Group -->
<div class="filter-group mb-4"> <!-- Grouping for date filters -->
    <label for="startDate" class="filter-label">Start Date:</label> <!-- Label for start date filter -->
    <!-- 
    Start Date Input: Allows filtering tasks based on their start date.
    - ID: startDate
    - Type: date (provides a date picker UI)
    - Value: Set to the current date by default using `strftime` for formatting.
    -->
    <input type="date" id="startDate" class="form-control mb-2" value="{{ date.today().strftime('%Y-%m-%d') }}">

    <label for="endDate" class="filter-label">Due Date:</label> <!-- Label for end date filter -->
    <!-- 
    End Date Input: Allows filtering tasks based on their due date.
    - ID: endDate
    - Type: date (provides a date picker UI)
    - Value: Set to the current date by default using `strftime` for formatting.
    -->
    <input type="date" id="endDate" class="form-control" value="{{ date.today().strftime('%Y-%m-%d') }}">
</div>

<!-- Filter Buttons -->
<div class="filter-buttons"> <!-- Grouping for filter action buttons -->
    <!-- 
    Apply Filters Button: Triggers the filtering process based on selected criteria.
    - ID: filterBtn
    - Class: btn btn-primary (Bootstrap classes for styling)
    -->
    <button id="filterBtn" class="btn btn-primary mb-2">Apply Filters</button>
    <!-- 
    Clear Filters Button: Resets all filters to their default state.
    - ID: clearFilterBtn
    - Class: btn btn-secondary (Bootstrap classes for styling)
    -->
    <button id="clearFilterBtn" class="btn btn-secondary mb-2">Clear Filters</button>
</div>


File: _tasks_body.html
----------------------------
<!-- 
    Developed by Stefania Galatolo, assisted by ChatGPT 4. 
    In this collaboration, ChatGPT helped Stefania keep things organized and smooth—because let's face it, 
    even with all that CS50 knowledge, things can get messy! 
-->

<!-- 
    tasks-wrapper: This wrapper contains the main task management table.
    The table displays all tasks retrieved from the backend and rendered dynamically using Flask's Jinja templating engine.
    Pagination buttons are generated by JavaScript and placed in the paginationContainer div.
    
    Inputs: 
    - Task data is provided by Flask as a list of task objects.
    - The task data includes attributes like task_id, pos_id, pos_name, task_status, etc.
    
    Outputs:
    - A dynamic table displaying the tasks, with support for pagination and responsiveness.
    - The JavaScript file 'tasksLookup.js' handles pagination and potentially other dynamic interactions.
-->
<div class="tasks-wrapper">
    <h2 class="mt-0">Tasks</h2>

    <!-- Pagination Controls -->
    <!-- Pagination controls are generated dynamically through JavaScript -->
    <div id="paginationContainer" class="pagination-container mt-3">
        <!-- Pagination buttons will be dynamically inserted here by the JavaScript -->
    </div>

    <!-- Table containing task details -->
    <!-- The table is populated dynamically using data provided by Flask (Jinja templating) -->
    <div class="table-responsive">
        <table class="table table-striped mt-3">
            <thead>
                <tr>
                    <!-- Columns are task attributes such as Task ID, POS ID, Name, etc. -->
                    <th>Task ID</th>
                    <th>POS ID</th>
                    <th>POS Name</th>
                    <th>Rec. Date</th>
                    <th>Certified</th>
                    <th>Task Desc.</th>
                    <th>Status</th>
                    <th>Priority</th>
                    <th>Blockers Desc.</th>
                    <th>Blockers Resp</th>
                    <th>Start Date</th>
                    <th>Due Date</th>
                    <th class="notes-column">Notes</th>
                </tr>
            </thead>
            <tbody id="taskTableBody">
                <!-- Task rows are dynamically generated by Flask's Jinja templating system -->
                {% for task in tasks %}
                <tr>
                    <td>{{ task.task_id }}</td>
                    <td>{{ task.pos_id }}</td>
                    <td>{{ task.pos_name }}</td>
                    <td>{{ task.rec_date }}</td>
                    <td>{{ task.rec_certified }}</td>
                    <td>{{ task.task_desc }}</td>
                    <td>{{ task.task_status }}</td>
                    <td>{{ task.task_priority }}</td>
                    <td>{{ task.blocker_desc }}</td>
                    <td>{{ task.blocker_responsible }}</td>
                    <td>{{ task.task_start_date }}</td>
                    <td>{{ task.task_due_date }}</td>
                    <td>{{ task.task_notes }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
</div>

<!-- 
    This script tag references the tasksLookup.js file located in the static/js/ folder.
    This JavaScript file is responsible for handling dynamic table updates, such as pagination, sorting, and filtering.
-->
<script src="{{ url_for('static', filename='js/tasksLookup.js') }}"></script>



--- Directory: ./core/__pycache__ ---

--- Directory: ./helpers ---

File: db_foreignkeys_update.py
----------------------------
from sqlalchemy import create_engine, MetaData, Table, text
from sqlalchemy.exc import SQLAlchemyError

# Connect to the SQLite database
db_path = 'sqlite:///taskflow.db'  # Using relative path
engine = create_engine(db_path)
metadata = MetaData()

# Reflect existing tables
metadata.reflect(bind=engine)

# Function to recreate tables with foreign keys using raw SQL commands
def recreate_tables_with_foreign_keys(engine):
    try:
        with engine.connect() as conn:
            # Begin a transaction
            with conn.begin():
                # Disable foreign key checks
                conn.execute(text("PRAGMA foreign_keys=OFF;"))

                # Rename the original tables
                conn.execute(text("ALTER TABLE tasks RENAME TO old_tasks;"))
                conn.execute(text("ALTER TABLE rec RENAME TO old_rec;"))
                conn.execute(text("ALTER TABLE blockers RENAME TO old_blockers;"))

                # Recreate the 'tasks' table with foreign keys
                conn.execute(text("""
                    CREATE TABLE tasks (
                        task_id INTEGER NOT NULL, 
                        task_desc VARCHAR, 
                        task_status VARCHAR, 
                        task_priority VARCHAR, 
                        task_start_date DATE, 
                        task_due_date DATE, 
                        task_notes VARCHAR, 
                        pos_id INTEGER NOT NULL, 
                        blocker_id INTEGER, 
                        rec_id INTEGER, 
                        PRIMARY KEY (task_id), 
                        CHECK (task_status IN ('Backlog', 'To Do', 'In Progress', 'Done')), 
                        CHECK (task_priority IN ('None', 'Low', 'Medium', 'High')),
                        FOREIGN KEY(pos_id) REFERENCES pos (pos_id),
                        FOREIGN KEY(blocker_id) REFERENCES blockers (blocker_id),
                        FOREIGN KEY(rec_id) REFERENCES rec (rec_id)
                    );
                """))

                # Recreate the 'rec' table with foreign keys
                conn.execute(text("""
                    CREATE TABLE rec (
                        rec_id INTEGER NOT NULL, 
                        rec_date DATE, 
                        rec_certified BOOLEAN, 
                        task_id INTEGER, 
                        pos_id INTEGER, 
                        blocker_id INTEGER, 
                        PRIMARY KEY (rec_id),
                        FOREIGN KEY(task_id) REFERENCES tasks (task_id),
                        FOREIGN KEY(pos_id) REFERENCES pos (pos_id),
                        FOREIGN KEY(blocker_id) REFERENCES blockers (blocker_id)
                    );
                """))

                # Recreate the 'blockers' table with foreign keys
                conn.execute(text("""
                    CREATE TABLE blockers (
                        blocker_id INTEGER NOT NULL, 
                        blocker_desc VARCHAR, 
                        blocker_responsible VARCHAR, 
                        blocker_resolved BOOLEAN, 
                        blocker_res_date DATE, 
                        pos_id INTEGER, 
                        rec_id INTEGER, 
                        task_id INTEGER, 
                        PRIMARY KEY (blocker_id),
                        FOREIGN KEY(pos_id) REFERENCES pos (pos_id),
                        FOREIGN KEY(rec_id) REFERENCES rec (rec_id),
                        FOREIGN KEY(task_id) REFERENCES tasks (task_id)
                    );
                """))

                # Copy data from the old tables to the new tables
                conn.execute(text("""
                    INSERT INTO tasks (task_id, task_desc, task_status, task_priority, task_start_date, task_due_date, task_notes, pos_id, blocker_id, rec_id)
                    SELECT task_id, task_desc, task_status, task_priority, task_start_date, task_due_date, task_notes, pos_id, blocker_id, rec_id FROM old_tasks;
                """))

                conn.execute(text("""
                    INSERT INTO rec (rec_id, rec_date, rec_certified, task_id, pos_id, blocker_id)
                    SELECT rec_id, rec_date, rec_certified, task_id, pos_id, blocker_id FROM old_rec;
                """))

                conn.execute(text("""
                    INSERT INTO blockers (blocker_id, blocker_desc, blocker_responsible, blocker_resolved, blocker_res_date, pos_id, rec_id, task_id)
                    SELECT blocker_id, blocker_desc, blocker_responsible, blocker_resolved, blocker_res_date, pos_id, rec_id, task_id FROM old_blockers;
                """))

                # Drop the old tables
                conn.execute(text("DROP TABLE old_tasks;"))
                conn.execute(text("DROP TABLE old_rec;"))
                conn.execute(text("DROP TABLE old_blockers;"))

                # Re-enable foreign key checks
                conn.execute(text("PRAGMA foreign_keys=ON;"))

            print("Foreign keys added successfully, and tables recreated.")
    except SQLAlchemyError as e:
        print(f"Error while recreating tables with foreign keys: {e}")

# Call the function to recreate tables with foreign keys
recreate_tables_with_foreign_keys(engine)



File: db_notnull_update.py
----------------------------
from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String, Date, Boolean, text
from sqlalchemy.sql import select
from sqlalchemy.exc import SQLAlchemyError

# Connect to the SQLite database
db_path = 'sqlite:///taskflow.db'  # Using relative path
engine = create_engine(db_path)
metadata = MetaData()

# Reflect existing tables
metadata.reflect(bind=engine)

# Backup original tables
with engine.connect() as conn:
    try:
        conn.execute(text("ALTER TABLE tasks RENAME TO tasks_backup;"))
        conn.execute(text("ALTER TABLE rec RENAME TO rec_backup;"))
        conn.execute(text("ALTER TABLE blockers RENAME TO blockers_backup;"))
        print("Backup tables created successfully.")
    except SQLAlchemyError as e:
        print(f"Error during renaming tables: {e}")
        exit(1)  # Exit if renaming fails

# Define new tables with updated schema (nullable fields)
tasks = Table(
    'tasks', metadata,
    Column('task_id', Integer, primary_key=True, nullable=False),
    Column('task_desc', String),
    Column('task_status', String),
    Column('task_priority', String),
    Column('task_start_date', Date),
    Column('task_due_date', Date),
    Column('task_notes', String),
    Column('pos_id', Integer, nullable=False),
    Column('blocker_id', Integer),
    Column('rec_id', Integer),
    extend_existing=True  # Allow redefinition
)

rec = Table(
    'rec', metadata,
    Column('rec_id', Integer, primary_key=True, nullable=False),
    Column('rec_date', Date),
    Column('rec_certified', Boolean),
    Column('task_id', Integer),
    Column('pos_id', Integer),
    Column('blocker_id', Integer),
    extend_existing=True  # Allow redefinition
)

blockers = Table(
    'blockers', metadata,
    Column('blocker_id', Integer, primary_key=True, nullable=False),
    Column('blocker_desc', String),
    Column('blocker_responsible', String),
    Column('blocker_resolved', Boolean),
    Column('blocker_res_date', Date),
    Column('pos_id', Integer),
    Column('rec_id', Integer),
    Column('task_id', Integer),
    extend_existing=True  # Allow redefinition
)

# Create new tables
metadata.create_all(engine)

# Insert data from backup tables to new tables
with engine.begin() as conn:  # Use begin() to ensure transactions
    try:
        # Copy data from tasks_backup to tasks
        tasks_backup = Table('tasks_backup', metadata, autoload_with=engine)
        select_stmt = select(tasks_backup)
        result = conn.execute(select_stmt)
        for row in result:
            conn.execute(tasks.insert().values(row._mapping))

        # Copy data from rec_backup to rec
        rec_backup = Table('rec_backup', metadata, autoload_with=engine)
        select_stmt = select(rec_backup)
        result = conn.execute(select_stmt)
        for row in result:
            conn.execute(rec.insert().values(row._mapping))

        # Copy data from blockers_backup to blockers
        blockers_backup = Table('blockers_backup', metadata, autoload_with=engine)
        select_stmt = select(blockers_backup)
        result = conn.execute(select_stmt)
        for row in result:
            conn.execute(blockers.insert().values(row._mapping))

        print("Data copied successfully to new tables.")
        
    except SQLAlchemyError as e:
        print(f"Error during data copying: {e}")
        exit(1)  # Exit if data copying fails

# Drop the backup tables
with engine.connect() as conn:
    try:
        # Disable foreign key checks to drop tables safely
        conn.execute(text("PRAGMA foreign_keys=OFF;"))
        
        # Drop the backup tables
        conn.execute(text("DROP TABLE IF EXISTS tasks_backup;"))
        conn.execute(text("DROP TABLE IF EXISTS rec_backup;"))
        conn.execute(text("DROP TABLE IF EXISTS blockers_backup;"))

        # Re-enable foreign key checks
        conn.execute(text("PRAGMA foreign_keys=ON;"))

        print("Backup tables dropped successfully.")
    except SQLAlchemyError as e:
        print(f"Error during dropping backup tables: {e}")

print("Database schema updated successfully.")



File: db_setup.py
----------------------------
import sqlite3
import csv
from datetime import datetime
from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String, Date, Boolean, ForeignKey, CheckConstraint, exc

"""
This script converts a CSV file containing task data into a relational SQLite database. 
It first loads the data into a temporary in-memory SQLite database using the `sqlite3` module,
and then transfers the data to a final SQLite database managed by SQLAlchemy.

Modules:
    - sqlite3: For interacting with SQLite databases.
    - csv: For reading CSV files.
    - datetime: For handling date conversion.
    - sqlalchemy: For database interaction and schema definition.

Steps:
    1. Convert CSV data into a temporary SQLite database.
    2. Create a final SQLite database with a specified schema using SQLAlchemy.
    3. Transfer data from the temporary database to the final database.
"""

# Paths for the databases
csv_file_path = 'kb.csv'  # Path to the CSV file that contains task data
taskflow_db_path = 'sqlite:///taskflow.db'  # Path to the final SQLite database

# Step 1: Convert CSV to Temporary SQLite Database using sqlite3

# Create a temporary SQLite database in memory
temp_db = ':memory:'  # This creates an in-memory SQLite database, which is temporary and faster

# Connect to the temporary SQLite database
conn = sqlite3.connect(temp_db)  # Establishing a connection to the in-memory SQLite database
c = conn.cursor()  # Creating a cursor object to interact with the database

# Create temp_tasks table in the temporary SQLite database
c.execute('''
CREATE TABLE IF NOT EXISTS temp_tasks (
    pos_id INTEGER,
    reconciliation_date TEXT,
    reconciliation_certified TEXT,
    task_description TEXT,
    task_status TEXT,
    task_priority TEXT,
    task_start_date TEXT,
    task_due_date TEXT,
    task_notes TEXT
)
''')
# The above SQL command creates a table named `temp_tasks` with columns that correspond to the task data fields.

# Function to convert CSV dates from DD-MMM format to YYYY-MM-DD format
def convert_date(date_str):
    """
    Converts a date string from 'DD-MMM' format to 'YYYY-MM-DD' format.
    The year is set to 2024.

    Args:
        date_str (str): The date string in 'DD-MMM' format.

    Returns:
        str: The date string in 'YYYY-MM-DD' format.
    """
    return datetime.strptime(date_str, '%d-%b').replace(year=2024).strftime('%Y-%m-%d')

# Read and insert CSV data into the temp_tasks table
with open(csv_file_path, newline='') as csvfile:  # Opening the CSV file
    reader = csv.DictReader(csvfile)  # Creating a CSV dictionary reader to read rows as dictionaries
    for row in reader:  # Looping through each row in the CSV file
        c.execute('''
        INSERT INTO temp_tasks (pos_id, reconciliation_date, reconciliation_certified, task_description, task_status, task_priority, task_start_date, task_due_date, task_notes)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            int(row['pos_id']),  # Convert pos_id to integer
            convert_date(row['reconciliation_date']),  # Convert reconciliation_date to 'YYYY-MM-DD' format
            row['reconciliation_certified'].lower(),  # Convert reconciliation_certified to lowercase string
            row['task_description'],  # Task description as a string
            row['task_status'],  # Task status as a string
            row['task_priority'],  # Task priority as a string
            convert_date(row['task_start_date']),  # Convert task_start_date to 'YYYY-MM-DD' format
            convert_date(row['task_due_date']),  # Convert task_due_date to 'YYYY-MM-DD' format
            row['task_notes']  # Task notes as a string
        ))

# Commit the data to the temp database to make sure all changes are saved
conn.commit()

# Step 2: Create the Final `taskflow` Database and Populate it Using SQLAlchemy Core

# Create SQLAlchemy engine and metadata for the taskflow database
engine = create_engine(taskflow_db_path, echo=True)  # SQLAlchemy engine to connect to the SQLite database
metadata = MetaData()  # Container object to hold schema details

# Define the Users table schema
users_table = Table('users', metadata,
    Column('user_id', Integer, primary_key=True),  # Primary key column
    Column('username', String, nullable=False, unique=True),  # Unique and non-nullable username
    Column('password_hash', String, nullable=False)  # Non-nullable password hash
)

# Define the POS table schema
pos_table = Table('pos', metadata,
    Column('pos_id', Integer, primary_key=True),  # Primary key column
    Column('pos_name', String, unique=True, nullable=False)  # Unique and non-nullable string column for POS names
)

# Define the Tasks table schema
tasks_table = Table('tasks', metadata,
    Column('task_id', Integer, primary_key=True, autoincrement=True),  # Auto-incrementing primary key
    Column('task_desc', String, nullable=False),  # Task description
    Column('task_status', String, CheckConstraint("task_status IN ('Backlog', 'To Do', 'In Progress', 'Done')"), nullable=False),  # Check constraint for task status
    Column('task_priority', String, CheckConstraint("task_priority IN ('None', 'Low', 'Medium', 'High')"), nullable=False),  # Check constraint for task priority
    Column('task_start_date', Date, nullable=False),  # Task start date
    Column('task_due_date', Date, nullable=False),  # Task due date
    Column('task_notes', String),  # Task notes
    Column('pos_id', Integer, ForeignKey('pos.pos_id'), nullable=False),  # Foreign key referencing POS table
    Column('blocker_id', Integer, ForeignKey('blockers.blocker_id')),  # Foreign key referencing blockers table
    Column('rec_id', Integer, ForeignKey('rec.rec_id'))  # Foreign key referencing rec table
)

# Define the Rec table schema
rec_table = Table('rec', metadata,
    Column('rec_id', Integer, primary_key=True, autoincrement=True),  # Auto-incrementing primary key
    Column('rec_date', Date, nullable=False),  # Reconciliation date
    Column('rec_certified', Boolean, nullable=False),  # Reconciliation certified status
    Column('task_id', Integer, ForeignKey('tasks.task_id')),  # Foreign key referencing tasks table
    Column('pos_id', Integer, ForeignKey('pos.pos_id')),  # Foreign key referencing POS table
    Column('blocker_id', Integer, ForeignKey('blockers.blocker_id'))  # Foreign key referencing blockers table
)

# Define the Blockers table schema
blockers_table = Table('blockers', metadata,
    Column('blocker_id', Integer, primary_key=True, autoincrement=True),  # Auto-incrementing primary key
    Column('blocker_desc', String, nullable=False),  # Blocker description
    Column('blocker_responsible', String, nullable=False),  # Blocker responsible person/role
    Column('blocker_resolved', Boolean, nullable=False),  # Blocker resolved status
    Column('blocker_res_date', Date, nullable=False),  # Blocker resolution date
    Column('pos_id', Integer, ForeignKey('pos.pos_id')),  # Foreign key referencing POS table
    Column('rec_id', Integer, ForeignKey('rec.rec_id')),  # Foreign key referencing rec table
    Column('task_id', Integer, ForeignKey('tasks.task_id'))  # Foreign key referencing tasks table
)

# Create the tables in the taskflow database based on the above schema definitions
metadata.create_all(engine)

# Insert POS data into the taskflow database
pos_data = [
    {'pos_id': 1, 'pos_name': "Bagnore"},
    {'pos_id': 2, 'pos_name': "Vivo d'Orcia"},
    {'pos_id': 7, 'pos_name': "Bagnolo"},
    {'pos_id': 9, 'pos_name': "Castiglione d'Orcia"},
    {'pos_id': 13, 'pos_name': "Castell'Azzara"},
    {'pos_id': 14, 'pos_name': "Abbadia San Salvatore"},
    {'pos_id': 17, 'pos_name': "Arcidosso"},
    {'pos_id': 18, 'pos_name': "Pienza"},
    {'pos_id': 20, 'pos_name': "Pitigliano"},
    {'pos_id': 27, 'pos_name': "Castelnuovo Berardenga"},
    {'pos_id': 29, 'pos_name': "Canino"},
    {'pos_id': 30, 'pos_name': "Grotte di Castro"},
    {'pos_id': 31, 'pos_name': "Bolsena"},
    {'pos_id': 32, 'pos_name': "Montalto di Castro"},
    {'pos_id': 33, 'pos_name': "Manciano"},
    {'pos_id': 35, 'pos_name': "Grotte Santo Stefano"},
    {'pos_id': 36, 'pos_name': "Castelnuovo Val di Cecina"},
    {'pos_id': 37, 'pos_name': "Pomarance"},
    {'pos_id': 38, 'pos_name': "Larderello"},
    {'pos_id': 39, 'pos_name': "Peccioli"},
    {'pos_id': 40, 'pos_name': "Montaione"},
    {'pos_id': 41, 'pos_name': "Santa Fiora"},
    {'pos_id': 42, 'pos_name': "Castel del Piano"},
    {'pos_id': 43, 'pos_name': "Piancastagnaio"},
    {'pos_id': 44, 'pos_name': "Paganico"},
    {'pos_id': 45, 'pos_name': "Monticiano"},
    {'pos_id': 46, 'pos_name': "Capranica"},
    {'pos_id': 48, 'pos_name': "Seggiano"},
    {'pos_id': 49, 'pos_name': "Sede"}
]

# Insert the POS data into the `pos` table in the final database
try:
    with engine.begin() as conn:  # Use engine.begin() to ensure the transaction is properly managed
        conn.execute(pos_table.insert(), pos_data)  # Executing the insert statement with the pos_data list
    print("POS data inserted successfully.")
except exc.SQLAlchemyError as e:
    print(f"Error inserting POS data: {e}")

# Transfer data from the temporary SQLite database to the final taskflow database
temp_cursor = c.execute('SELECT * FROM temp_tasks')  # Selecting all rows from the temp_tasks table
task_rows = temp_cursor.fetchall()  # Fetching all rows as a list of tuples

# Inserting data into the final database using SQLAlchemy Core
try:
    with engine.begin() as conn:  # Use engine.begin() to ensure the transaction is properly managed
        for row in task_rows:  # Loop through each row of data
            task_id_result = conn.execute(tasks_table.insert().values(
                pos_id=row[0],  # Integer value for POS ID
                task_desc=row[3],  # Task description string
                task_status=row[4],  # Task status string
                task_priority=row[5],  # Task priority string
                task_start_date=datetime.strptime(row[6], '%Y-%m-%d').date(),  # Convert start date string to date
                task_due_date=datetime.strptime(row[7], '%Y-%m-%d').date(),  # Convert due date string to date
                task_notes=row[8]  # Task notes string
            ))
            # Get the last inserted task_id
            task_id = task_id_result.inserted_primary_key[0]

            # Insert into rec table with the generated task_id
            rec_id_result = conn.execute(rec_table.insert().values(
                rec_date=datetime.strptime(row[1], '%Y-%m-%d').date(),
                rec_certified=row[2] == 'true',
                task_id=task_id,
                pos_id=row[0]
            ))

            rec_id = rec_id_result.inserted_primary_key[0]

            # Update the task row to include the rec_id
            conn.execute(tasks_table.update().where(tasks_table.c.task_id == task_id).values(rec_id=rec_id))
            
    print("Tasks and rec tables populated successfully.")
except exc.SQLAlchemyError as e:  # Handling any SQLAlchemy errors
    print(f"Error occurred while populating tasks and rec tables: {e}")

print("Database created and populated successfully.")  # Final confirmation message





File: cons.py
----------------------------
import os

def consolidate_code_by_structure(output_file='all_code_structure.txt'):
    with open(output_file, 'w') as outfile:
        # Walk through the directory
        for root, dirs, files in os.walk('.'):
            # Skip the current directory if it's the root where the script is located
            if root == '.':
                continue

            # Write the directory as a header
            outfile.write(f'\n--- Directory: {root} ---\n')
            
            for file in files:
                # Filter for specific file types: .py, .html, .css, .js, and .md
                if file.endswith(('.py', '.html', '.css', '.js', '.md')):
                    file_path = os.path.join(root, file)
                    
                    # Write the file name as a sub-header
                    outfile.write(f'\nFile: {file}\n')
                    outfile.write('----------------------------\n')

                    # Write the content of the file
                    with open(file_path, 'r') as infile:
                        outfile.write(infile.read())
                        outfile.write('\n\n')

# Run the function
consolidate_code_by_structure()



File: db_foreignkeys_update.py
----------------------------
from sqlalchemy import create_engine, MetaData, Table, text
from sqlalchemy.exc import SQLAlchemyError

# Connect to the SQLite database
db_path = 'sqlite:///taskflow.db'  # Using relative path
engine = create_engine(db_path)
metadata = MetaData()

# Reflect existing tables
metadata.reflect(bind=engine)

# Function to recreate tables with foreign keys using raw SQL commands
def recreate_tables_with_foreign_keys(engine):
    try:
        with engine.connect() as conn:
            # Begin a transaction
            with conn.begin():
                # Disable foreign key checks
                conn.execute(text("PRAGMA foreign_keys=OFF;"))

                # Rename the original tables
                conn.execute(text("ALTER TABLE tasks RENAME TO old_tasks;"))
                conn.execute(text("ALTER TABLE rec RENAME TO old_rec;"))
                conn.execute(text("ALTER TABLE blockers RENAME TO old_blockers;"))

                # Recreate the 'tasks' table with foreign keys
                conn.execute(text("""
                    CREATE TABLE tasks (
                        task_id INTEGER NOT NULL, 
                        task_desc VARCHAR, 
                        task_status VARCHAR, 
                        task_priority VARCHAR, 
                        task_start_date DATE, 
                        task_due_date DATE, 
                        task_notes VARCHAR, 
                        pos_id INTEGER NOT NULL, 
                        blocker_id INTEGER, 
                        rec_id INTEGER, 
                        PRIMARY KEY (task_id), 
                        CHECK (task_status IN ('Backlog', 'To Do', 'In Progress', 'Done')), 
                        CHECK (task_priority IN ('None', 'Low', 'Medium', 'High')),
                        FOREIGN KEY(pos_id) REFERENCES pos (pos_id),
                        FOREIGN KEY(blocker_id) REFERENCES blockers (blocker_id),
                        FOREIGN KEY(rec_id) REFERENCES rec (rec_id)
                    );
                """))

                # Recreate the 'rec' table with foreign keys
                conn.execute(text("""
                    CREATE TABLE rec (
                        rec_id INTEGER NOT NULL, 
                        rec_date DATE, 
                        rec_certified BOOLEAN, 
                        task_id INTEGER, 
                        pos_id INTEGER, 
                        blocker_id INTEGER, 
                        PRIMARY KEY (rec_id),
                        FOREIGN KEY(task_id) REFERENCES tasks (task_id),
                        FOREIGN KEY(pos_id) REFERENCES pos (pos_id),
                        FOREIGN KEY(blocker_id) REFERENCES blockers (blocker_id)
                    );
                """))

                # Recreate the 'blockers' table with foreign keys
                conn.execute(text("""
                    CREATE TABLE blockers (
                        blocker_id INTEGER NOT NULL, 
                        blocker_desc VARCHAR, 
                        blocker_responsible VARCHAR, 
                        blocker_resolved BOOLEAN, 
                        blocker_res_date DATE, 
                        pos_id INTEGER, 
                        rec_id INTEGER, 
                        task_id INTEGER, 
                        PRIMARY KEY (blocker_id),
                        FOREIGN KEY(pos_id) REFERENCES pos (pos_id),
                        FOREIGN KEY(rec_id) REFERENCES rec (rec_id),
                        FOREIGN KEY(task_id) REFERENCES tasks (task_id)
                    );
                """))

                # Copy data from the old tables to the new tables
                conn.execute(text("""
                    INSERT INTO tasks (task_id, task_desc, task_status, task_priority, task_start_date, task_due_date, task_notes, pos_id, blocker_id, rec_id)
                    SELECT task_id, task_desc, task_status, task_priority, task_start_date, task_due_date, task_notes, pos_id, blocker_id, rec_id FROM old_tasks;
                """))

                conn.execute(text("""
                    INSERT INTO rec (rec_id, rec_date, rec_certified, task_id, pos_id, blocker_id)
                    SELECT rec_id, rec_date, rec_certified, task_id, pos_id, blocker_id FROM old_rec;
                """))

                conn.execute(text("""
                    INSERT INTO blockers (blocker_id, blocker_desc, blocker_responsible, blocker_resolved, blocker_res_date, pos_id, rec_id, task_id)
                    SELECT blocker_id, blocker_desc, blocker_responsible, blocker_resolved, blocker_res_date, pos_id, rec_id, task_id FROM old_blockers;
                """))

                # Drop the old tables
                conn.execute(text("DROP TABLE old_tasks;"))
                conn.execute(text("DROP TABLE old_rec;"))
                conn.execute(text("DROP TABLE old_blockers;"))

                # Re-enable foreign key checks
                conn.execute(text("PRAGMA foreign_keys=ON;"))

            print("Foreign keys added successfully, and tables recreated.")
    except SQLAlchemyError as e:
        print(f"Error while recreating tables with foreign keys: {e}")

# Call the function to recreate tables with foreign keys
recreate_tables_with_foreign_keys(engine)



File: db_notnull_update.py
----------------------------
from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String, Date, Boolean, text
from sqlalchemy.sql import select
from sqlalchemy.exc import SQLAlchemyError

# Connect to the SQLite database
db_path = 'sqlite:///taskflow.db'  # Using relative path
engine = create_engine(db_path)
metadata = MetaData()

# Reflect existing tables
metadata.reflect(bind=engine)

# Backup original tables
with engine.connect() as conn:
    try:
        conn.execute(text("ALTER TABLE tasks RENAME TO tasks_backup;"))
        conn.execute(text("ALTER TABLE rec RENAME TO rec_backup;"))
        conn.execute(text("ALTER TABLE blockers RENAME TO blockers_backup;"))
        print("Backup tables created successfully.")
    except SQLAlchemyError as e:
        print(f"Error during renaming tables: {e}")
        exit(1)  # Exit if renaming fails

# Define new tables with updated schema (nullable fields)
tasks = Table(
    'tasks', metadata,
    Column('task_id', Integer, primary_key=True, nullable=False),
    Column('task_desc', String),
    Column('task_status', String),
    Column('task_priority', String),
    Column('task_start_date', Date),
    Column('task_due_date', Date),
    Column('task_notes', String),
    Column('pos_id', Integer, nullable=False),
    Column('blocker_id', Integer),
    Column('rec_id', Integer),
    extend_existing=True  # Allow redefinition
)

rec = Table(
    'rec', metadata,
    Column('rec_id', Integer, primary_key=True, nullable=False),
    Column('rec_date', Date),
    Column('rec_certified', Boolean),
    Column('task_id', Integer),
    Column('pos_id', Integer),
    Column('blocker_id', Integer),
    extend_existing=True  # Allow redefinition
)

blockers = Table(
    'blockers', metadata,
    Column('blocker_id', Integer, primary_key=True, nullable=False),
    Column('blocker_desc', String),
    Column('blocker_responsible', String),
    Column('blocker_resolved', Boolean),
    Column('blocker_res_date', Date),
    Column('pos_id', Integer),
    Column('rec_id', Integer),
    Column('task_id', Integer),
    extend_existing=True  # Allow redefinition
)

# Create new tables
metadata.create_all(engine)

# Insert data from backup tables to new tables
with engine.begin() as conn:  # Use begin() to ensure transactions
    try:
        # Copy data from tasks_backup to tasks
        tasks_backup = Table('tasks_backup', metadata, autoload_with=engine)
        select_stmt = select(tasks_backup)
        result = conn.execute(select_stmt)
        for row in result:
            conn.execute(tasks.insert().values(row._mapping))

        # Copy data from rec_backup to rec
        rec_backup = Table('rec_backup', metadata, autoload_with=engine)
        select_stmt = select(rec_backup)
        result = conn.execute(select_stmt)
        for row in result:
            conn.execute(rec.insert().values(row._mapping))

        # Copy data from blockers_backup to blockers
        blockers_backup = Table('blockers_backup', metadata, autoload_with=engine)
        select_stmt = select(blockers_backup)
        result = conn.execute(select_stmt)
        for row in result:
            conn.execute(blockers.insert().values(row._mapping))

        print("Data copied successfully to new tables.")
        
    except SQLAlchemyError as e:
        print(f"Error during data copying: {e}")
        exit(1)  # Exit if data copying fails

# Drop the backup tables
with engine.connect() as conn:
    try:
        # Disable foreign key checks to drop tables safely
        conn.execute(text("PRAGMA foreign_keys=OFF;"))
        
        # Drop the backup tables
        conn.execute(text("DROP TABLE IF EXISTS tasks_backup;"))
        conn.execute(text("DROP TABLE IF EXISTS rec_backup;"))
        conn.execute(text("DROP TABLE IF EXISTS blockers_backup;"))

        # Re-enable foreign key checks
        conn.execute(text("PRAGMA foreign_keys=ON;"))

        print("Backup tables dropped successfully.")
    except SQLAlchemyError as e:
        print(f"Error during dropping backup tables: {e}")

print("Database schema updated successfully.")



File: db_schema.txt
----------------------------
CREATE TABLE users (
        user_id INTEGER NOT NULL, 
        username VARCHAR NOT NULL, 
        password_hash VARCHAR NOT NULL, 
        PRIMARY KEY (user_id), 
        UNIQUE (username)
);
CREATE TABLE pos (
        pos_id INTEGER NOT NULL, 
        pos_name VARCHAR, 
        PRIMARY KEY (pos_id), 
        UNIQUE (pos_name)
);
CREATE TABLE rec (
        rec_id INTEGER NOT NULL, 
        rec_date DATE, 
        rec_certified BOOLEAN, 
        task_id INTEGER, 
        pos_id INTEGER, 
        blocker_id INTEGER, 
        PRIMARY KEY (rec_id), 
        FOREIGN KEY(task_id) REFERENCES tasks (task_id), 
        FOREIGN KEY(pos_id) REFERENCES pos (pos_id), 
        FOREIGN KEY(blocker_id) REFERENCES blockers (blocker_id)
);
CREATE TABLE blockers (
        blocker_id INTEGER NOT NULL, 
        blocker_desc VARCHAR, 
        blocker_responsible VARCHAR, 
        blocker_resolved BOOLEAN, 
        blocker_res_date DATE, 
        pos_id INTEGER, 
        rec_id INTEGER, 
        task_id INTEGER, 
        PRIMARY KEY (blocker_id), 
        FOREIGN KEY(pos_id) REFERENCES pos (pos_id), 
        FOREIGN KEY(rec_id) REFERENCES rec (rec_id), 
        FOREIGN KEY(task_id) REFERENCES tasks (task_id)
);
CREATE TABLE tasks (
        task_id INTEGER NOT NULL, 
        task_desc VARCHAR, 
        task_status VARCHAR, 
        task_priority VARCHAR, 
        task_start_date DATE, 
        task_due_date DATE, 
        task_notes VARCHAR, 
        pos_id INTEGER, 
        blocker_id INTEGER, 
        rec_id INTEGER, 
        PRIMARY KEY (task_id), 
        FOREIGN KEY(pos_id) REFERENCES pos (pos_id), 
        FOREIGN KEY(blocker_id) REFERENCES blockers (blocker_id), 
        FOREIGN KEY(rec_id) REFERENCES rec (rec_id)
);



File: db_setup.py
----------------------------
import sqlite3
import csv
from datetime import datetime
from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String, Date, Boolean, ForeignKey, CheckConstraint, exc

"""
This script converts a CSV file containing task data into a relational SQLite database. 
It first loads the data into a temporary in-memory SQLite database using the `sqlite3` module,
and then transfers the data to a final SQLite database managed by SQLAlchemy.

Modules:
    - sqlite3: For interacting with SQLite databases.
    - csv: For reading CSV files.
    - datetime: For handling date conversion.
    - sqlalchemy: For database interaction and schema definition.

Steps:
    1. Convert CSV data into a temporary SQLite database.
    2. Create a final SQLite database with a specified schema using SQLAlchemy.
    3. Transfer data from the temporary database to the final database.
"""

# Paths for the databases
csv_file_path = 'kb.csv'  # Path to the CSV file that contains task data
taskflow_db_path = 'sqlite:///taskflow.db'  # Path to the final SQLite database

# Step 1: Convert CSV to Temporary SQLite Database using sqlite3

# Create a temporary SQLite database in memory
temp_db = ':memory:'  # This creates an in-memory SQLite database, which is temporary and faster

# Connect to the temporary SQLite database
conn = sqlite3.connect(temp_db)  # Establishing a connection to the in-memory SQLite database
c = conn.cursor()  # Creating a cursor object to interact with the database

# Create temp_tasks table in the temporary SQLite database
c.execute('''
CREATE TABLE IF NOT EXISTS temp_tasks (
    pos_id INTEGER,
    reconciliation_date TEXT,
    reconciliation_certified TEXT,
    task_description TEXT,
    task_status TEXT,
    task_priority TEXT,
    task_start_date TEXT,
    task_due_date TEXT,
    task_notes TEXT
)
''')
# The above SQL command creates a table named `temp_tasks` with columns that correspond to the task data fields.

# Function to convert CSV dates from DD-MMM format to YYYY-MM-DD format
def convert_date(date_str):
    """
    Converts a date string from 'DD-MMM' format to 'YYYY-MM-DD' format.
    The year is set to 2024.

    Args:
        date_str (str): The date string in 'DD-MMM' format.

    Returns:
        str: The date string in 'YYYY-MM-DD' format.
    """
    return datetime.strptime(date_str, '%d-%b').replace(year=2024).strftime('%Y-%m-%d')

# Read and insert CSV data into the temp_tasks table
with open(csv_file_path, newline='') as csvfile:  # Opening the CSV file
    reader = csv.DictReader(csvfile)  # Creating a CSV dictionary reader to read rows as dictionaries
    for row in reader:  # Looping through each row in the CSV file
        c.execute('''
        INSERT INTO temp_tasks (pos_id, reconciliation_date, reconciliation_certified, task_description, task_status, task_priority, task_start_date, task_due_date, task_notes)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            int(row['pos_id']),  # Convert pos_id to integer
            convert_date(row['reconciliation_date']),  # Convert reconciliation_date to 'YYYY-MM-DD' format
            row['reconciliation_certified'].lower(),  # Convert reconciliation_certified to lowercase string
            row['task_description'],  # Task description as a string
            row['task_status'],  # Task status as a string
            row['task_priority'],  # Task priority as a string
            convert_date(row['task_start_date']),  # Convert task_start_date to 'YYYY-MM-DD' format
            convert_date(row['task_due_date']),  # Convert task_due_date to 'YYYY-MM-DD' format
            row['task_notes']  # Task notes as a string
        ))

# Commit the data to the temp database to make sure all changes are saved
conn.commit()

# Step 2: Create the Final `taskflow` Database and Populate it Using SQLAlchemy Core

# Create SQLAlchemy engine and metadata for the taskflow database
engine = create_engine(taskflow_db_path, echo=True)  # SQLAlchemy engine to connect to the SQLite database
metadata = MetaData()  # Container object to hold schema details

# Define the Users table schema
users_table = Table('users', metadata,
    Column('user_id', Integer, primary_key=True),  # Primary key column
    Column('username', String, nullable=False, unique=True),  # Unique and non-nullable username
    Column('password_hash', String, nullable=False)  # Non-nullable password hash
)

# Define the POS table schema
pos_table = Table('pos', metadata,
    Column('pos_id', Integer, primary_key=True),  # Primary key column
    Column('pos_name', String, unique=True, nullable=False)  # Unique and non-nullable string column for POS names
)

# Define the Tasks table schema
tasks_table = Table('tasks', metadata,
    Column('task_id', Integer, primary_key=True, autoincrement=True),  # Auto-incrementing primary key
    Column('task_desc', String, nullable=False),  # Task description
    Column('task_status', String, CheckConstraint("task_status IN ('Backlog', 'To Do', 'In Progress', 'Done')"), nullable=False),  # Check constraint for task status
    Column('task_priority', String, CheckConstraint("task_priority IN ('None', 'Low', 'Medium', 'High')"), nullable=False),  # Check constraint for task priority
    Column('task_start_date', Date, nullable=False),  # Task start date
    Column('task_due_date', Date, nullable=False),  # Task due date
    Column('task_notes', String),  # Task notes
    Column('pos_id', Integer, ForeignKey('pos.pos_id'), nullable=False),  # Foreign key referencing POS table
    Column('blocker_id', Integer, ForeignKey('blockers.blocker_id')),  # Foreign key referencing blockers table
    Column('rec_id', Integer, ForeignKey('rec.rec_id'))  # Foreign key referencing rec table
)

# Define the Rec table schema
rec_table = Table('rec', metadata,
    Column('rec_id', Integer, primary_key=True, autoincrement=True),  # Auto-incrementing primary key
    Column('rec_date', Date, nullable=False),  # Reconciliation date
    Column('rec_certified', Boolean, nullable=False),  # Reconciliation certified status
    Column('task_id', Integer, ForeignKey('tasks.task_id')),  # Foreign key referencing tasks table
    Column('pos_id', Integer, ForeignKey('pos.pos_id')),  # Foreign key referencing POS table
    Column('blocker_id', Integer, ForeignKey('blockers.blocker_id'))  # Foreign key referencing blockers table
)

# Define the Blockers table schema
blockers_table = Table('blockers', metadata,
    Column('blocker_id', Integer, primary_key=True, autoincrement=True),  # Auto-incrementing primary key
    Column('blocker_desc', String, nullable=False),  # Blocker description
    Column('blocker_responsible', String, nullable=False),  # Blocker responsible person/role
    Column('blocker_resolved', Boolean, nullable=False),  # Blocker resolved status
    Column('blocker_res_date', Date, nullable=False),  # Blocker resolution date
    Column('pos_id', Integer, ForeignKey('pos.pos_id')),  # Foreign key referencing POS table
    Column('rec_id', Integer, ForeignKey('rec.rec_id')),  # Foreign key referencing rec table
    Column('task_id', Integer, ForeignKey('tasks.task_id'))  # Foreign key referencing tasks table
)

# Create the tables in the taskflow database based on the above schema definitions
metadata.create_all(engine)

# Insert POS data into the taskflow database
pos_data = [
    {'pos_id': 1, 'pos_name': "Bagnore"},
    {'pos_id': 2, 'pos_name': "Vivo d'Orcia"},
    {'pos_id': 7, 'pos_name': "Bagnolo"},
    {'pos_id': 9, 'pos_name': "Castiglione d'Orcia"},
    {'pos_id': 13, 'pos_name': "Castell'Azzara"},
    {'pos_id': 14, 'pos_name': "Abbadia San Salvatore"},
    {'pos_id': 17, 'pos_name': "Arcidosso"},
    {'pos_id': 18, 'pos_name': "Pienza"},
    {'pos_id': 20, 'pos_name': "Pitigliano"},
    {'pos_id': 27, 'pos_name': "Castelnuovo Berardenga"},
    {'pos_id': 29, 'pos_name': "Canino"},
    {'pos_id': 30, 'pos_name': "Grotte di Castro"},
    {'pos_id': 31, 'pos_name': "Bolsena"},
    {'pos_id': 32, 'pos_name': "Montalto di Castro"},
    {'pos_id': 33, 'pos_name': "Manciano"},
    {'pos_id': 35, 'pos_name': "Grotte Santo Stefano"},
    {'pos_id': 36, 'pos_name': "Castelnuovo Val di Cecina"},
    {'pos_id': 37, 'pos_name': "Pomarance"},
    {'pos_id': 38, 'pos_name': "Larderello"},
    {'pos_id': 39, 'pos_name': "Peccioli"},
    {'pos_id': 40, 'pos_name': "Montaione"},
    {'pos_id': 41, 'pos_name': "Santa Fiora"},
    {'pos_id': 42, 'pos_name': "Castel del Piano"},
    {'pos_id': 43, 'pos_name': "Piancastagnaio"},
    {'pos_id': 44, 'pos_name': "Paganico"},
    {'pos_id': 45, 'pos_name': "Monticiano"},
    {'pos_id': 46, 'pos_name': "Capranica"},
    {'pos_id': 48, 'pos_name': "Seggiano"},
    {'pos_id': 49, 'pos_name': "Sede"}
]

# Insert the POS data into the `pos` table in the final database
try:
    with engine.begin() as conn:  # Use engine.begin() to ensure the transaction is properly managed
        conn.execute(pos_table.insert(), pos_data)  # Executing the insert statement with the pos_data list
    print("POS data inserted successfully.")
except exc.SQLAlchemyError as e:
    print(f"Error inserting POS data: {e}")

# Transfer data from the temporary SQLite database to the final taskflow database
temp_cursor = c.execute('SELECT * FROM temp_tasks')  # Selecting all rows from the temp_tasks table
task_rows = temp_cursor.fetchall()  # Fetching all rows as a list of tuples

# Inserting data into the final database using SQLAlchemy Core
try:
    with engine.begin() as conn:  # Use engine.begin() to ensure the transaction is properly managed
        for row in task_rows:  # Loop through each row of data
            task_id_result = conn.execute(tasks_table.insert().values(
                pos_id=row[0],  # Integer value for POS ID
                task_desc=row[3],  # Task description string
                task_status=row[4],  # Task status string
                task_priority=row[5],  # Task priority string
                task_start_date=datetime.strptime(row[6], '%Y-%m-%d').date(),  # Convert start date string to date
                task_due_date=datetime.strptime(row[7], '%Y-%m-%d').date(),  # Convert due date string to date
                task_notes=row[8]  # Task notes string
            ))
            # Get the last inserted task_id
            task_id = task_id_result.inserted_primary_key[0]

            # Insert into rec table with the generated task_id
            rec_id_result = conn.execute(rec_table.insert().values(
                rec_date=datetime.strptime(row[1], '%Y-%m-%d').date(),
                rec_certified=row[2] == 'true',
                task_id=task_id,
                pos_id=row[0]
            ))

            rec_id = rec_id_result.inserted_primary_key[0]

            # Update the task row to include the rec_id
            conn.execute(tasks_table.update().where(tasks_table.c.task_id == task_id).values(rec_id=rec_id))
            
    print("Tasks and rec tables populated successfully.")
except exc.SQLAlchemyError as e:  # Handling any SQLAlchemy errors
    print(f"Error occurred while populating tasks and rec tables: {e}")

print("Database created and populated successfully.")  # Final confirmation message



File: structure.txt
----------------------------
.
├── C__
│   └── Users
│       └── micro
│           └── Downloads
│               └── final
│                   └── tasks.db
├── README.md
├── __pycache__
│   ├── app.cpython-310.pyc
│   └── helpers.cpython-310.pyc
├── app.log
├── app.py
├── db_foreignkeys_update.py
├── db_notnull_update.py
├── db_setup.py
├── del_dev_HELPERS
│   ├── TaskFlow-Tasks-screenclip1.png
│   └── db_schema.txt
├── flask_session
│   ├── 00c6e53ddd4282b56027e7a75655bd85
│   ├── 115b8d1c96b0cb912808c4b8fd89e7ad
│   ├── 2029240f6d1128be89ddc32729463129
│   ├── 25c1bd5a07156187c7b0beed0a1614fd
│   ├── 3384a545330177f20598584fc4ebfec4
│   ├── 40dd680e8b8ffe1cbcd4bd5d3ca650c3
│   ├── 443cfce86d641e5456893efda28b5643
│   ├── 55e12fc15fbda0f54ced11c299115879
│   ├── 799e423e099248571fee7c4346753d29
│   ├── 812dac17609fb16bb678d4af000c9cdc
│   ├── 87eafa91e2f3a41a08836488b73f997c
│   ├── 98317db603d3d75d953039b897e5f565
│   ├── a440f90a8f56189a7f61483c8184f41a
│   ├── d404270ce7367bd70c451d8a1ece16fe
│   └── f57e7d336403e4d448a9c495e4ed1e0d
├── helpers.py
├── kb.csv
├── requirements.txt
├── static
│   ├── css
│   │   └── style.css
│   ├── images
│   └── js
│       ├── createTasks.js
│       ├── kanban.js
│       └── tasksLookup.js
├── structure.txt
├── taskflow - Copy.db
├── taskflow.db
├── taskflowold.db
└── templates
    ├── _create_form.html
    ├── _sidebar.html
    ├── _tasks_body.html
    ├── create.html
    ├── error.html
    ├── kanban.html
    ├── layout.html
    ├── login.html
    ├── modify.html
    ├── register.html
    └── tasks.html

13 directories, 48 files


